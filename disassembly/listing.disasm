Disassembly Listing for galeoTester1
Generated From:
C:/Users/Michel/MPLABXProjects/galeoTester1.X/dist/default/debug/galeoTester1.X.debug.elf
5 janv. 2024 14:08:14

---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/tester.c  --------------------------------------------
1:             /*
2:              * File:   tester.c
3:              * Author: Michel
4:              *
5:              * Created on 31 août 2023, 15:28
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "mcc_generated_files/mcc.h"
11:            #include "I2C_LCD.h"
12:            #include "tester.h"
13:            #include "display.h"
14:            #include <stdio.h>
15:            #include <string.h>
16:            
17:            void alimenter(bool active) {
1D89  0020     MOVLB 0x0
1D8A  00A3     MOVWF data
18:            
19:                if (active) {
1D8B  0823     MOVF data, W
1D8C  1903     BTFSC STATUS, 0x2
1D8D  2D8F     GOTO 0x58F
1D8E  2D90     GOTO 0x590
1D8F  2D93     GOTO 0x593
20:            
21:                    REL1_SetHigh();
1D90  0022     MOVLB 0x2
1D91  140C     BSF LATA, 0x0
1D92  2D95     GOTO 0x595
22:                } else {
23:                    REL1_SetLow();
1D93  0022     MOVLB 0x2
1D94  100C     BCF LATA, 0x0
24:                }
25:            }
1D95  0008     RETURN
26:            
27:            void pressBP1(bool active) {
1DBD  0020     MOVLB 0x0
1DBE  00A3     MOVWF data
28:            
29:                if (active) {
1DBF  0823     MOVF data, W
1DC0  1903     BTFSC STATUS, 0x2
1DC1  2DC3     GOTO 0x5C3
1DC2  2DC4     GOTO 0x5C4
1DC3  2DC7     GOTO 0x5C7
30:            
31:                    REL2_SetHigh();
1DC4  0022     MOVLB 0x2
1DC5  148C     BSF LATA, 0x1
1DC6  2DC9     GOTO 0x5C9
32:                } else {
33:                    REL2_SetLow();
1DC7  0022     MOVLB 0x2
1DC8  108C     BCF LATA, 0x1
34:                }
35:            }
1DC9  0008     RETURN
36:            
37:            void pressBP2(bool active) {
1DCA  0020     MOVLB 0x0
1DCB  00A3     MOVWF data
38:            
39:                if (active) {
1DCC  0823     MOVF data, W
1DCD  1903     BTFSC STATUS, 0x2
1DCE  2DD0     GOTO 0x5D0
1DCF  2DD1     GOTO 0x5D1
1DD0  2DD4     GOTO 0x5D4
40:            
41:                    REL3_SetHigh();
1DD1  0022     MOVLB 0x2
1DD2  150C     BSF LATA, 0x2
1DD3  2DD6     GOTO 0x5D6
42:                } else {
43:                    REL3_SetLow();
1DD4  0022     MOVLB 0x2
1DD5  110C     BCF LATA, 0x2
44:                }
45:            }
1DD6  0008     RETURN
46:            
47:            void setHorloge(bool active) {
1DF1  0020     MOVLB 0x0
1DF2  00A3     MOVWF data
48:            
49:                if (active) {
1DF3  0823     MOVF data, W
1DF4  1903     BTFSC STATUS, 0x2
1DF5  2DF7     GOTO 0x5F7
1DF6  2DF8     GOTO 0x5F8
1DF7  2DFB     GOTO 0x5FB
50:            
51:                    REL4_SetHigh();
1DF8  0022     MOVLB 0x2
1DF9  158C     BSF LATA, 0x3
1DFA  2DFD     GOTO 0x5FD
52:                } else {
53:                    REL4_SetLow();
1DFB  0022     MOVLB 0x2
1DFC  118C     BCF LATA, 0x3
54:                }
55:            
56:            }
1DFD  0008     RETURN
57:            
58:            bool testR1(bool active) {
1074  0020     MOVLB 0x0
1075  00A4     MOVWF Data
59:            
60:                bool result = false;
1076  01A3     CLRF data
61:                if (active) {
1077  0824     MOVF Data, W
1078  1903     BTFSC STATUS, 0x2
1079  287B     GOTO 0x7B
107A  287C     GOTO 0x7C
107B  2886     GOTO 0x86
62:            
63:                    if (IN1_GetValue() == 1 && IN2_GetValue() == 0) {
107C  1C0F     BTFSS PORTD, 0x0
107D  287F     GOTO 0x7F
107E  2880     GOTO 0x80
107F  2886     GOTO 0x86
1080  188F     BTFSC PORTD, 0x1
1081  2883     GOTO 0x83
1082  2884     GOTO 0x84
1083  2886     GOTO 0x86
64:            
65:                        result = true;
1084  01A3     CLRF data
1085  0AA3     INCF data, F
66:                    }
67:                }
68:            
69:                if (!active) {
1086  0824     MOVF Data, W
1087  1D03     BTFSS STATUS, 0x2
1088  288A     GOTO 0x8A
1089  288B     GOTO 0x8B
108A  2895     GOTO 0x95
70:            
71:                    if (IN1_GetValue() == 0 && IN2_GetValue() == 1) {
108B  180F     BTFSC PORTD, 0x0
108C  288E     GOTO 0x8E
108D  288F     GOTO 0x8F
108E  2895     GOTO 0x95
108F  1C8F     BTFSS PORTD, 0x1
1090  2892     GOTO 0x92
1091  2893     GOTO 0x93
1092  2895     GOTO 0x95
72:            
73:            
74:                        result = true;
1093  01A3     CLRF data
1094  0AA3     INCF data, F
75:                    }
76:                }
77:            
78:                return result;
1095  0823     MOVF data, W
79:            }
1096  0008     RETURN
80:            
81:            bool testR2(bool active) {
1097  0020     MOVLB 0x0
1098  00A4     MOVWF Data
82:            
83:                bool result = false;
1099  01A3     CLRF data
84:                if (active) {
109A  0824     MOVF Data, W
109B  1903     BTFSC STATUS, 0x2
109C  289E     GOTO 0x9E
109D  289F     GOTO 0x9F
109E  28A9     GOTO 0xA9
85:            
86:                    if (IN4_GetValue() == 1 && IN5_GetValue() == 0) {
109F  1D8F     BTFSS PORTD, 0x3
10A0  28A2     GOTO 0xA2
10A1  28A3     GOTO 0xA3
10A2  28A9     GOTO 0xA9
10A3  1A0F     BTFSC PORTD, 0x4
10A4  28A6     GOTO 0xA6
10A5  28A7     GOTO 0xA7
10A6  28A9     GOTO 0xA9
87:            
88:                        result = true;
10A7  01A3     CLRF data
10A8  0AA3     INCF data, F
89:                    }
90:                }
91:            
92:                if (!active) {
10A9  0824     MOVF Data, W
10AA  1D03     BTFSS STATUS, 0x2
10AB  28AD     GOTO 0xAD
10AC  28AE     GOTO 0xAE
10AD  28B8     GOTO 0xB8
93:            
94:                    if (IN4_GetValue() == 0 && IN5_GetValue() == 1) {
10AE  198F     BTFSC PORTD, 0x3
10AF  28B1     GOTO 0xB1
10B0  28B2     GOTO 0xB2
10B1  28B8     GOTO 0xB8
10B2  1E0F     BTFSS PORTD, 0x4
10B3  28B5     GOTO 0xB5
10B4  28B6     GOTO 0xB6
10B5  28B8     GOTO 0xB8
95:            
96:                        result = true;
10B6  01A3     CLRF data
10B7  0AA3     INCF data, F
97:                    }
98:                }
99:            
100:               return result;
10B8  0823     MOVF data, W
101:           }
10B9  0008     RETURN
102:           
103:           bool testR3(bool active) {
10BA  0020     MOVLB 0x0
10BB  00A4     MOVWF Data
104:           
105:           
106:               bool result = false;
10BC  01A3     CLRF data
107:               if (active) {
10BD  0824     MOVF Data, W
10BE  1903     BTFSC STATUS, 0x2
10BF  28C1     GOTO 0xC1
10C0  28C2     GOTO 0xC2
10C1  28CC     GOTO 0xCC
108:           
109:                   if (IN6_GetValue() == 1 && IN7_GetValue() == 0) {
10C2  1E8F     BTFSS PORTD, 0x5
10C3  28C5     GOTO 0xC5
10C4  28C6     GOTO 0xC6
10C5  28CC     GOTO 0xCC
10C6  1B0F     BTFSC PORTD, 0x6
10C7  28C9     GOTO 0xC9
10C8  28CA     GOTO 0xCA
10C9  28CC     GOTO 0xCC
110:           
111:                       result = true;
10CA  01A3     CLRF data
10CB  0AA3     INCF data, F
112:                   }
113:               }
114:           
115:               if (!active) {
10CC  0824     MOVF Data, W
10CD  1D03     BTFSS STATUS, 0x2
10CE  28D0     GOTO 0xD0
10CF  28D1     GOTO 0xD1
10D0  28DB     GOTO 0xDB
116:           
117:                   if (IN6_GetValue() == 0 && IN7_GetValue() == 1) {
10D1  1A8F     BTFSC PORTD, 0x5
10D2  28D4     GOTO 0xD4
10D3  28D5     GOTO 0xD5
10D4  28DB     GOTO 0xDB
10D5  1F0F     BTFSS PORTD, 0x6
10D6  28D8     GOTO 0xD8
10D7  28D9     GOTO 0xD9
10D8  28DB     GOTO 0xDB
118:           
119:                       result = true;
10D9  01A3     CLRF data
10DA  0AA3     INCF data, F
120:                   }
121:               }
122:           
123:               return result;
10DB  0823     MOVF data, W
124:           }
10DC  0008     RETURN
125:           
126:           bool testOK(bool active) {
1F6C  0020     MOVLB 0x0
1F6D  00A4     MOVWF Data
127:           
128:               bool result = false;
1F6E  01A3     CLRF data
129:               if (active) {
1F6F  0824     MOVF Data, W
1F70  1903     BTFSC STATUS, 0x2
1F71  2F73     GOTO 0x773
1F72  2F74     GOTO 0x774
1F73  2F7A     GOTO 0x77A
130:           
131:                   if (IN3_GetValue() == 0) {
1F74  190F     BTFSC PORTD, 0x2
1F75  2F77     GOTO 0x777
1F76  2F78     GOTO 0x778
1F77  2F7A     GOTO 0x77A
132:           
133:                       result = true;
1F78  01A3     CLRF data
1F79  0AA3     INCF data, F
134:                   }
135:               }
136:           
137:               if (!active) {
1F7A  0824     MOVF Data, W
1F7B  1D03     BTFSS STATUS, 0x2
1F7C  2F7E     GOTO 0x77E
1F7D  2F7F     GOTO 0x77F
1F7E  2F85     GOTO 0x785
138:           
139:                   if (IN3_GetValue() == 1) {
1F7F  1D0F     BTFSS PORTD, 0x2
1F80  2F82     GOTO 0x782
1F81  2F83     GOTO 0x783
1F82  2F85     GOTO 0x785
140:           
141:                       result = true;
1F83  01A3     CLRF data
1F84  0AA3     INCF data, F
142:                   }
143:               }
144:           
145:               return result;
1F85  0823     MOVF data, W
146:           
147:           }
1F86  0008     RETURN
148:           
149:           bool testNOK(bool active) {
1F51  0020     MOVLB 0x0
1F52  00A4     MOVWF Data
150:           
151:               bool result = false;
1F53  01A3     CLRF data
152:               if (active) {
1F54  0824     MOVF Data, W
1F55  1903     BTFSC STATUS, 0x2
1F56  2F58     GOTO 0x758
1F57  2F59     GOTO 0x759
1F58  2F5F     GOTO 0x75F
153:           
154:                   if (IN8_GetValue() == 0) {
1F59  1B8F     BTFSC PORTD, 0x7
1F5A  2F5C     GOTO 0x75C
1F5B  2F5D     GOTO 0x75D
1F5C  2F5F     GOTO 0x75F
155:           
156:                       result = true;
1F5D  01A3     CLRF data
1F5E  0AA3     INCF data, F
157:                   }
158:               }
159:           
160:               if (!active) {
1F5F  0824     MOVF Data, W
1F60  1D03     BTFSS STATUS, 0x2
1F61  2F63     GOTO 0x763
1F62  2F64     GOTO 0x764
1F63  2F6A     GOTO 0x76A
161:           
162:                   if (IN8_GetValue() == 1) {
1F64  1F8F     BTFSS PORTD, 0x7
1F65  2F67     GOTO 0x767
1F66  2F68     GOTO 0x768
1F67  2F6A     GOTO 0x76A
163:           
164:                       result = true;
1F68  01A3     CLRF data
1F69  0AA3     INCF data, F
165:                   }
166:               }
167:           
168:               return result;
1F6A  0823     MOVF data, W
169:           }
1F6B  0008     RETURN
170:           
171:           bool controlVisuel() {
172:           
173:               bool result = false;
174:           
175:           
176:               if (IN3_GetValue() == 0) {
177:           
178:                   result = true;
179:               }
180:           
181:               if (IN3_GetValue() == 1) {
182:           
183:                   result = false;
184:           
185:               }
186:           
187:           }
188:           
189:           void ledNonConforme(bool active) {
1DA3  0020     MOVLB 0x0
1DA4  00A3     MOVWF data
190:           
191:               if (active) {
1DA5  0823     MOVF data, W
1DA6  1903     BTFSC STATUS, 0x2
1DA7  2DA9     GOTO 0x5A9
1DA8  2DAA     GOTO 0x5AA
1DA9  2DAD     GOTO 0x5AD
192:           
193:                   C3_SetHigh();
1DAA  0022     MOVLB 0x2
1DAB  1490     BSF LATE, 0x1
1DAC  2DAF     GOTO 0x5AF
194:               } else {
195:                   C3_SetLow();
1DAD  0022     MOVLB 0x2
1DAE  1090     BCF LATE, 0x1
196:               }
197:           }
1DAF  0008     RETURN
198:           
199:           void ledConforme(bool active) {
1D96  0020     MOVLB 0x0
1D97  00A3     MOVWF data
200:           
201:               if (active) {
1D98  0823     MOVF data, W
1D99  1903     BTFSC STATUS, 0x2
1D9A  2D9C     GOTO 0x59C
1D9B  2D9D     GOTO 0x59D
1D9C  2DA0     GOTO 0x5A0
202:           
203:                   C4_SetHigh();
1D9D  0022     MOVLB 0x2
1D9E  1410     BSF LATE, 0x0
1D9F  2DA2     GOTO 0x5A2
204:               } else {
205:                   C4_SetLow();
1DA0  0022     MOVLB 0x2
1DA1  1010     BCF LATE, 0x0
206:               }
207:           }
1DA2  0008     RETURN
208:           
209:           void ledProgession(bool active) {
1DB0  0020     MOVLB 0x0
1DB1  00A3     MOVWF data
210:           
211:               if (active) {
1DB2  0823     MOVF data, W
1DB3  1903     BTFSC STATUS, 0x2
1DB4  2DB6     GOTO 0x5B6
1DB5  2DB7     GOTO 0x5B7
1DB6  2DBA     GOTO 0x5BA
212:           
213:                   C2_SetHigh();
1DB7  0022     MOVLB 0x2
1DB8  1510     BSF LATE, 0x2
1DB9  2DBC     GOTO 0x5BC
214:           
215:               } else {
216:           
217:                   C2_SetLow();
1DBA  0022     MOVLB 0x2
1DBB  1110     BCF LATE, 0x2
218:               }
219:           }
1DBC  0008     RETURN
220:           
221:           void attenteDemarrage(bool *autom, bool *testAct) {
222:           
223:           
224:               unsigned char reception;
225:               bool repOperateur = false;
226:           
227:               if (!*autom) {
228:           
229:                   while (IN3_GetValue() == 1 && !*autom) {
230:           
231:                       if (IN3_GetValue() == 0) {
232:           
233:                           if (!*testAct) {
234:           
235:                               printf("-> TEST MANUEL EN COURS\r\n");
236:           
237:                           } else {
238:           
239:                               printf("-> FIN TEST MANUEL\r\n");
240:                           }
241:           
242:                       }
243:           
244:                       if (eusartRxCount != 0) {
245:           
246:                           *autom = true;
247:                           reception = EUSART_Read(); // read a byte for RX
248:           
249:                           switch (reception) // check command  
250:                           {
251:                               case '1':
252:                               {
253:                                   printf("-> TEST ON\r\n");
254:                                   *autom = true;
255:                                   __delay_ms(50);
256:                                   repOperateur = true;
257:                                   break;
258:                               }
259:           
260:                               case '0':
261:                               {
262:                                   printf("-> TEST OFF\r\n");
263:                                   __delay_ms(50);
264:                                   repOperateur = true;
265:                                   *autom = false;
266:                                   break;
267:                               }
268:           
269:                               case '4':
270:                               {
271:                                   printf("-> TEST ACQUITTE\r\n");
272:                                   __delay_ms(50);
273:                                   repOperateur = false;
274:                                   *autom = false;
275:                                   break;
276:                               }
277:                           }
278:                       }
279:           
280:                   }
281:                   repOperateur = true;
282:               }
283:           
284:               if (*autom) {
285:           
286:                   while (!repOperateur) {
287:           
288:           
289:                       // Réception RX
290:           
291:           
292:                       if (eusartRxCount != 0) {
293:                           *autom = true;
294:                           reception = EUSART_Read(); // read a byte for RX
295:           
296:                           switch (reception) // check command  
297:                           {
298:                               case '1':
299:                               {
300:                                   printf("-> TEST ON\r\n");
301:                                   __delay_ms(50);
302:                                   repOperateur = true;
303:                                   *autom = true;
304:                                   break;
305:                               }
306:           
307:                               case '0':
308:                               {
309:                                   printf("-> TEST OFF\r\n");
310:                                   __delay_ms(50);
311:                                   repOperateur = true;
312:                                   *autom = false;
313:                                   break;
314:                               }
315:           
316:                               case '4':
317:                               {
318:                                   printf("-> TEST ACQUITTE\r\n");
319:                                   __delay_ms(50);
320:                                   repOperateur = true;
321:                                   *autom = false;
322:                                   break;
323:                               }
324:                           }
325:           
326:                       }
327:                   }
328:           
329:               }
330:           
331:           }
332:           
333:           void alerteDefaut(char etape[], bool *testAct, bool *testVoy) {
334:           
335:               char error[20] = "-> ERREUR: ";
16EB  30A0     MOVLW 0xA0
16EC  0086     MOVWF FSR1L
16ED  3001     MOVLW 0x1
16EE  0087     MOVWF FSR1H
16EF  30C1     MOVLW 0xC1
16F0  0084     MOVWF FSR0L
16F1  3000     MOVLW 0x0
16F2  0085     MOVWF FSR0H
16F3  3014     MOVLW 0x14
16F4  0021     MOVLB 0x1
16F5  00B6     MOVWF reception
16F6  0016     MOVIW FSR1++
16F7  001A     MOVWI FSR0++
16F8  0BB6     DECFSZ reception, F
16F9  2EF6     GOTO 0x6F6
336:               char eol[10] = "\r\n";
16FA  30BE     MOVLW 0xBE
16FB  0086     MOVWF FSR1L
16FC  3001     MOVLW 0x1
16FD  0087     MOVWF FSR1H
16FE  30B7     MOVLW 0xB7
16FF  0084     MOVWF FSR0L
1700  3000     MOVLW 0x0
1701  0085     MOVWF FSR0H
1702  300A     MOVLW 0xA
1703  00B6     MOVWF reception
1704  0016     MOVIW FSR1++
1705  001A     MOVWI FSR0++
1706  0BB6     DECFSZ reception, F
1707  2F04     GOTO 0x704
337:               ledNonConforme(true);
1708  3001     MOVLW 0x1
1709  319D     MOVLP 0x1D
170A  25A3     CALL 0x5A3
170B  3196     MOVLP 0x16
338:               ledProgession(true);
170C  3001     MOVLW 0x1
170D  319D     MOVLP 0x1D
170E  25B0     CALL 0x5B0
170F  3196     MOVLP 0x16
339:               ledConforme(false);
1710  3000     MOVLW 0x0
1711  319D     MOVLP 0x1D
1712  2596     CALL 0x596
1713  3196     MOVLP 0x16
340:               alimenter(false);
1714  3000     MOVLW 0x0
1715  319D     MOVLP 0x1D
1716  2589     CALL 0x589
1717  3196     MOVLP 0x16
341:               displayManager(etape, NON_CONFORME, ACQ, LIGNE_VIDE);
1718  0021     MOVLB 0x1
1719  0831     MOVF ret, W
171A  0020     MOVLB 0x0
171B  00AF     MOVWF s
171C  0021     MOVLB 0x1
171D  0830     MOVF testAct, W
171E  0020     MOVLB 0x0
171F  00AE     MOVWF fp
1720  30E5     MOVLW 0xE5
1721  00B0     MOVWF s2
1722  30A0     MOVLW 0xA0
1723  00B1     MOVWF d
1724  305E     MOVLW 0x5E
1725  00B2     MOVWF c
1726  30A0     MOVLW 0xA0
1727  00B3     MOVWF dest
1728  30AD     MOVLW 0xAD
1729  00B4     MOVWF counter
172A  30A0     MOVLW 0xA0
172B  00B5     MOVWF src
172C  3194     MOVLP 0x14
172D  24C3     CALL 0x4C3
172E  3196     MOVLP 0x16
342:               printf(strcat(strcat(error, etape), eol));
172F  30C1     MOVLW 0xC1
1730  0020     MOVLB 0x0
1731  00B3     MOVWF dest
1732  3000     MOVLW 0x0
1733  00B4     MOVWF counter
1734  0021     MOVLB 0x1
1735  0831     MOVF ret, W
1736  0020     MOVLB 0x0
1737  00B6     MOVWF buf
1738  0021     MOVLB 0x1
1739  0830     MOVF testAct, W
173A  0020     MOVLB 0x0
173B  00B5     MOVWF src
173C  319E     MOVLP 0x1E
173D  26A4     CALL 0x6A4
173E  3196     MOVLP 0x16
173F  0020     MOVLB 0x0
1740  0834     MOVF counter, W
1741  0021     MOVLB 0x1
1742  00D6     MOVWF 0xD6
1743  0020     MOVLB 0x0
1744  0833     MOVF dest, W
1745  0021     MOVLB 0x1
1746  00D5     MOVWF 0xD5
1747  0856     MOVF 0xD6, W
1748  0020     MOVLB 0x0
1749  00B4     MOVWF counter
174A  0021     MOVLB 0x1
174B  0855     MOVF 0xD5, W
174C  0020     MOVLB 0x0
174D  00B3     MOVWF dest
174E  30B7     MOVLW 0xB7
174F  00B5     MOVWF src
1750  3000     MOVLW 0x0
1751  00B6     MOVWF buf
1752  319E     MOVLP 0x1E
1753  26A4     CALL 0x6A4
1754  3196     MOVLP 0x16
1755  0020     MOVLB 0x0
1756  0834     MOVF counter, W
1757  0021     MOVLB 0x1
1758  00AE     MOVWF 0xAE
1759  0020     MOVLB 0x0
175A  0833     MOVF dest, W
175B  0021     MOVLB 0x1
175C  00AD     MOVWF fmt
175D  319E     MOVLP 0x1E
175E  268E     CALL 0x68E
175F  3196     MOVLP 0x16
343:               errorAlert();
1760  3193     MOVLP 0x13
1761  23E6     CALL 0x3E6
1762  3196     MOVLP 0x16
344:           
345:               while (IN3_GetValue() == 0) {
346:                   ;
347:               }
1763  0020     MOVLB 0x0
1764  1D0F     BTFSS PORTD, 0x2
1765  2F67     GOTO 0x767
1766  2F68     GOTO 0x768
1767  2F63     GOTO 0x763
348:           
349:               // ledNonConforme(false);
350:               *testAct = false;
1768  0021     MOVLB 0x1
1769  0832     MOVF testVoy, W
176A  0086     MOVWF FSR1L
176B  0833     MOVF ap, W
176C  0087     MOVWF FSR1H
176D  0181     CLRF INDF1
351:               *testVoy = false;
176E  0834     MOVF s, W
176F  0086     MOVWF FSR1L
1770  0835     MOVF f, W
1771  0087     MOVWF FSR1H
1772  0181     CLRF INDF1
352:           
353:           }
1773  0008     RETURN
354:           
355:           bool reponseOperateur(bool automatique) {
1673  0020     MOVLB 0x0
1674  00A8     MOVWF Data
356:           
357:               bool reponse = false;
1675  01A9     CLRF Str
358:               bool repOperateur = false;
1676  01AA     CLRF repOperateur
359:               unsigned char reception;
360:           
361:               if (automatique) {
1677  0828     MOVF Data, W
1678  1903     BTFSC STATUS, 0x2
1679  2E7B     GOTO 0x67B
167A  2E7C     GOTO 0x67C
167B  2EC2     GOTO 0x6C2
167C  2EBD     GOTO 0x6BD
362:           
363:                   while (!repOperateur) {
16BD  082A     MOVF repOperateur, W
16BE  1903     BTFSC STATUS, 0x2
16BF  2EC1     GOTO 0x6C1
16C0  2EC2     GOTO 0x6C2
16C1  2E7D     GOTO 0x67D
364:           
365:                       if (eusartRxCount != 0) {
167D  086A     MOVF eusartRxCount, W
167E  1903     BTFSC STATUS, 0x2
167F  2E81     GOTO 0x681
1680  2E82     GOTO 0x682
1681  2EBD     GOTO 0x6BD
366:           
367:                           reception = EUSART_Read(); // read a byte for RX
1682  3192     MOVLP 0x12
1683  22B7     CALL 0x2B7
1684  3196     MOVLP 0x16
1685  0020     MOVLB 0x0
1686  00A5     MOVWF txData
1687  0825     MOVF txData, W
1688  00A7     MOVWF reception
368:           
369:                           switch (reception) // check command  
1689  2EAD     GOTO 0x6AD
370:                           {
371:                               case '2':
372:                               {
373:           
374:                                   __delay_ms(50);
168A  3002     MOVLW 0x2
168B  0020     MOVLB 0x0
168C  00A6     MOVWF Nibble
168D  3004     MOVLW 0x4
168E  00A5     MOVWF txData
168F  30BA     MOVLW 0xBA
1690  0B89     DECFSZ WREG, F
1691  2E90     GOTO 0x690
1692  0BA5     DECFSZ txData, F
1693  2E90     GOTO 0x690
1694  0BA6     DECFSZ Nibble, F
1695  2E90     GOTO 0x690
1696  0000     NOP
375:                                   reponse = true;
1697  0020     MOVLB 0x0
1698  01A9     CLRF Str
1699  0AA9     INCF Str, F
376:                                   repOperateur = true;
169A  01AA     CLRF repOperateur
169B  0AAA     INCF repOperateur, F
377:                                   break;
169C  2EBD     GOTO 0x6BD
378:                               }
379:           
380:                               case '3':
381:                               {
382:           
383:                                   __delay_ms(50);
169D  3002     MOVLW 0x2
169E  0020     MOVLB 0x0
169F  00A6     MOVWF Nibble
16A0  3004     MOVLW 0x4
16A1  00A5     MOVWF txData
16A2  30BA     MOVLW 0xBA
16A3  0B89     DECFSZ WREG, F
16A4  2EA3     GOTO 0x6A3
16A5  0BA5     DECFSZ txData, F
16A6  2EA3     GOTO 0x6A3
16A7  0BA6     DECFSZ Nibble, F
16A8  2EA3     GOTO 0x6A3
16A9  0000     NOP
384:                                   reponse = false;
16AA  0020     MOVLB 0x0
16AB  01A9     CLRF Str
16AC  2E9A     GOTO 0x69A
385:                                   repOperateur = true;
386:                                   break;
387:                               }
388:                           }
16AD  0827     MOVF reception, W
16AE  00A5     MOVWF txData
16AF  01A6     CLRF Nibble
16B0  0826     MOVF Nibble, W
16B1  3A00     XORLW 0x0
16B2  1903     BTFSC STATUS, 0x2
16B3  2EB5     GOTO 0x6B5
16B4  2EBD     GOTO 0x6BD
16B5  0825     MOVF txData, W
16B6  3A32     XORLW 0x32
16B7  1903     BTFSC STATUS, 0x2
16B8  2E8A     GOTO 0x68A
16B9  3A01     XORLW 0x1
16BA  1903     BTFSC STATUS, 0x2
16BB  2E9D     GOTO 0x69D
16BC  2EBD     GOTO 0x6BD
389:           
390:                       }
391:           
392:                   }
393:           
394:               }
395:           
396:               if (!automatique) {
16C2  0828     MOVF Data, W
16C3  1D03     BTFSS STATUS, 0x2
16C4  2EC6     GOTO 0x6C6
16C5  2EC7     GOTO 0x6C7
16C6  2EE9     GOTO 0x6E9
16C7  2EE3     GOTO 0x6E3
397:           
398:                   while (!repOperateur) {
16E3  0020     MOVLB 0x0
16E4  082A     MOVF repOperateur, W
16E5  1903     BTFSC STATUS, 0x2
16E6  2EE8     GOTO 0x6E8
16E7  2EE9     GOTO 0x6E9
16E8  2EC8     GOTO 0x6C8
399:           
400:                       if (testNOK(true)) {
16C8  3001     MOVLW 0x1
16C9  319F     MOVLP 0x1F
16CA  2751     CALL 0x751
16CB  3196     MOVLP 0x16
16CC  3A00     XORLW 0x0
16CD  1903     BTFSC STATUS, 0x2
16CE  2ED0     GOTO 0x6D0
16CF  2ED1     GOTO 0x6D1
16D0  2ED5     GOTO 0x6D5
401:                           reponse = false;
16D1  0020     MOVLB 0x0
16D2  01A9     CLRF Str
402:                           repOperateur = true;
16D3  01AA     CLRF repOperateur
16D4  0AAA     INCF repOperateur, F
403:                       }
404:                       if (testOK(true)) {
16D5  3001     MOVLW 0x1
16D6  319F     MOVLP 0x1F
16D7  276C     CALL 0x76C
16D8  3196     MOVLP 0x16
16D9  3A00     XORLW 0x0
16DA  1903     BTFSC STATUS, 0x2
16DB  2EDD     GOTO 0x6DD
16DC  2EDE     GOTO 0x6DE
16DD  2EE3     GOTO 0x6E3
405:                           reponse = true;
16DE  0020     MOVLB 0x0
16DF  01A9     CLRF Str
16E0  0AA9     INCF Str, F
406:                           repOperateur = true;
16E1  01AA     CLRF repOperateur
16E2  0AAA     INCF repOperateur, F
407:                       }
408:                   }
409:           
410:               }
411:           
412:               return reponse;
16E9  0829     MOVF Str, W
413:           
414:           }
16EA  0008     RETURN
415:           
416:           void setP1(bool active) {
1DD7  0020     MOVLB 0x0
1DD8  00A3     MOVWF data
417:           
418:               if (active) {
1DD9  0823     MOVF data, W
1DDA  1903     BTFSC STATUS, 0x2
1DDB  2DDD     GOTO 0x5DD
1DDC  2DDE     GOTO 0x5DE
1DDD  2DE1     GOTO 0x5E1
419:           
420:                   REL5_SetHigh();
1DDE  0022     MOVLB 0x2
1DDF  160C     BSF LATA, 0x4
1DE0  2DE3     GOTO 0x5E3
421:               } else {
422:                   REL5_SetLow();
1DE1  0022     MOVLB 0x2
1DE2  120C     BCF LATA, 0x4
423:               }
424:           
425:           }
1DE3  0008     RETURN
426:           
427:           void setP2(bool active) {
1DE4  0020     MOVLB 0x0
1DE5  00A3     MOVWF data
428:           
429:               if (active) {
1DE6  0823     MOVF data, W
1DE7  1903     BTFSC STATUS, 0x2
1DE8  2DEA     GOTO 0x5EA
1DE9  2DEB     GOTO 0x5EB
1DEA  2DEE     GOTO 0x5EE
430:           
431:                   REL6_SetHigh();
1DEB  0022     MOVLB 0x2
1DEC  168C     BSF LATA, 0x5
1DED  2DF0     GOTO 0x5F0
432:               } else {
433:                   REL6_SetLow();
1DEE  0022     MOVLB 0x2
1DEF  128C     BCF LATA, 0x5
434:               }
435:           
436:           }
1DF0  0008     RETURN
437:           
438:           void initialConditions(bool *testAct, bool *testVoy, bool *autom) {
439:           
440:               if (!*autom) {
135E  0021     MOVLB 0x1
135F  0834     MOVF s, W
1360  0086     MOVWF FSR1L
1361  0835     MOVF f, W
1362  0087     MOVWF FSR1H
1363  0801     MOVF INDF1, W
1364  1D03     BTFSS STATUS, 0x2
1365  2B67     GOTO 0x367
1366  2B68     GOTO 0x368
1367  2B6F     GOTO 0x36F
441:           
442:                   printf("-> FIN TEST MANUEL\r\n");
1368  3034     MOVLW 0x34
1369  00AD     MOVWF fmt
136A  30A0     MOVLW 0xA0
136B  00AE     MOVWF 0xAE
136C  319E     MOVLP 0x1E
136D  268E     CALL 0x68E
136E  3193     MOVLP 0x13
443:               }
444:               *testAct = false;
136F  0021     MOVLB 0x1
1370  0830     MOVF testAct, W
1371  0086     MOVWF FSR1L
1372  0831     MOVF ret, W
1373  0087     MOVWF FSR1H
1374  0181     CLRF INDF1
445:               *testVoy = false;
1375  0832     MOVF testVoy, W
1376  0086     MOVWF FSR1L
1377  0833     MOVF ap, W
1378  0087     MOVWF FSR1H
1379  0181     CLRF INDF1
446:               *autom = false;
137A  0834     MOVF s, W
137B  0086     MOVWF FSR1L
137C  0835     MOVF f, W
137D  0087     MOVWF FSR1H
137E  0181     CLRF INDF1
447:               ledConforme(false);
137F  3000     MOVLW 0x0
1380  319D     MOVLP 0x1D
1381  2596     CALL 0x596
1382  3193     MOVLP 0x13
448:               ledNonConforme(false);
1383  3000     MOVLW 0x0
1384  319D     MOVLP 0x1D
1385  25A3     CALL 0x5A3
1386  3193     MOVLP 0x13
449:               ledProgession(false);
1387  3000     MOVLW 0x0
1388  319D     MOVLP 0x1D
1389  25B0     CALL 0x5B0
138A  3193     MOVLP 0x13
450:               alimenter(false);
138B  3000     MOVLW 0x0
138C  319D     MOVLP 0x1D
138D  2589     CALL 0x589
138E  3193     MOVLP 0x13
451:               pressBP1(false);
138F  3000     MOVLW 0x0
1390  319D     MOVLP 0x1D
1391  25BD     CALL 0x5BD
1392  3193     MOVLP 0x13
452:               pressBP2(false);
1393  3000     MOVLW 0x0
1394  319D     MOVLP 0x1D
1395  25CA     CALL 0x5CA
1396  3193     MOVLP 0x13
453:               setP1(false);
1397  3000     MOVLW 0x0
1398  319D     MOVLP 0x1D
1399  25D7     CALL 0x5D7
139A  3193     MOVLP 0x13
454:               setP2(false);
139B  3000     MOVLW 0x0
139C  319D     MOVLP 0x1D
139D  25E4     CALL 0x5E4
139E  3193     MOVLP 0x13
455:           
456:           }
139F  0008     RETURN
457:           
458:           void activerBuzzer() {
459:           
460:           
461:               for (int i = 0; i < 50; i++) {
11A5  0020     MOVLB 0x0
11A6  01A4     CLRF Data
11A7  01A5     CLRF txData
462:           
463:                   BUZ_SetHigh();
11A8  0022     MOVLB 0x2
11A9  160D     BSF LATB, 0x4
464:                   // __delay_ms(1);
465:                   __delay_us(1000);
11AA  3006     MOVLW 0x6
11AB  0020     MOVLB 0x0
11AC  00A3     MOVWF data
11AD  3030     MOVLW 0x30
11AE  0B89     DECFSZ WREG, F
11AF  29AE     GOTO 0x1AE
11B0  0BA3     DECFSZ data, F
11B1  29AE     GOTO 0x1AE
11B2  0000     NOP
466:           
467:                   BUZ_SetLow();
11B3  0022     MOVLB 0x2
11B4  120D     BCF LATB, 0x4
468:                   // __delay_ms(1);
469:                   __delay_us(1000);
11B5  3006     MOVLW 0x6
11B6  0020     MOVLB 0x0
11B7  00A3     MOVWF data
11B8  3030     MOVLW 0x30
11B9  0B89     DECFSZ WREG, F
11BA  29B9     GOTO 0x1B9
11BB  0BA3     DECFSZ data, F
11BC  29B9     GOTO 0x1B9
11BD  0000     NOP
470:           
471:               }
11BE  3001     MOVLW 0x1
11BF  0020     MOVLB 0x0
11C0  07A4     ADDWF Data, F
11C1  3000     MOVLW 0x0
11C2  3DA5     ADDWFC txData, F
11C3  0825     MOVF txData, W
11C4  3A80     XORLW 0x80
11C5  00A3     MOVWF data
11C6  3080     MOVLW 0x80
11C7  0223     SUBWF data, W
11C8  1D03     BTFSS STATUS, 0x2
11C9  29CC     GOTO 0x1CC
11CA  3032     MOVLW 0x32
11CB  0224     SUBWF Data, W
11CC  1C03     BTFSS STATUS, 0x0
11CD  29CF     GOTO 0x1CF
11CE  29D0     GOTO 0x1D0
11CF  29A8     GOTO 0x1A8
472:           
473:           }
11D0  0008     RETURN
474:           
475:           void activerTouche(void) {
476:           
477:               REL7_SetHigh();
1FC2  0022     MOVLB 0x2
1FC3  170C     BSF LATA, 0x6
478:               __delay_ms(250);
1FC4  3006     MOVLW 0x6
1FC5  0020     MOVLB 0x0
1FC6  00A4     MOVWF Data
1FC7  3013     MOVLW 0x13
1FC8  00A3     MOVWF data
1FC9  30AD     MOVLW 0xAD
1FCA  0B89     DECFSZ WREG, F
1FCB  2FCA     GOTO 0x7CA
1FCC  0BA3     DECFSZ data, F
1FCD  2FCA     GOTO 0x7CA
1FCE  0BA4     DECFSZ Data, F
1FCF  2FCA     GOTO 0x7CA
1FD0  3200     BRA 0x1FD1
479:               REL7_SetLow();
1FD1  0022     MOVLB 0x2
1FD2  130C     BCF LATA, 0x6
480:               __delay_ms(250);
1FD3  3006     MOVLW 0x6
1FD4  0020     MOVLB 0x0
1FD5  00A4     MOVWF Data
1FD6  3013     MOVLW 0x13
1FD7  00A3     MOVWF data
1FD8  30AD     MOVLW 0xAD
1FD9  0B89     DECFSZ WREG, F
1FDA  2FD9     GOTO 0x7D9
1FDB  0BA3     DECFSZ data, F
1FDC  2FD9     GOTO 0x7D9
1FDD  0BA4     DECFSZ Data, F
1FDE  2FD9     GOTO 0x7D9
1FDF  3200     BRA 0x1FE0
481:           
482:           }
1FE0  0008     RETURN
483:           
484:           void startAlert(void) {
485:           
486:               for (int i = 0; i < 2; i++) {
10DD  0020     MOVLB 0x0
10DE  01A8     CLRF Data
10DF  01A9     CLRF Str
487:           
488:                   activerBuzzer();
10E0  3191     MOVLP 0x11
10E1  21A5     CALL 0x1A5
10E2  3190     MOVLP 0x10
489:                   __delay_ms(500);
10E3  300B     MOVLW 0xB
10E4  0020     MOVLB 0x0
10E5  00A7     MOVWF reception
10E6  3026     MOVLW 0x26
10E7  00A6     MOVWF Nibble
10E8  305D     MOVLW 0x5D
10E9  0B89     DECFSZ WREG, F
10EA  28E9     GOTO 0xE9
10EB  0BA6     DECFSZ Nibble, F
10EC  28E9     GOTO 0xE9
10ED  0BA7     DECFSZ reception, F
10EE  28E9     GOTO 0xE9
10EF  3200     BRA 0x10F0
490:           
491:               }
10F0  3001     MOVLW 0x1
10F1  0020     MOVLB 0x0
10F2  07A8     ADDWF Data, F
10F3  3000     MOVLW 0x0
10F4  3DA9     ADDWFC Str, F
10F5  0829     MOVF Str, W
10F6  3A80     XORLW 0x80
10F7  00A6     MOVWF Nibble
10F8  3080     MOVLW 0x80
10F9  0226     SUBWF Nibble, W
10FA  1D03     BTFSS STATUS, 0x2
10FB  28FE     GOTO 0xFE
10FC  3002     MOVLW 0x2
10FD  0228     SUBWF Data, W
10FE  1C03     BTFSS STATUS, 0x0
10FF  2901     GOTO 0x101
1100  2902     GOTO 0x102
1101  28E0     GOTO 0xE0
492:           
493:           }
1102  0008     RETURN
494:           
495:           void errorAlert(void) {
496:           
497:               for (int j = 0; j < 4; j++) {
13E6  0020     MOVLB 0x0
13E7  01A8     CLRF Data
13E8  01A9     CLRF Str
498:           
499:                   for (int i = 0; i < 4; i++) {
13E9  0020     MOVLB 0x0
13EA  01AA     CLRF repOperateur
13EB  01AB     CLRF I2C_Add
500:           
501:                       activerBuzzer();
13EC  3191     MOVLP 0x11
13ED  21A5     CALL 0x1A5
13EE  3193     MOVLP 0x13
502:                       __delay_ms(500);
13EF  300B     MOVLW 0xB
13F0  0020     MOVLB 0x0
13F1  00A7     MOVWF reception
13F2  3026     MOVLW 0x26
13F3  00A6     MOVWF Nibble
13F4  305D     MOVLW 0x5D
13F5  0B89     DECFSZ WREG, F
13F6  2BF5     GOTO 0x3F5
13F7  0BA6     DECFSZ Nibble, F
13F8  2BF5     GOTO 0x3F5
13F9  0BA7     DECFSZ reception, F
13FA  2BF5     GOTO 0x3F5
13FB  3200     BRA 0x13FC
503:           
504:                   }
13FC  3001     MOVLW 0x1
13FD  0020     MOVLB 0x0
13FE  07AA     ADDWF repOperateur, F
13FF  3000     MOVLW 0x0
1400  3DAB     ADDWFC I2C_Add, F
1401  082B     MOVF I2C_Add, W
1402  3A80     XORLW 0x80
1403  00A6     MOVWF Nibble
1404  3080     MOVLW 0x80
1405  0226     SUBWF Nibble, W
1406  1D03     BTFSS STATUS, 0x2
1407  2C0A     GOTO 0x40A
1408  3004     MOVLW 0x4
1409  022A     SUBWF repOperateur, W
140A  1C03     BTFSS STATUS, 0x0
140B  2C0D     GOTO 0x40D
140C  2C0E     GOTO 0x40E
140D  2BEC     GOTO 0x3EC
505:                   __delay_ms(500);
140E  300B     MOVLW 0xB
140F  0020     MOVLB 0x0
1410  00A7     MOVWF reception
1411  3026     MOVLW 0x26
1412  00A6     MOVWF Nibble
1413  305D     MOVLW 0x5D
1414  0B89     DECFSZ WREG, F
1415  2C14     GOTO 0x414
1416  0BA6     DECFSZ Nibble, F
1417  2C14     GOTO 0x414
1418  0BA7     DECFSZ reception, F
1419  2C14     GOTO 0x414
141A  3200     BRA 0x141B
506:               }
141B  3001     MOVLW 0x1
141C  0020     MOVLB 0x0
141D  07A8     ADDWF Data, F
141E  3000     MOVLW 0x0
141F  3DA9     ADDWFC Str, F
1420  0829     MOVF Str, W
1421  3A80     XORLW 0x80
1422  00A6     MOVWF Nibble
1423  3080     MOVLW 0x80
1424  0226     SUBWF Nibble, W
1425  1D03     BTFSS STATUS, 0x2
1426  2C29     GOTO 0x429
1427  3004     MOVLW 0x4
1428  0228     SUBWF Data, W
1429  1C03     BTFSS STATUS, 0x0
142A  2C2C     GOTO 0x42C
142B  2C2D     GOTO 0x42D
142C  2BE9     GOTO 0x3E9
507:           
508:           
509:           }
142D  0008     RETURN
510:           
511:           void okAlert(void) {
512:           
513:           
514:               printf("-> TEST CONFORME - ATTENTE ACQUITTEMENT\r\n");
1031  3020     MOVLW 0x20
1032  0021     MOVLB 0x1
1033  00AD     MOVWF fmt
1034  3098     MOVLW 0x98
1035  00AE     MOVWF 0xAE
1036  319E     MOVLP 0x1E
1037  268E     CALL 0x68E
1038  3190     MOVLP 0x10
515:               for (int i = 0; i < 2; i++) {
1039  0021     MOVLB 0x1
103A  01B1     CLRF ret
103B  01B2     CLRF testVoy
516:           
517:                   startAlert();
103C  3190     MOVLP 0x10
103D  20DD     CALL 0xDD
103E  3190     MOVLP 0x10
518:           
519:               }
103F  3001     MOVLW 0x1
1040  0021     MOVLB 0x1
1041  07B1     ADDWF ret, F
1042  3000     MOVLW 0x0
1043  3DB2     ADDWFC testVoy, F
1044  0832     MOVF testVoy, W
1045  3A80     XORLW 0x80
1046  00B0     MOVWF testAct
1047  3080     MOVLW 0x80
1048  0230     SUBWF testAct, W
1049  1D03     BTFSS STATUS, 0x2
104A  284D     GOTO 0x4D
104B  3002     MOVLW 0x2
104C  0231     SUBWF ret, W
104D  1C03     BTFSS STATUS, 0x0
104E  2850     GOTO 0x50
104F  2851     GOTO 0x51
1050  283C     GOTO 0x3C
520:           
521:           
522:           }
1051  0008     RETURN
523:           
524:           void attenteDemarrage2(bool *autom, bool *testAct) {
15BD  0021     MOVLB 0x1
15BE  00B5     MOVWF f
525:           
526:               unsigned char reception;
527:               bool repOperateur = false;
15BF  01B4     CLRF s
528:           
529:               while (!repOperateur) {
15C0  2E10     GOTO 0x610
1610  0021     MOVLB 0x1
1611  0834     MOVF s, W
1612  1903     BTFSC STATUS, 0x2
1613  2E15     GOTO 0x615
1614  2E16     GOTO 0x616
1615  2DC1     GOTO 0x5C1
530:           
531:           
532:                   if (IN3_GetValue() == 0) {
15C1  0020     MOVLB 0x0
15C2  190F     BTFSC PORTD, 0x2
15C3  2DC5     GOTO 0x5C5
15C4  2DC6     GOTO 0x5C6
15C5  2DD6     GOTO 0x5D6
533:           
534:                       printf("-> TEST MANUEL EN COURS\r\n");
15C6  3000     MOVLW 0x0
15C7  0021     MOVLB 0x1
15C8  00AD     MOVWF fmt
15C9  30A0     MOVLW 0xA0
15CA  00AE     MOVWF 0xAE
15CB  319E     MOVLP 0x1E
15CC  268E     CALL 0x68E
15CD  3195     MOVLP 0x15
535:                       repOperateur = true;
15CE  0021     MOVLB 0x1
15CF  01B4     CLRF s
15D0  0AB4     INCF s, F
536:                       *autom = false;
15D1  0835     MOVF f, W
15D2  0086     MOVWF FSR1L
15D3  3002     MOVLW 0x2
15D4  0087     MOVWF FSR1H
15D5  0181     CLRF INDF1
537:                   }
538:           
539:                   if (eusartRxCount != 0) {
15D6  0020     MOVLB 0x0
15D7  086A     MOVF eusartRxCount, W
15D8  1903     BTFSC STATUS, 0x2
15D9  2DDB     GOTO 0x5DB
15DA  2DDC     GOTO 0x5DC
15DB  2E10     GOTO 0x610
540:           
541:                       reception = EUSART_Read(); // read a byte for RX
15DC  3192     MOVLP 0x12
15DD  22B7     CALL 0x2B7
15DE  3195     MOVLP 0x15
15DF  0021     MOVLB 0x1
15E0  00B1     MOVWF ret
15E1  0831     MOVF ret, W
15E2  00B3     MOVWF ap
542:           
543:                       switch (reception) // check command  
15E3  2E03     GOTO 0x603
544:                       {
545:                           case '1':
546:                           {
547:                               printf("-> TEST ON\r\n");
15E4  3015     MOVLW 0x15
15E5  00AD     MOVWF fmt
15E6  30A2     MOVLW 0xA2
15E7  00AE     MOVWF 0xAE
15E8  319E     MOVLP 0x1E
15E9  268E     CALL 0x68E
15EA  3195     MOVLP 0x15
548:                               *autom = true;
15EB  0021     MOVLB 0x1
15EC  0835     MOVF f, W
15ED  0086     MOVWF FSR1L
15EE  3002     MOVLW 0x2
15EF  0087     MOVWF FSR1H
15F0  0181     CLRF INDF1
15F1  0A81     INCF INDF1, F
549:                               __delay_ms(50);
15F2  3002     MOVLW 0x2
15F3  0021     MOVLB 0x1
15F4  00B2     MOVWF testVoy
15F5  3004     MOVLW 0x4
15F6  00B1     MOVWF ret
15F7  30BA     MOVLW 0xBA
15F8  0B89     DECFSZ WREG, F
15F9  2DF8     GOTO 0x5F8
15FA  0BB1     DECFSZ ret, F
15FB  2DF8     GOTO 0x5F8
15FC  0BB2     DECFSZ testVoy, F
15FD  2DF8     GOTO 0x5F8
15FE  0000     NOP
550:                               repOperateur = true;
15FF  0021     MOVLB 0x1
1600  01B4     CLRF s
1601  0AB4     INCF s, F
551:                               break;
1602  2E10     GOTO 0x610
552:                           }
553:                       }
1603  0833     MOVF ap, W
1604  00B1     MOVWF ret
1605  01B2     CLRF testVoy
1606  0832     MOVF testVoy, W
1607  3A00     XORLW 0x0
1608  1903     BTFSC STATUS, 0x2
1609  2E0B     GOTO 0x60B
160A  2E10     GOTO 0x610
160B  0831     MOVF ret, W
160C  3A31     XORLW 0x31
160D  1903     BTFSC STATUS, 0x2
160E  2DE4     GOTO 0x5E4
160F  2E10     GOTO 0x610
1610  0021     MOVLB 0x1
1611  0834     MOVF s, W
1612  1903     BTFSC STATUS, 0x2
1613  2E15     GOTO 0x615
1614  2E16     GOTO 0x616
1615  2DC1     GOTO 0x5C1
554:                   }
555:               }
556:           
557:           }
1616  0008     RETURN
558:           
559:           void attenteAquittement(bool *autom, bool *testAct) {
560:           
561:               unsigned char reception;
562:               bool repOperateur = false;
0798  0021     MOVLB 0x1
0799  01B7     CLRF repOperateur
563:           
564:               while (!repOperateur) {
079A  2FF3     GOTO 0x7F3
07F3  0021     MOVLB 0x1
07F4  0837     MOVF repOperateur, W
07F5  1903     BTFSC STATUS, 0x2
07F6  2FF8     GOTO 0x7F8
07F7  2FF9     GOTO 0x7F9
07F8  2F9B     GOTO 0x79B
565:           
566:           
567:                   if (IN3_GetValue() == 0) {
079B  0020     MOVLB 0x0
079C  190F     BTFSC PORTD, 0x2
079D  2F9F     GOTO 0x79F
079E  2FA0     GOTO 0x7A0
079F  2FB5     GOTO 0x7B5
568:           
569:                       printf("-> FIN TEST MANUEL\r\n");
07A0  3034     MOVLW 0x34
07A1  0021     MOVLB 0x1
07A2  00AD     MOVWF fmt
07A3  30A0     MOVLW 0xA0
07A4  00AE     MOVWF 0xAE
07A5  319E     MOVLP 0x1E
07A6  268E     CALL 0x68E
07A7  3187     MOVLP 0x7
570:                       repOperateur = true;
07A8  0021     MOVLB 0x1
07A9  01B7     CLRF repOperateur
07AA  0AB7     INCF repOperateur, F
571:                       *autom = false;
07AB  0830     MOVF testAct, W
07AC  0086     MOVWF FSR1L
07AD  0831     MOVF ret, W
07AE  0087     MOVWF FSR1H
07AF  0181     CLRF INDF1
572:                       *testAct = false;
07B0  0832     MOVF testVoy, W
07B1  0086     MOVWF FSR1L
07B2  0833     MOVF ap, W
07B3  0087     MOVWF FSR1H
07B4  0181     CLRF INDF1
573:                   }
574:           
575:                   if (eusartRxCount != 0) {
07B5  0020     MOVLB 0x0
07B6  086A     MOVF eusartRxCount, W
07B7  1903     BTFSC STATUS, 0x2
07B8  2FBA     GOTO 0x7BA
07B9  2FBB     GOTO 0x7BB
07BA  2FF3     GOTO 0x7F3
576:           
577:                       reception = EUSART_Read(); // read a byte for RX
07BB  3192     MOVLP 0x12
07BC  22B7     CALL 0x2B7
07BD  3187     MOVLP 0x7
07BE  0021     MOVLB 0x1
07BF  00B4     MOVWF s
07C0  0834     MOVF s, W
07C1  00B6     MOVWF reception
578:           
579:                       switch (reception) // check command  
07C2  2FE6     GOTO 0x7E6
580:                       {
581:                           case '4':
582:                           {
583:                               printf("-> TEST ACQUITTE\r\n");
07C3  309B     MOVLW 0x9B
07C4  00AD     MOVWF fmt
07C5  30A0     MOVLW 0xA0
07C6  00AE     MOVWF 0xAE
07C7  319E     MOVLP 0x1E
07C8  268E     CALL 0x68E
07C9  3187     MOVLP 0x7
584:                               *autom = false;
07CA  0021     MOVLB 0x1
07CB  0830     MOVF testAct, W
07CC  0086     MOVWF FSR1L
07CD  0831     MOVF ret, W
07CE  0087     MOVWF FSR1H
07CF  0181     CLRF INDF1
585:                               *testAct = false;
07D0  0832     MOVF testVoy, W
07D1  0086     MOVWF FSR1L
07D2  0833     MOVF ap, W
07D3  0087     MOVWF FSR1H
07D4  0181     CLRF INDF1
586:                               __delay_ms(50);
07D5  3002     MOVLW 0x2
07D6  0021     MOVLB 0x1
07D7  00B5     MOVWF f
07D8  3004     MOVLW 0x4
07D9  00B4     MOVWF s
07DA  30BA     MOVLW 0xBA
07DB  0B89     DECFSZ WREG, F
07DC  2FDB     GOTO 0x7DB
07DD  0BB4     DECFSZ s, F
07DE  2FDB     GOTO 0x7DB
07DF  0BB5     DECFSZ f, F
07E0  2FDB     GOTO 0x7DB
07E1  0000     NOP
587:                               repOperateur = true;
07E2  0021     MOVLB 0x1
07E3  01B7     CLRF repOperateur
07E4  0AB7     INCF repOperateur, F
588:                               break;
07E5  2FF3     GOTO 0x7F3
589:                           }
590:                       }
07E6  0836     MOVF reception, W
07E7  00B4     MOVWF s
07E8  01B5     CLRF f
07E9  0835     MOVF f, W
07EA  3A00     XORLW 0x0
07EB  1903     BTFSC STATUS, 0x2
07EC  2FEE     GOTO 0x7EE
07ED  2FF3     GOTO 0x7F3
07EE  0834     MOVF s, W
07EF  3A34     XORLW 0x34
07F0  1903     BTFSC STATUS, 0x2
07F1  2FC3     GOTO 0x7C3
07F2  2FF3     GOTO 0x7F3
07F3  0021     MOVLB 0x1
07F4  0837     MOVF repOperateur, W
07F5  1903     BTFSC STATUS, 0x2
07F6  2FF8     GOTO 0x7F8
07F7  2FF9     GOTO 0x7F9
07F8  2F9B     GOTO 0x79B
591:                   }
592:               }
593:           
594:           }
07F9  0008     RETURN
595:           
596:           void sortieErreur(bool *autom, bool *testAct, bool *testVoy) {
597:           
598:               attenteAquittement(*autom, *testAct);
1477  0021     MOVLB 0x1
1478  0838     MOVF autom, W
1479  0086     MOVWF FSR1L
147A  0839     MOVF 0xB9, W
147B  0087     MOVWF FSR1H
147C  0801     MOVF INDF1, W
147D  00BE     MOVWF 0xBE
147E  01BF     CLRF 0xBF
147F  083E     MOVF 0xBE, W
1480  00B0     MOVWF testAct
1481  083F     MOVF 0xBF, W
1482  00B1     MOVWF ret
1483  083A     MOVF testAct, W
1484  0086     MOVWF FSR1L
1485  083B     MOVF 0xBB, W
1486  0087     MOVWF FSR1H
1487  0801     MOVF INDF1, W
1488  00C0     MOVWF 0xC0
1489  01C1     CLRF error
148A  0840     MOVF 0xC0, W
148B  00B2     MOVWF testVoy
148C  0841     MOVF error, W
148D  00B3     MOVWF ap
148E  3187     MOVLP 0x7
148F  2798     CALL 0x798
1490  3194     MOVLP 0x14
599:               initialConditions(*testAct, *testVoy, *autom);
1491  0021     MOVLB 0x1
1492  083A     MOVF testAct, W
1493  0086     MOVWF FSR1L
1494  083B     MOVF 0xBB, W
1495  0087     MOVWF FSR1H
1496  0801     MOVF INDF1, W
1497  00BE     MOVWF 0xBE
1498  01BF     CLRF 0xBF
1499  083E     MOVF 0xBE, W
149A  00B0     MOVWF testAct
149B  083F     MOVF 0xBF, W
149C  00B1     MOVWF ret
149D  083C     MOVF testVoy, W
149E  0086     MOVWF FSR1L
149F  083D     MOVF 0xBD, W
14A0  0087     MOVWF FSR1H
14A1  0801     MOVF INDF1, W
14A2  00C0     MOVWF 0xC0
14A3  01C1     CLRF error
14A4  0840     MOVF 0xC0, W
14A5  00B2     MOVWF testVoy
14A6  0841     MOVF error, W
14A7  00B3     MOVWF ap
14A8  0838     MOVF autom, W
14A9  0086     MOVWF FSR1L
14AA  0839     MOVF 0xB9, W
14AB  0087     MOVWF FSR1H
14AC  0801     MOVF INDF1, W
14AD  00C2     MOVWF 0xC2
14AE  01C3     CLRF 0xC3
14AF  0842     MOVF 0xC2, W
14B0  00B4     MOVWF s
14B1  0843     MOVF 0xC3, W
14B2  00B5     MOVWF f
14B3  3193     MOVLP 0x13
14B4  235E     CALL 0x35E
14B5  3194     MOVLP 0x14
600:               __delay_ms(2000);
14B6  3029     MOVLW 0x29
14B7  0021     MOVLB 0x1
14B8  00BF     MOVWF 0xBF
14B9  3096     MOVLW 0x96
14BA  00BE     MOVWF 0xBE
14BB  307F     MOVLW 0x7F
14BC  0B89     DECFSZ WREG, F
14BD  2CBC     GOTO 0x4BC
14BE  0BBE     DECFSZ 0xBE, F
14BF  2CBC     GOTO 0x4BC
14C0  0BBF     DECFSZ 0xBF, F
14C1  2CBC     GOTO 0x4BC
601:           
602:           }
14C2  0008     RETURN
603:           
604:           void alerteDefautEtape16(char etape[], bool *testAct, bool *testVoy, bool *autom) {
605:           
606:               char error[20] = "-> ERREUR: ";
0B4E  3040     MOVLW 0x40
0B4F  0086     MOVWF FSR1L
0B50  3002     MOVLW 0x2
0B51  0087     MOVWF FSR1H
0B52  3057     MOVLW 0x57
0B53  0084     MOVWF FSR0L
0B54  3001     MOVLW 0x1
0B55  0085     MOVWF FSR0H
0B56  3014     MOVLW 0x14
0B57  0021     MOVLB 0x1
0B58  00DC     MOVWF 0xDC
0B59  0016     MOVIW FSR1++
0B5A  001A     MOVWI FSR0++
0B5B  0BDC     DECFSZ 0xDC, F
0B5C  2B59     GOTO 0x359
607:               char eol[10] = "\r\n";
0B5D  30B4     MOVLW 0xB4
0B5E  0086     MOVWF FSR1L
0B5F  3001     MOVLW 0x1
0B60  0087     MOVWF FSR1H
0B61  304D     MOVLW 0x4D
0B62  0084     MOVWF FSR0L
0B63  3001     MOVLW 0x1
0B64  0085     MOVWF FSR0H
0B65  300A     MOVLW 0xA
0B66  00DC     MOVWF 0xDC
0B67  0016     MOVIW FSR1++
0B68  001A     MOVWI FSR0++
0B69  0BDC     DECFSZ 0xDC, F
0B6A  2B67     GOTO 0x367
608:               ledNonConforme(true);
0B6B  3001     MOVLW 0x1
0B6C  319D     MOVLP 0x1D
0B6D  25A3     CALL 0x5A3
0B6E  318B     MOVLP 0xB
609:               ledProgession(true);
0B6F  3001     MOVLW 0x1
0B70  319D     MOVLP 0x1D
0B71  25B0     CALL 0x5B0
0B72  318B     MOVLP 0xB
610:               ledConforme(false);
0B73  3000     MOVLW 0x0
0B74  319D     MOVLP 0x1D
0B75  2596     CALL 0x596
0B76  318B     MOVLP 0xB
611:               //alimenter(false);
612:               displayManager(etape, NON_CONFORME, "VERIFIER P1 ET P2", "PRESSER OK OU ERREUR");
0B77  0021     MOVLB 0x1
0B78  0858     MOVF 0xD8, W
0B79  0020     MOVLB 0x0
0B7A  00AF     MOVWF s
0B7B  0021     MOVLB 0x1
0B7C  0857     MOVF etape, W
0B7D  0020     MOVLB 0x0
0B7E  00AE     MOVWF fp
0B7F  30E5     MOVLW 0xE5
0B80  00B0     MOVWF s2
0B81  30A0     MOVLW 0xA0
0B82  00B1     MOVWF d
0B83  30C1     MOVLW 0xC1
0B84  00B2     MOVWF c
0B85  30A0     MOVLW 0xA0
0B86  00B3     MOVWF dest
0B87  3049     MOVLW 0x49
0B88  00B4     MOVWF counter
0B89  30A0     MOVLW 0xA0
0B8A  00B5     MOVWF src
0B8B  3194     MOVLP 0x14
0B8C  24C3     CALL 0x4C3
0B8D  318B     MOVLP 0xB
613:               printf(strcat(strcat(error, etape), eol));
0B8E  3057     MOVLW 0x57
0B8F  0020     MOVLB 0x0
0B90  00B3     MOVWF dest
0B91  3001     MOVLW 0x1
0B92  00B4     MOVWF counter
0B93  0021     MOVLB 0x1
0B94  0858     MOVF 0xD8, W
0B95  0020     MOVLB 0x0
0B96  00B6     MOVWF buf
0B97  0021     MOVLB 0x1
0B98  0857     MOVF etape, W
0B99  0020     MOVLB 0x0
0B9A  00B5     MOVWF src
0B9B  319E     MOVLP 0x1E
0B9C  26A4     CALL 0x6A4
0B9D  318B     MOVLP 0xB
0B9E  0020     MOVLB 0x0
0B9F  0834     MOVF counter, W
0BA0  0022     MOVLB 0x2
0BA1  00EC     MOVWF 0x16C
0BA2  0020     MOVLB 0x0
0BA3  0833     MOVF dest, W
0BA4  0022     MOVLB 0x2
0BA5  00EB     MOVWF 0x16B
0BA6  086C     MOVF 0x16C, W
0BA7  0020     MOVLB 0x0
0BA8  00B4     MOVWF counter
0BA9  0022     MOVLB 0x2
0BAA  086B     MOVF 0x16B, W
0BAB  0020     MOVLB 0x0
0BAC  00B3     MOVWF dest
0BAD  304D     MOVLW 0x4D
0BAE  00B5     MOVWF src
0BAF  3001     MOVLW 0x1
0BB0  00B6     MOVWF buf
0BB1  319E     MOVLP 0x1E
0BB2  26A4     CALL 0x6A4
0BB3  318B     MOVLP 0xB
0BB4  0020     MOVLB 0x0
0BB5  0834     MOVF counter, W
0BB6  0021     MOVLB 0x1
0BB7  00AE     MOVWF 0xAE
0BB8  0020     MOVLB 0x0
0BB9  0833     MOVF dest, W
0BBA  0021     MOVLB 0x1
0BBB  00AD     MOVWF fmt
0BBC  319E     MOVLP 0x1E
0BBD  268E     CALL 0x68E
0BBE  318B     MOVLP 0xB
614:               errorAlert();
0BBF  3193     MOVLP 0x13
0BC0  23E6     CALL 0x3E6
0BC1  318B     MOVLP 0xB
615:           
616:               bool reponse = reponseOperateur(*autom);
0BC2  0021     MOVLB 0x1
0BC3  085B     MOVF autom, W
0BC4  0086     MOVWF FSR1L
0BC5  3002     MOVLW 0x2
0BC6  0087     MOVWF FSR1H
0BC7  0801     MOVF INDF1, W
0BC8  3196     MOVLP 0x16
0BC9  2673     CALL 0x673
0BCA  318B     MOVLP 0xB
0BCB  0021     MOVLB 0x1
0BCC  00DC     MOVWF 0xDC
0BCD  085C     MOVF 0xDC, W
0BCE  0022     MOVLB 0x2
0BCF  00ED     MOVWF reponse
617:               __delay_ms(500);
0BD0  300B     MOVLW 0xB
0BD1  0021     MOVLB 0x1
0BD2  00DD     MOVWF 0xDD
0BD3  3026     MOVLW 0x26
0BD4  00DC     MOVWF 0xDC
0BD5  305D     MOVLW 0x5D
0BD6  0B89     DECFSZ WREG, F
0BD7  2BD6     GOTO 0x3D6
0BD8  0BDC     DECFSZ 0xDC, F
0BD9  2BD6     GOTO 0x3D6
0BDA  0BDD     DECFSZ 0xDD, F
0BDB  2BD6     GOTO 0x3D6
0BDC  3200     BRA 0xBDD
618:               if (reponse) {
0BDD  0022     MOVLB 0x2
0BDE  086D     MOVF reponse, W
0BDF  1903     BTFSC STATUS, 0x2
0BE0  2BE2     GOTO 0x3E2
0BE1  2BE3     GOTO 0x3E3
0BE2  2C13     GOTO 0x413
619:           
620:                   // ledNonConforme(false);
621:                   *testAct = false;
0BE3  0021     MOVLB 0x1
0BE4  0859     MOVF testAct, W
0BE5  0086     MOVWF FSR1L
0BE6  3002     MOVLW 0x2
0BE7  0087     MOVWF FSR1H
0BE8  0181     CLRF INDF1
622:                   *testVoy = false;
0BE9  085A     MOVF testVoy, W
0BEA  0086     MOVWF FSR1L
0BEB  3002     MOVLW 0x2
0BEC  0087     MOVWF FSR1H
0BED  0181     CLRF INDF1
623:                   //alerteDefaut("ETAPE 16 CONFIRMEE", &testAct, &testVoy);
624:                   displayManager("ETAPE 16", "NON CONFORME", "RESULTAT CONFIRME", ACQ );
0BEE  3093     MOVLW 0x93
0BEF  0020     MOVLB 0x0
0BF0  00AE     MOVWF fp
0BF1  30A2     MOVLW 0xA2
0BF2  00AF     MOVWF s
0BF3  30EA     MOVLW 0xEA
0BF4  00B0     MOVWF s2
0BF5  30A0     MOVLW 0xA0
0BF6  00B1     MOVWF d
0BF7  30D3     MOVLW 0xD3
0BF8  00B2     MOVWF c
0BF9  30A0     MOVLW 0xA0
0BFA  00B3     MOVWF dest
0BFB  305E     MOVLW 0x5E
0BFC  00B4     MOVWF counter
0BFD  30A0     MOVLW 0xA0
0BFE  00B5     MOVWF src
0BFF  3194     MOVLP 0x14
0C00  24C3     CALL 0x4C3
0C01  318B     MOVLP 0xB
625:                   sortieErreur(&autom, &testAct, &testVoy);
0C02  30DB     MOVLW 0xDB
0C03  0021     MOVLB 0x1
0C04  00B8     MOVWF autom
0C05  3000     MOVLW 0x0
0C06  00B9     MOVWF 0xB9
0C07  30D9     MOVLW 0xD9
0C08  00BA     MOVWF testAct
0C09  3000     MOVLW 0x0
0C0A  00BB     MOVWF 0xBB
0C0B  30DA     MOVLW 0xDA
0C0C  00BC     MOVWF testVoy
0C0D  3000     MOVLW 0x0
0C0E  00BD     MOVWF 0xBD
0C0F  3194     MOVLP 0x14
0C10  2477     CALL 0x477
0C11  318B     MOVLP 0xB
626:           
627:               } else {
0C12  2C9B     GOTO 0x49B
628:           
629:                   displayManager("ETAPE 16", "TEST P1", LIGNE_VIDE, LIGNE_VIDE);
0C13  3093     MOVLW 0x93
0C14  0020     MOVLB 0x0
0C15  00AE     MOVWF fp
0C16  30A2     MOVLW 0xA2
0C17  00AF     MOVWF s
0C18  30BE     MOVLW 0xBE
0C19  00B0     MOVWF s2
0C1A  30A2     MOVLW 0xA2
0C1B  00B1     MOVWF d
0C1C  30AD     MOVLW 0xAD
0C1D  00B2     MOVWF c
0C1E  30A0     MOVLW 0xA0
0C1F  00B3     MOVWF dest
0C20  30AD     MOVLW 0xAD
0C21  00B4     MOVWF counter
0C22  30A0     MOVLW 0xA0
0C23  00B5     MOVWF src
0C24  3194     MOVLP 0x14
0C25  24C3     CALL 0x4C3
0C26  318B     MOVLP 0xB
630:                   ledNonConforme(false);
0C27  3000     MOVLW 0x0
0C28  319D     MOVLP 0x1D
0C29  25A3     CALL 0x5A3
0C2A  318B     MOVLP 0xB
631:                   ledProgession(true);
0C2B  3001     MOVLW 0x1
0C2C  319D     MOVLP 0x1D
0C2D  25B0     CALL 0x5B0
0C2E  318B     MOVLP 0xB
632:                   ledConforme(false);
0C2F  3000     MOVLW 0x0
0C30  319D     MOVLP 0x1D
0C31  2596     CALL 0x596
0C32  318B     MOVLP 0xB
633:                   setP1(true);
0C33  3001     MOVLW 0x1
0C34  319D     MOVLP 0x1D
0C35  25D7     CALL 0x5D7
0C36  318B     MOVLP 0xB
634:                   __delay_ms(1200);
0C37  3019     MOVLW 0x19
0C38  0021     MOVLB 0x1
0C39  00DD     MOVWF 0xDD
0C3A  305A     MOVLW 0x5A
0C3B  00DC     MOVWF 0xDC
0C3C  30B1     MOVLW 0xB1
0C3D  0B89     DECFSZ WREG, F
0C3E  2C3D     GOTO 0x43D
0C3F  0BDC     DECFSZ 0xDC, F
0C40  2C3D     GOTO 0x43D
0C41  0BDD     DECFSZ 0xDD, F
0C42  2C3D     GOTO 0x43D
0C43  3200     BRA 0xC44
635:                   setP1(false);
0C44  3000     MOVLW 0x0
0C45  319D     MOVLP 0x1D
0C46  25D7     CALL 0x5D7
0C47  318B     MOVLP 0xB
636:                   __delay_ms(1000);
0C48  3015     MOVLW 0x15
0C49  0021     MOVLB 0x1
0C4A  00DD     MOVWF 0xDD
0C4B  304B     MOVLW 0x4B
0C4C  00DC     MOVWF 0xDC
0C4D  30BE     MOVLW 0xBE
0C4E  0B89     DECFSZ WREG, F
0C4F  2C4E     GOTO 0x44E
0C50  0BDC     DECFSZ 0xDC, F
0C51  2C4E     GOTO 0x44E
0C52  0BDD     DECFSZ 0xDD, F
0C53  2C4E     GOTO 0x44E
0C54  0000     NOP
637:                   if (testR1(true) && testR2(true) && testR3(true)) {
0C55  3001     MOVLW 0x1
0C56  3190     MOVLP 0x10
0C57  2074     CALL 0x74
0C58  318B     MOVLP 0xB
0C59  3A00     XORLW 0x0
0C5A  1903     BTFSC STATUS, 0x2
0C5B  2C5D     GOTO 0x45D
0C5C  2C5E     GOTO 0x45E
0C5D  2C85     GOTO 0x485
0C5E  3001     MOVLW 0x1
0C5F  3190     MOVLP 0x10
0C60  2097     CALL 0x97
0C61  318B     MOVLP 0xB
0C62  3A00     XORLW 0x0
0C63  1903     BTFSC STATUS, 0x2
0C64  2C66     GOTO 0x466
0C65  2C67     GOTO 0x467
0C66  2C85     GOTO 0x485
0C67  3001     MOVLW 0x1
0C68  3190     MOVLP 0x10
0C69  20BA     CALL 0xBA
0C6A  318B     MOVLP 0xB
0C6B  3A00     XORLW 0x0
0C6C  1903     BTFSC STATUS, 0x2
0C6D  2C6F     GOTO 0x46F
0C6E  2C70     GOTO 0x470
0C6F  2C85     GOTO 0x485
638:           
639:                       displayManager("ETAPE 16", "TEST P1", "ERREUR VALIDEE", "TEST OK");
0C70  3093     MOVLW 0x93
0C71  0020     MOVLB 0x0
0C72  00AE     MOVWF fp
0C73  30A2     MOVLW 0xA2
0C74  00AF     MOVWF s
0C75  30BE     MOVLW 0xBE
0C76  00B0     MOVWF s2
0C77  30A2     MOVLW 0xA2
0C78  00B1     MOVWF d
0C79  3091     MOVLW 0x91
0C7A  00B2     MOVWF c
0C7B  30A1     MOVLW 0xA1
0C7C  00B3     MOVWF dest
0C7D  30AE     MOVLW 0xAE
0C7E  00B4     MOVWF counter
0C7F  30A2     MOVLW 0xA2
0C80  00B5     MOVWF src
0C81  3194     MOVLP 0x14
0C82  24C3     CALL 0x4C3
0C83  318B     MOVLP 0xB
640:           
641:                   } else {
0C84  2C9B     GOTO 0x49B
642:           
643:                       *testAct = false;
0C85  0021     MOVLB 0x1
0C86  0859     MOVF testAct, W
0C87  0086     MOVWF FSR1L
0C88  3002     MOVLW 0x2
0C89  0087     MOVWF FSR1H
0C8A  0181     CLRF INDF1
644:                       alerteDefaut("ETAPE 16", &testAct, &testVoy);
0C8B  3093     MOVLW 0x93
0C8C  00B0     MOVWF testAct
0C8D  30A2     MOVLW 0xA2
0C8E  00B1     MOVWF ret
0C8F  30D9     MOVLW 0xD9
0C90  00B2     MOVWF testVoy
0C91  3000     MOVLW 0x0
0C92  00B3     MOVWF ap
0C93  30DA     MOVLW 0xDA
0C94  00B4     MOVWF s
0C95  3000     MOVLW 0x0
0C96  00B5     MOVWF f
0C97  3196     MOVLP 0x16
0C98  26EB     CALL 0x6EB
0C99  318B     MOVLP 0xB
0C9A  2C02     GOTO 0x402
645:                       sortieErreur(&autom, &testAct, &testVoy);
646:                   }
647:           
648:               }
649:           
650:           
651:           }
0C9B  0008     RETURN
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/pin_manager.c  -------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATE = 0x00;
1FA3  0022     MOVLB 0x2
1FA4  0190     CLRF LATE
61:                LATD = 0x00;
1FA5  018F     CLRF LATD
62:                LATA = 0x00;
1FA6  018C     CLRF LATA
63:                LATB = 0x00;
1FA7  018D     CLRF LATB
64:                LATC = 0x00;
1FA8  018E     CLRF LATC
65:            
66:                /**
67:                TRISx registers
68:                */
69:                TRISE = 0x08;
1FA9  3008     MOVLW 0x8
1FAA  0021     MOVLB 0x1
1FAB  0090     MOVWF TRISE
70:                TRISA = 0x00;
1FAC  018C     CLRF TRISA
71:                TRISB = 0xEF;
1FAD  30EF     MOVLW 0xEF
1FAE  008D     MOVWF TRISB
72:                TRISC = 0xBF;
1FAF  30BF     MOVLW 0xBF
1FB0  008E     MOVWF TRISC
73:                TRISD = 0xFF;
1FB1  30FF     MOVLW 0xFF
1FB2  008F     MOVWF TRISD
74:            
75:                /**
76:                ANSELx registers
77:                */
78:                ANSELD = 0x00;
1FB3  0023     MOVLB 0x3
1FB4  018F     CLRF ANSELD
79:                ANSELB = 0x3F;
1FB5  303F     MOVLW 0x3F
1FB6  008D     MOVWF ANSELB
80:                ANSELE = 0x00;
1FB7  0190     CLRF ANSELE
81:                ANSELA = 0x3C;
1FB8  303C     MOVLW 0x3C
1FB9  008C     MOVWF ANSELA
82:            
83:                /**
84:                WPUx registers
85:                */
86:                WPUE = 0x00;
1FBA  0024     MOVLB 0x4
1FBB  0190     CLRF WPUE
87:                WPUB = 0x00;
1FBC  018D     CLRF WPUB
88:                OPTION_REGbits.nWPUEN = 1;
1FBD  0021     MOVLB 0x1
1FBE  1795     BSF OPTION_REG, 0x7
89:            
90:            
91:                /**
92:                APFCONx registers
93:                */
94:                APFCON = 0x00;
1FBF  0022     MOVLB 0x2
1FC0  019D     CLRF APFCON
95:            
96:            
97:            
98:            
99:               
100:               
101:           }
1FC1  0008     RETURN
102:             
103:           void PIN_MANAGER_IOC(void)
104:           {   
105:           }
106:           
107:           /**
108:            End of File
109:           */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/mcc.c  ---------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:            
53:                I2C_Initialize();
1E52  319D     MOVLP 0x1D
1E53  254F     CALL 0x54F
1E54  319E     MOVLP 0x1E
54:                PIN_MANAGER_Initialize();
1E55  319F     MOVLP 0x1F
1E56  27A3     CALL 0x7A3
1E57  319E     MOVLP 0x1E
55:                OSCILLATOR_Initialize();
1E58  319D     MOVLP 0x1D
1E59  2570     CALL 0x570
1E5A  319E     MOVLP 0x1E
56:                WDT_Initialize();
1E5B  319C     MOVLP 0x1C
1E5C  24A4     CALL 0x4A4
1E5D  319E     MOVLP 0x1E
57:                ADC_Initialize();
1E5E  319D     MOVLP 0x1D
1E5F  2508     CALL 0x508
1E60  319E     MOVLP 0x1E
58:                EUSART_Initialize();
1E61  3194     MOVLP 0x14
1E62  242E     CALL 0x42E
1E63  319E     MOVLP 0x1E
59:            }
1E64  0008     RETURN
60:            
61:            void OSCILLATOR_Initialize(void)
62:            {
63:                // SCS FOSC; SPLLEN disabled; IRCF 8MHz_HF; 
64:                OSCCON = 0x70;
1D70  3070     MOVLW 0x70
1D71  0021     MOVLB 0x1
1D72  0099     MOVWF OSCCON
65:                // TUN 0; 
66:                OSCTUNE = 0x00;
1D73  0198     CLRF OSCTUNE
67:                // SBOREN disabled; 
68:                BORCON = 0x00;
1D74  0022     MOVLB 0x2
1D75  0196     CLRF BORCON
69:                // Wait for PLL to stabilize
70:                while(PLLR == 0)
71:                {
72:                }
1D76  0021     MOVLB 0x1
1D77  1F1A     BTFSS OSCSTAT, 0x6
1D78  2D7A     GOTO 0x57A
1D79  2D7B     GOTO 0x57B
1D7A  2D76     GOTO 0x576
73:            }
1D7B  0008     RETURN
74:            
75:            void WDT_Initialize(void)
76:            {
77:                // WDTPS 1:65536; SWDTEN OFF; 
78:                WDTCON = 0x16;
1CA4  3016     MOVLW 0x16
1CA5  0021     MOVLB 0x1
1CA6  0097     MOVWF WDTCON
79:            }
1CA7  0008     RETURN
80:            
81:            /**
82:             End of File
83:            */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/interrupt_manager.c  -------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
19:                    Device            :  PIC16LF1939
20:                    Driver Version    :  2.04
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.31 and above or later
23:                    MPLAB 	          :  MPLAB X 5.45
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void __interrupt() INTERRUPT_InterruptManager (void)
0004  147E     BSF 0xFE, 0x0
0005  3180     MOVLP 0x0
53:            {
54:                // interrupt handler
55:                if(INTCONbits.PEIE == 1)
0006  1F0B     BTFSS INTCON, 0x6
0007  2809     GOTO 0x9
0008  280A     GOTO 0xA
0009  2848     GOTO 0x48
56:                {
57:                    if(PIE1bits.TXIE == 1 && PIR1bits.TXIF == 1)
000A  0021     MOVLB 0x1
000B  1E11     BTFSS PIE1, 0x4
000C  280E     GOTO 0xE
000D  280F     GOTO 0xF
000E  281B     GOTO 0x1B
000F  0020     MOVLB 0x0
0010  1E11     BTFSS PIR1, 0x4
0011  2813     GOTO 0x13
0012  2814     GOTO 0x14
0013  281B     GOTO 0x1B
58:                    {
59:                        EUSART_TxDefaultInterruptHandler();
0014  0022     MOVLB 0x2
0015  0847     MOVF 0x147, W
0016  008A     MOVWF PCLATH
0017  0846     MOVF EUSART_TxDefaultInterruptHandler, W
0018  000A     CALLW
0019  3180     MOVLP 0x0
60:                    } 
001A  2848     GOTO 0x48
61:                    else if(PIE1bits.RCIE == 1 && PIR1bits.RCIF == 1)
001B  0021     MOVLB 0x1
001C  1E91     BTFSS PIE1, 0x5
001D  281F     GOTO 0x1F
001E  2820     GOTO 0x20
001F  282C     GOTO 0x2C
0020  0020     MOVLB 0x0
0021  1E91     BTFSS PIR1, 0x5
0022  2824     GOTO 0x24
0023  2825     GOTO 0x25
0024  282C     GOTO 0x2C
62:                    {
63:                        EUSART_RxDefaultInterruptHandler();
0025  0022     MOVLB 0x2
0026  0845     MOVF 0x145, W
0027  008A     MOVWF PCLATH
0028  0844     MOVF EUSART_RxDefaultInterruptHandler, W
0029  000A     CALLW
002A  3180     MOVLP 0x0
64:                    } 
002B  2848     GOTO 0x48
65:                    else if(PIE2bits.BCLIE == 1 && PIR2bits.BCLIF == 1)
002C  0021     MOVLB 0x1
002D  1D92     BTFSS PIE2, 0x3
002E  2830     GOTO 0x30
002F  2831     GOTO 0x31
0030  283D     GOTO 0x3D
0031  0020     MOVLB 0x0
0032  1D92     BTFSS PIR2, 0x3
0033  2835     GOTO 0x35
0034  2836     GOTO 0x36
0035  283D     GOTO 0x3D
66:                    {
67:                        MSSP_InterruptHandler();
0036  0022     MOVLB 0x2
0037  084B     MOVF 0x14B, W
0038  008A     MOVWF PCLATH
0039  084A     MOVF MSSP_InterruptHandler, W
003A  000A     CALLW
003B  3180     MOVLP 0x0
68:                    } 
003C  2848     GOTO 0x48
69:                    else if(PIE1bits.SSPIE == 1 && PIR1bits.SSPIF == 1)
003D  0021     MOVLB 0x1
003E  1D91     BTFSS PIE1, 0x3
003F  2841     GOTO 0x41
0040  2842     GOTO 0x42
0041  2848     GOTO 0x48
0042  0020     MOVLB 0x0
0043  1D91     BTFSS PIR1, 0x3
0044  2846     GOTO 0x46
0045  2847     GOTO 0x47
0046  2848     GOTO 0x48
0047  2836     GOTO 0x36
70:                    {
71:                        MSSP_InterruptHandler();
72:                    } 
73:                    else
74:                    {
75:                        //Unhandled Interrupt
76:                    }
77:                }      
78:                else
79:                {
80:                    //Unhandled Interrupt
81:                }
82:            }
0048  107E     BCF btemp, 0x0
83:            /**
84:             End of File
85:            */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/i2c_master.c  --------------------
1:             /**
2:               I2C Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 i2c_master.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the I2C driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for I2C.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  1.0.2
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "i2c_master.h"
48:            #include <xc.h>
49:            
50:            // I2C STATES
51:            typedef enum {
52:                I2C_IDLE = 0,
53:                I2C_SEND_ADR_READ,
54:                I2C_SEND_ADR_WRITE,
55:                I2C_TX,
56:                I2C_RX,
57:                I2C_RCEN,
58:                I2C_TX_EMPTY,      
59:                I2C_SEND_RESTART_READ,
60:                I2C_SEND_RESTART_WRITE,
61:                I2C_SEND_RESTART,
62:                I2C_SEND_STOP,
63:                I2C_RX_ACK,
64:                I2C_RX_NACK_STOP,
65:                I2C_RX_NACK_RESTART,
66:                I2C_RESET,
67:                I2C_ADDRESS_NACK,
68:            
69:            } i2c_fsm_states_t;
70:            
71:            // I2C Event callBack List
72:            typedef enum {
73:                I2C_DATA_COMPLETE = 0,
74:                I2C_WRITE_COLLISION,
75:                I2C_ADDR_NACK,
76:                I2C_DATA_NACK,
77:                I2C_TIMEOUT,
78:                I2C_NULL
79:            } i2c_callbackIndex_t;
80:            
81:            // I2C Status Structure
82:            typedef struct
83:            {
84:                i2c_callback_t callbackTable[6];
85:                void *callbackPayload[6];           //  each callBack can have a payload
86:                uint16_t time_out;                  // I2C Timeout Counter between I2C Events.
87:                uint16_t time_out_value;            // Reload value for the timeouts
88:                i2c_address_t address;             // The I2C Address
89:                uint8_t *data_ptr;                  // pointer to a data buffer
90:                size_t data_length;                 // Bytes in the data buffer
91:                i2c_fsm_states_t state;            // Driver State
92:                i2c_error_t error;
93:                unsigned addressNackCheck:1;
94:                unsigned busy:1;
95:                unsigned inUse:1;
96:                unsigned bufferFree:1;
97:            
98:            } i2c_status_t;
99:            
100:           static void I2C_SetCallback(i2c_callbackIndex_t idx, i2c_callback_t cb, void *ptr);
101:           static void I2C_MasterIsr(void);
102:           static inline void I2C_MasterFsm(void);
103:           
104:           /* I2C interfaces */
105:           static inline bool I2C_MasterOpen(void);
106:           static inline void I2C_MasterClose(void);    
107:           static inline uint8_t I2C_MasterGetRxData(void);
108:           static inline void I2C_MasterSendTxData(uint8_t data);
109:           static inline void I2C_MasterEnableRestart(void);
110:           static inline void I2C_MasterDisableRestart(void);
111:           static inline void I2C_MasterStartRx(void);
112:           static inline void I2C_MasterStart(void);
113:           static inline void I2C_MasterStop(void);
114:           static inline bool I2C_MasterIsNack(void);
115:           static inline void I2C_MasterSendAck(void);
116:           static inline void I2C_MasterSendNack(void);
117:           static inline void I2C_MasterClearBusCollision(void);
118:           
119:           /* Interrupt interfaces */
120:           static inline void I2C_MasterEnableIrq(void);
121:           static inline bool I2C_MasterIsIrqEnabled(void);
122:           static inline void I2C_MasterDisableIrq(void);
123:           static inline void I2C_MasterClearIrq(void);
124:           static inline void I2C_MasterSetIrq(void);
125:           static inline void I2C_MasterWaitForEvent(void);
126:           
127:           static i2c_fsm_states_t I2C_DO_IDLE(void);
128:           static i2c_fsm_states_t I2C_DO_SEND_ADR_READ(void);
129:           static i2c_fsm_states_t I2C_DO_SEND_ADR_WRITE(void);
130:           static i2c_fsm_states_t I2C_DO_TX(void);
131:           static i2c_fsm_states_t I2C_DO_RX(void);
132:           static i2c_fsm_states_t I2C_DO_RCEN(void);
133:           static i2c_fsm_states_t I2C_DO_TX_EMPTY(void);
134:           static i2c_fsm_states_t I2C_DO_SEND_RESTART_READ(void);
135:           static i2c_fsm_states_t I2C_DO_SEND_RESTART_WRITE(void);
136:           static i2c_fsm_states_t I2C_DO_SEND_RESTART(void);
137:           static i2c_fsm_states_t I2C_DO_SEND_STOP(void);
138:           static i2c_fsm_states_t I2C_DO_RX_ACK(void);
139:           static i2c_fsm_states_t I2C_DO_RX_NACK_STOP(void);
140:           static i2c_fsm_states_t I2C_DO_RX_NACK_RESTART(void);
141:           static i2c_fsm_states_t I2C_DO_RESET(void);
142:           static i2c_fsm_states_t I2C_DO_ADDRESS_NACK(void);
143:           
144:           
145:           typedef i2c_fsm_states_t (*i2cFsmHandler)(void);
146:           const i2cFsmHandler i2c_fsmStateTable[] = {
147:               I2C_DO_IDLE,
148:               I2C_DO_SEND_ADR_READ,
149:               I2C_DO_SEND_ADR_WRITE,
150:               I2C_DO_TX,
151:               I2C_DO_RX,
152:               I2C_DO_RCEN,
153:               I2C_DO_TX_EMPTY,
154:               I2C_DO_SEND_RESTART_READ,
155:               I2C_DO_SEND_RESTART_WRITE,
156:               I2C_DO_SEND_RESTART,
157:               I2C_DO_SEND_STOP,
158:               I2C_DO_RX_ACK,
159:               I2C_DO_RX_NACK_STOP,
160:               I2C_DO_RX_NACK_RESTART,
161:               I2C_DO_RESET,
162:               I2C_DO_ADDRESS_NACK,
163:           };
164:           
165:           i2c_status_t I2C_Status = {0};
166:           
167:           void I2C_Initialize()
168:           {
169:               SSPSTAT = 0xC0;
1D4F  30C0     MOVLW 0xC0
1D50  0024     MOVLB 0x4
1D51  0094     MOVWF SSPSTAT
170:               SSPCON1 = 0x08;
1D52  3008     MOVLW 0x8
1D53  0095     MOVWF SSPCON1
171:               SSPCON2 = 0x00;
1D54  0196     CLRF SSPCON2
172:               SSPADD  = 0x4F;
1D55  304F     MOVLW 0x4F
1D56  0092     MOVWF SSPADD
173:               SSPCON1bits.SSPEN = 0;
1D57  1295     BCF SSPCON1, 0x5
174:           }
1D58  0008     RETURN
175:           
176:           i2c_error_t I2C_Open(i2c_address_t address)
177:           {
178:               i2c_error_t returnValue = I2C_BUSY;
179:               
180:               if(!I2C_Status.inUse)
181:               {
182:                   I2C_Status.address = address;
183:                   I2C_Status.busy = 0;
184:                   I2C_Status.inUse = 1;
185:                   I2C_Status.addressNackCheck = 0;
186:                   I2C_Status.state = I2C_RESET;
187:                   I2C_Status.time_out_value = 500; // MCC should determine a reasonable starting value here.
188:                   I2C_Status.bufferFree = 1;
189:           
190:                   // set all the call backs to a default of sending stop
191:                   I2C_Status.callbackTable[I2C_DATA_COMPLETE]=I2C_CallbackReturnStop;
192:                   I2C_Status.callbackPayload[I2C_DATA_COMPLETE] = NULL;
193:                   I2C_Status.callbackTable[I2C_WRITE_COLLISION]=I2C_CallbackReturnStop;
194:                   I2C_Status.callbackPayload[I2C_WRITE_COLLISION] = NULL;
195:                   I2C_Status.callbackTable[I2C_ADDR_NACK]=I2C_CallbackReturnStop;
196:                   I2C_Status.callbackPayload[I2C_ADDR_NACK] = NULL;
197:                   I2C_Status.callbackTable[I2C_DATA_NACK]=I2C_CallbackReturnStop;
198:                   I2C_Status.callbackPayload[I2C_DATA_NACK] = NULL;
199:                   I2C_Status.callbackTable[I2C_TIMEOUT]=I2C_CallbackReturnReset;
200:                   I2C_Status.callbackPayload[I2C_TIMEOUT] = NULL;
201:                   
202:                   I2C_SetInterruptHandler(I2C_MasterIsr);
203:                   I2C_MasterClearIrq();
204:                   I2C_MasterOpen();
205:                   I2C_MasterEnableIrq();
206:                   returnValue = I2C_NOERR;
207:               }
208:               return returnValue;
209:           }
210:           
211:           i2c_error_t I2C_Close(void)
212:           {
213:               i2c_error_t returnValue = I2C_BUSY;
214:               if(!I2C_Status.busy)
215:               {
216:                   I2C_Status.inUse = 0;
217:                   I2C_Status.address = 0xff;
218:                   I2C_MasterClearIrq();
219:                   I2C_MasterDisableIrq();
220:                   I2C_MasterClose();
221:                   returnValue = I2C_Status.error;
222:               }
223:               return returnValue;
224:           }
225:           
226:           i2c_error_t I2C_MasterOperation(bool read)
227:           {
228:               i2c_error_t returnValue = I2C_BUSY;
229:               if(!I2C_Status.busy)
230:               {
231:                   I2C_Status.busy = true;
232:                   returnValue = I2C_NOERR;
233:           
234:                   if(read)
235:                   {
236:                       I2C_Status.state = I2C_SEND_ADR_READ;
237:                   }
238:                   else
239:                   {
240:                       I2C_Status.state = I2C_SEND_ADR_WRITE;
241:                   }
242:                   I2C_MasterStart();
243:               }
244:               return returnValue;
245:           }
246:           
247:           i2c_error_t I2C_MasterRead(void)
248:           {
249:               return I2C_MasterOperation(true);
250:           }
251:           
252:           i2c_error_t I2C_MasterWrite(void)
253:           {
254:               return I2C_MasterOperation(false);
255:           }
256:           
257:           void I2C_SetTimeOut(uint8_t timeOutValue)
258:           {
259:               I2C_MasterDisableIrq();
260:               I2C_Status.time_out_value = timeOutValue;
261:               I2C_MasterEnableIrq();
262:           }
263:           
264:           void I2C_SetBuffer(void *buffer, size_t bufferSize)
1DFE  00F3     MOVWF 0x273
265:           {
266:               if(I2C_Status.bufferFree)
1DFF  0023     MOVLB 0x3
1E00  1DE4     BTFSS 0x1E4, 0x3
1E01  2E03     GOTO 0x603
1E02  2E04     GOTO 0x604
1E03  2E0D     GOTO 0x60D
267:               {
268:                   I2C_Status.data_ptr = buffer;
1E04  0873     MOVF 0x1F3, W
1E05  00F2     MOVWF 0x1F2
1E06  0872     MOVF 0x1F2, W
1E07  00DF     MOVWF 0x1DF
269:                   I2C_Status.data_length = bufferSize;
1E08  0871     MOVF 0x1F1, W
1E09  00E1     MOVWF 0x1E1
1E0A  0870     MOVF 0x1F0, W
1E0B  00E0     MOVWF 0x1E0
270:                   I2C_Status.bufferFree = false;
1E0C  11E4     BCF 0x1E4, 0x3
271:               }
272:           }
1E0D  0008     RETURN
273:           
274:           void I2C_SetDataCompleteCallback(i2c_callback_t cb, void *ptr)
275:           {
276:               I2C_SetCallback(I2C_DATA_COMPLETE, cb, ptr);
1D7C  0876     MOVF 0x1F6, W
1D7D  00F1     MOVWF 0x1F1
1D7E  0875     MOVF 0x1F5, W
1D7F  00F0     MOVWF 0x1F0
1D80  0877     MOVF 0x1F7, W
1D81  00F8     MOVWF 0x1F8
1D82  0878     MOVF 0x1F8, W
1D83  00F2     MOVWF 0x1F2
1D84  3000     MOVLW 0x0
1D85  3191     MOVLP 0x11
1D86  217B     CALL 0x17B
1D87  319D     MOVLP 0x1D
277:           }
1D88  0008     RETURN
278:           
279:           void I2C_SetWriteCollisionCallback(i2c_callback_t cb, void *ptr)
280:           {
281:               I2C_SetCallback(I2C_WRITE_COLLISION, cb, ptr);
282:           }
283:           
284:           void I2C_SetAddressNackCallback(i2c_callback_t cb, void *ptr)
285:           {
286:               I2C_SetCallback(I2C_ADDR_NACK, cb, ptr);
287:           }
288:           
289:           void I2C_SetDataNackCallback(i2c_callback_t cb, void *ptr)
290:           {
291:               I2C_SetCallback(I2C_DATA_NACK, cb, ptr);
292:           }
293:           
294:           void I2C_SetTimeoutCallback(i2c_callback_t cb, void *ptr)
295:           {
296:               I2C_SetCallback(I2C_TIMEOUT, cb, ptr);
297:           }
298:           
299:           void I2C_SetInterruptHandler(void (* InterruptHandler)(void))
300:           {
301:               MSSP_InterruptHandler = InterruptHandler;
302:           }
303:           
304:           static void I2C_SetCallback(i2c_callbackIndex_t idx, i2c_callback_t cb, void *ptr)
117B  00F4     MOVWF 0x1F4
305:           {
306:               if(cb)
117C  0870     MOVF 0x1F0, W
117D  0471     IORWF 0x1F1, W
117E  1903     BTFSC STATUS, 0x2
117F  2981     GOTO 0x181
1180  2982     GOTO 0x182
1181  2995     GOTO 0x195
307:               {
308:                   I2C_Status.callbackTable[idx] = cb;
1182  3574     LSLF 0x1F4, W
1183  3EC8     ADDLW 0xC8
1184  0086     MOVWF FSR1L
1185  3001     MOVLW 0x1
1186  0087     MOVWF FSR1H
1187  0870     MOVF 0x1F0, W
1188  3FC0     MOVWI 0[FSR1]
1189  0871     MOVF 0x1F1, W
118A  3FC1     MOVWI 1[FSR1]
309:                   I2C_Status.callbackPayload[idx] = ptr;
118B  0872     MOVF 0x1F2, W
118C  00F3     MOVWF 0x1F3
118D  0874     MOVF 0x1F4, W
118E  3ED4     ADDLW 0xD4
118F  0086     MOVWF FSR1L
1190  3001     MOVLW 0x1
1191  0087     MOVWF FSR1H
1192  0873     MOVF 0x1F3, W
1193  0081     MOVWF INDF1
310:               }
1194  29A4     GOTO 0x1A4
311:               else
312:               {
313:                   I2C_Status.callbackTable[idx] = I2C_CallbackReturnStop;
1195  3574     LSLF 0x1F4, W
1196  3EC8     ADDLW 0xC8
1197  0086     MOVWF FSR1L
1198  3001     MOVLW 0x1
1199  0087     MOVWF FSR1H
119A  307C     MOVLW 0x7C
119B  3FC0     MOVWI 0[FSR1]
119C  301C     MOVLW 0x1C
119D  3FC1     MOVWI 1[FSR1]
314:                   I2C_Status.callbackPayload[idx] = NULL;
119E  0874     MOVF 0x1F4, W
119F  3ED4     ADDLW 0xD4
11A0  0086     MOVWF FSR1L
11A1  3001     MOVLW 0x1
11A2  0087     MOVWF FSR1H
11A3  0181     CLRF INDF1
315:               }
316:           }
11A4  0008     RETURN
317:           
318:           static void I2C_MasterIsr()
319:           {
320:               I2C_MasterFsm();
1CA0  3192     MOVLP 0x12
1CA1  222B     CALL 0x22B
1CA2  319C     MOVLP 0x1C
321:           }
1CA3  0008     RETURN
322:           
323:           static inline void I2C_MasterFsm(void)
324:           {
325:               I2C_MasterClearIrq();
122B  319C     MOVLP 0x1C
122C  248D     CALL 0x48D
122D  3192     MOVLP 0x12
326:           
327:               if(I2C_Status.addressNackCheck && I2C_MasterIsNack())
122E  0023     MOVLB 0x3
122F  1C64     BTFSS 0x1E4, 0x0
1230  2A32     GOTO 0x232
1231  2A33     GOTO 0x233
1232  2A41     GOTO 0x241
1233  319C     MOVLP 0x1C
1234  24DA     CALL 0x4DA
1235  3192     MOVLP 0x12
1236  3A00     XORLW 0x0
1237  1903     BTFSC STATUS, 0x2
1238  2A3A     GOTO 0x23A
1239  2A3B     GOTO 0x23B
123A  2A41     GOTO 0x241
328:               {
329:                   I2C_Status.state = I2C_ADDRESS_NACK;
123B  300F     MOVLW 0xF
123C  0020     MOVLB 0x0
123D  00A0     MOVWF __pcstackBANK0
123E  0820     MOVF __pcstackBANK0, W
123F  0023     MOVLB 0x3
1240  00E2     MOVWF 0x1E2
330:               }
331:               I2C_Status.state = i2c_fsmStateTable[I2C_Status.state]();
1241  0023     MOVLB 0x3
1242  0862     MOVF 0x1E2, W
1243  0020     MOVLB 0x0
1244  00A0     MOVWF __pcstackBANK0
1245  01A1     CLRF 0x21
1246  35A0     LSLF __pcstackBANK0, F
1247  0DA1     RLF 0x21, F
1248  3000     MOVLW 0x0
1249  0720     ADDWF __pcstackBANK0, W
124A  0084     MOVWF FSR0
124B  3098     MOVLW 0x98
124C  3D21     ADDWFC 0x21, W
124D  0085     MOVWF FSR0H
124E  3F01     MOVIW 1[FSR0]
124F  008A     MOVWF PCLATH
1250  3F00     MOVIW 0[FSR0]
1251  000A     CALLW
1252  3192     MOVLP 0x12
1253  0020     MOVLB 0x0
1254  00A2     MOVWF 0x22
1255  0822     MOVF 0x22, W
1256  0023     MOVLB 0x3
1257  00E2     MOVWF 0x1E2
332:           }
1258  0008     RETURN
333:           
334:           
335:           static i2c_fsm_states_t I2C_DO_IDLE(void)
336:           {
337:               I2C_Status.busy = false;
1CAD  0023     MOVLB 0x3
1CAE  10E4     BCF 0x1E4, 0x1
338:               I2C_Status.error = I2C_NOERR;
1CAF  01E3     CLRF 0x1E3
339:               return I2C_RESET;
1CB0  300E     MOVLW 0xE
340:           }
1CB1  0008     RETURN
341:           
342:           static i2c_fsm_states_t I2C_DO_SEND_ADR_READ(void)
343:           {
344:               I2C_Status.addressNackCheck = 1;
1D10  0023     MOVLB 0x3
1D11  1464     BSF 0x1E4, 0x0
345:               I2C_MasterSendTxData((uint8_t) (I2C_Status.address << 1 | 1));
1D12  1403     BSF STATUS, 0x0
1D13  0D5E     RLF 0x1DE, W
1D14  319C     MOVLP 0x1C
1D15  24A8     CALL 0x4A8
1D16  319D     MOVLP 0x1D
346:               return I2C_RCEN;
1D17  3005     MOVLW 0x5
347:           }
1D18  0008     RETURN
348:           
349:           static i2c_fsm_states_t I2C_DO_SEND_ADR_WRITE(void)
350:           {
351:               I2C_Status.addressNackCheck = 1;
1D00  0023     MOVLB 0x3
1D01  1464     BSF 0x1E4, 0x0
352:               I2C_MasterSendTxData((uint8_t) (I2C_Status.address << 1));
1D02  355E     LSLF 0x1DE, W
1D03  319C     MOVLP 0x1C
1D04  24A8     CALL 0x4A8
1D05  319D     MOVLP 0x1D
353:               return I2C_TX;
1D06  3003     MOVLW 0x3
354:           }
1D07  0008     RETURN
355:           
356:           static i2c_fsm_states_t I2C_DO_TX(void)
357:           {
358:               if(I2C_MasterIsNack())
1566  319C     MOVLP 0x1C
1567  24DA     CALL 0x4DA
1568  3195     MOVLP 0x15
1569  3A00     XORLW 0x0
156A  1903     BTFSC STATUS, 0x2
156B  2D6D     GOTO 0x56D
156C  2D6E     GOTO 0x56E
156D  2D9F     GOTO 0x59F
156E  2D7B     GOTO 0x57B
359:               {
360:                   switch(I2C_Status.callbackTable[I2C_DATA_NACK](I2C_Status.callbackPayload[I2C_DATA_NACK]))
361:                   {
362:                       case I2C_RESTART_READ:
363:                           return I2C_DO_SEND_RESTART_READ();
156F  319C     MOVLP 0x1C
1570  24B2     CALL 0x4B2
1571  3195     MOVLP 0x15
1572  2DBC     GOTO 0x5BC
364:                       case I2C_RESTART_WRITE:
365:                             return I2C_DO_SEND_RESTART_WRITE();
1573  319C     MOVLP 0x1C
1574  24B7     CALL 0x4B7
1575  3195     MOVLP 0x15
1576  2DBC     GOTO 0x5BC
366:                       default:
367:                       case I2C_CONTINUE:
368:                       case I2C_STOP:
369:                           return I2C_DO_SEND_STOP();
1577  319C     MOVLP 0x1C
1578  24C1     CALL 0x4C1
1579  3195     MOVLP 0x15
157A  2DBC     GOTO 0x5BC
370:                   }
157B  0023     MOVLB 0x3
157C  0857     MOVF 0x1D7, W
157D  00FA     MOVWF 0x1FA
157E  087A     MOVF 0x1FA, W
157F  00F9     MOVWF 0x1F9
1580  3006     MOVLW 0x6
1581  3EC8     ADDLW 0xC8
1582  0086     MOVWF FSR1L
1583  3001     MOVLW 0x1
1584  0087     MOVWF FSR1H
1585  3F41     MOVIW 1[FSR1]
1586  008A     MOVWF PCLATH
1587  3F40     MOVIW 0[FSR1]
1588  000A     CALLW
1589  3195     MOVLP 0x15
158A  00FB     MOVWF 0x1FB
158B  01FC     CLRF 0x1FC
158C  087C     MOVF 0x1FC, W
158D  3A00     XORLW 0x0
158E  1903     BTFSC STATUS, 0x2
158F  2D91     GOTO 0x591
1590  2D77     GOTO 0x577
1591  087B     MOVF 0x1FB, W
1592  3A01     XORLW 0x1
1593  1903     BTFSC STATUS, 0x2
1594  2D77     GOTO 0x577
1595  3A03     XORLW 0x3
1596  1903     BTFSC STATUS, 0x2
1597  2D6F     GOTO 0x56F
1598  3A01     XORLW 0x1
1599  1903     BTFSC STATUS, 0x2
159A  2D73     GOTO 0x573
159B  3A07     XORLW 0x7
159C  1903     BTFSC STATUS, 0x2
159D  2D77     GOTO 0x577
159E  2D77     GOTO 0x577
371:               }
372:               else
373:               {
374:                   I2C_Status.addressNackCheck = 0;
159F  0023     MOVLB 0x3
15A0  1064     BCF 0x1E4, 0x0
375:                   I2C_MasterSendTxData(*I2C_Status.data_ptr++);
15A1  3017     MOVLW 0x17
15A2  3EC8     ADDLW 0xC8
15A3  0086     MOVWF FSR1L
15A4  3001     MOVLW 0x1
15A5  0087     MOVWF FSR1H
15A6  3F40     MOVIW 0[FSR1]
15A7  0084     MOVWF FSR0L
15A8  0185     CLRF FSR0H
15A9  0A81     INCF INDF1, F
15AA  0800     MOVF INDF0, W
15AB  319C     MOVLP 0x1C
15AC  24A8     CALL 0x4A8
15AD  3195     MOVLP 0x15
376:                   return (--I2C_Status.data_length)?I2C_TX:I2C_TX_EMPTY;
15AE  3001     MOVLW 0x1
15AF  0023     MOVLB 0x3
15B0  02E0     SUBWF 0x1E0, F
15B1  3000     MOVLW 0x0
15B2  3BE1     SUBWFB 0x1E1, F
15B3  0860     MOVF 0x1E0, W
15B4  0461     IORWF 0x1E1, W
15B5  1D03     BTFSS STATUS, 0x2
15B6  2DB8     GOTO 0x5B8
15B7  2DB9     GOTO 0x5B9
15B8  2DBB     GOTO 0x5BB
15B9  3006     MOVLW 0x6
15BA  2DBC     GOTO 0x5BC
15BB  3003     MOVLW 0x3
377:               }
378:           }
15BC  0008     RETURN
379:           
380:           static i2c_fsm_states_t I2C_DO_RX(void)
381:           {
382:               *I2C_Status.data_ptr++ = I2C_MasterGetRxData();
13A0  319C     MOVLP 0x1C
13A1  2487     CALL 0x487
13A2  3193     MOVLP 0x13
13A3  00FA     MOVWF 0x1FA
13A4  0023     MOVLB 0x3
13A5  085F     MOVF 0x1DF, W
13A6  0086     MOVWF FSR1L
13A7  0187     CLRF FSR1H
13A8  087A     MOVF 0x1FA, W
13A9  0081     MOVWF INDF1
13AA  3001     MOVLW 0x1
13AB  00FA     MOVWF 0x1FA
13AC  087A     MOVF 0x1FA, W
13AD  07DF     ADDWF 0x1DF, F
383:               if(--I2C_Status.data_length)
13AE  3001     MOVLW 0x1
13AF  02E0     SUBWF 0x1E0, F
13B0  3000     MOVLW 0x0
13B1  3BE1     SUBWFB 0x1E1, F
13B2  0860     MOVF 0x1E0, W
13B3  0461     IORWF 0x1E1, W
13B4  1903     BTFSC STATUS, 0x2
13B5  2BB7     GOTO 0x3B7
13B6  2BB8     GOTO 0x3B8
13B7  2BBD     GOTO 0x3BD
384:               {
385:                   I2C_MasterSendAck();
13B8  319C     MOVLP 0x1C
13B9  249C     CALL 0x49C
13BA  3193     MOVLP 0x13
386:                   return I2C_RCEN;
13BB  3005     MOVLW 0x5
13BC  2BE5     GOTO 0x3E5
387:               }
388:               else
389:               {
390:                   I2C_Status.bufferFree = true;
13BD  15E4     BSF 0x1E4, 0x3
391:                   switch(I2C_Status.callbackTable[I2C_DATA_COMPLETE](I2C_Status.callbackPayload[I2C_DATA_COMPLETE]))
13BE  2BC7     GOTO 0x3C7
392:                   {
393:                       case I2C_RESTART_WRITE:
394:                       case I2C_RESTART_READ:
395:                           return I2C_DO_RX_NACK_RESTART();
13BF  319C     MOVLP 0x1C
13C0  24D0     CALL 0x4D0
13C1  3193     MOVLP 0x13
13C2  2BE5     GOTO 0x3E5
396:                       default:
397:                       case I2C_CONTINUE:
398:                       case I2C_STOP:
399:                           return I2C_DO_RX_NACK_STOP();
13C3  319C     MOVLP 0x1C
13C4  24CB     CALL 0x4CB
13C5  3193     MOVLP 0x13
13C6  2BE5     GOTO 0x3E5
400:                   }
13C7  0854     MOVF 0x1D4, W
13C8  00FA     MOVWF 0x1FA
13C9  087A     MOVF 0x1FA, W
13CA  00F9     MOVWF 0x1F9
13CB  0849     MOVF 0x1C9, W
13CC  008A     MOVWF PCLATH
13CD  0848     MOVF I2C_Status, W
13CE  000A     CALLW
13CF  3193     MOVLP 0x13
13D0  00FB     MOVWF 0x1FB
13D1  01FC     CLRF 0x1FC
13D2  087C     MOVF 0x1FC, W
13D3  3A00     XORLW 0x0
13D4  1903     BTFSC STATUS, 0x2
13D5  2BD7     GOTO 0x3D7
13D6  2BC3     GOTO 0x3C3
13D7  087B     MOVF 0x1FB, W
13D8  3A01     XORLW 0x1
13D9  1903     BTFSC STATUS, 0x2
13DA  2BC3     GOTO 0x3C3
13DB  3A03     XORLW 0x3
13DC  1903     BTFSC STATUS, 0x2
13DD  2BBF     GOTO 0x3BF
13DE  3A01     XORLW 0x1
13DF  1903     BTFSC STATUS, 0x2
13E0  2BBF     GOTO 0x3BF
13E1  3A07     XORLW 0x7
13E2  1903     BTFSC STATUS, 0x2
13E3  2BC3     GOTO 0x3C3
13E4  2BC3     GOTO 0x3C3
401:               }
402:           }
13E5  0008     RETURN
403:           
404:           static i2c_fsm_states_t I2C_DO_RCEN(void)
405:           {
406:               I2C_Status.addressNackCheck = 0;
1CF2  0023     MOVLB 0x3
1CF3  1064     BCF 0x1E4, 0x0
407:               I2C_MasterStartRx();
1CF4  319C     MOVLP 0x1C
1CF5  2484     CALL 0x484
1CF6  319C     MOVLP 0x1C
408:               return I2C_RX;
1CF7  3004     MOVLW 0x4
409:           }
1CF8  0008     RETURN
410:           
411:           static i2c_fsm_states_t I2C_DO_TX_EMPTY(void)
412:           {
413:               I2C_Status.bufferFree = true;
1259  0023     MOVLB 0x3
125A  15E4     BSF 0x1E4, 0x3
414:               switch(I2C_Status.callbackTable[I2C_DATA_COMPLETE](I2C_Status.callbackPayload[I2C_DATA_COMPLETE]))
125B  2A69     GOTO 0x269
415:               {
416:                   case I2C_RESTART_READ:
417:                   case I2C_RESTART_WRITE:
418:                       return I2C_DO_SEND_RESTART();
125C  319C     MOVLP 0x1C
125D  24BC     CALL 0x4BC
125E  3192     MOVLP 0x12
125F  2A87     GOTO 0x287
419:                   case I2C_CONTINUE:
420:                       I2C_MasterSetIrq();
1260  319C     MOVLP 0x1C
1261  248A     CALL 0x48A
1262  3192     MOVLP 0x12
421:                       return I2C_TX;
1263  3003     MOVLW 0x3
1264  2A87     GOTO 0x287
422:                   default:
423:                   case I2C_STOP:
424:                       return I2C_DO_SEND_STOP();
1265  319C     MOVLP 0x1C
1266  24C1     CALL 0x4C1
1267  3192     MOVLP 0x12
1268  2A87     GOTO 0x287
425:               }
1269  0854     MOVF 0x1D4, W
126A  00FA     MOVWF 0x1FA
126B  087A     MOVF 0x1FA, W
126C  00F9     MOVWF 0x1F9
126D  0849     MOVF 0x1C9, W
126E  008A     MOVWF PCLATH
126F  0848     MOVF I2C_Status, W
1270  000A     CALLW
1271  3192     MOVLP 0x12
1272  00FB     MOVWF 0x1FB
1273  01FC     CLRF 0x1FC
1274  087C     MOVF 0x1FC, W
1275  3A00     XORLW 0x0
1276  1903     BTFSC STATUS, 0x2
1277  2A79     GOTO 0x279
1278  2A65     GOTO 0x265
1279  087B     MOVF 0x1FB, W
127A  3A01     XORLW 0x1
127B  1903     BTFSC STATUS, 0x2
127C  2A65     GOTO 0x265
127D  3A03     XORLW 0x3
127E  1903     BTFSC STATUS, 0x2
127F  2A5C     GOTO 0x25C
1280  3A01     XORLW 0x1
1281  1903     BTFSC STATUS, 0x2
1282  2A5C     GOTO 0x25C
1283  3A07     XORLW 0x7
1284  1903     BTFSC STATUS, 0x2
1285  2A60     GOTO 0x260
1286  2A65     GOTO 0x265
426:           }
1287  0008     RETURN
427:           
428:           static i2c_fsm_states_t I2C_DO_RX_EMPTY(void)
429:           {
430:               I2C_Status.bufferFree = true;
431:               switch(I2C_Status.callbackTable[I2C_DATA_COMPLETE](I2C_Status.callbackPayload[I2C_DATA_COMPLETE]))
432:               {
433:                   case I2C_RESTART_WRITE:
434:                       I2C_MasterEnableRestart();
435:                       return I2C_SEND_RESTART_WRITE;
436:                   case I2C_RESTART_READ:
437:                       I2C_MasterEnableRestart();
438:                       return I2C_SEND_RESTART_READ;
439:                   case I2C_CONTINUE:
440:                       return I2C_RX;
441:                   default:
442:                   case I2C_STOP:
443:                       if(I2C_Status.state != I2C_SEND_RESTART_READ)
444:                       {
445:                           I2C_MasterDisableRestart();
446:                       }
447:                       return I2C_RESET;
448:               }
449:           }
450:           
451:           static i2c_fsm_states_t I2C_DO_SEND_RESTART_READ(void)
452:           {
453:               I2C_MasterEnableRestart();
1CB2  319C     MOVLP 0x1C
1CB3  247E     CALL 0x47E
1CB4  319C     MOVLP 0x1C
454:               return I2C_SEND_ADR_READ;
1CB5  3001     MOVLW 0x1
455:           }
1CB6  0008     RETURN
456:           
457:           static i2c_fsm_states_t I2C_DO_SEND_RESTART_WRITE(void)
458:           {
459:               I2C_MasterEnableRestart();
1CB7  319C     MOVLP 0x1C
1CB8  247E     CALL 0x47E
1CB9  319C     MOVLP 0x1C
460:               return I2C_SEND_ADR_WRITE;
1CBA  3002     MOVLW 0x2
461:           }
1CBB  0008     RETURN
462:           
463:           
464:           static i2c_fsm_states_t I2C_DO_SEND_RESTART(void)
465:           {
466:               I2C_MasterEnableRestart();
1CBC  319C     MOVLP 0x1C
1CBD  247E     CALL 0x47E
1CBE  319C     MOVLP 0x1C
467:               return I2C_SEND_ADR_READ;
1CBF  3001     MOVLW 0x1
468:           }
1CC0  0008     RETURN
469:           
470:           static i2c_fsm_states_t I2C_DO_SEND_STOP(void)
471:           {
472:               I2C_MasterStop();
1CC1  319C     MOVLP 0x1C
1CC2  2481     CALL 0x481
1CC3  319C     MOVLP 0x1C
473:               return I2C_IDLE;
1CC4  3000     MOVLW 0x0
474:           }
1CC5  0008     RETURN
475:           
476:           static i2c_fsm_states_t I2C_DO_RX_ACK(void)
477:           {
478:               I2C_MasterSendAck();
1CC6  319C     MOVLP 0x1C
1CC7  249C     CALL 0x49C
1CC8  319C     MOVLP 0x1C
479:               return I2C_RCEN;
1CC9  3005     MOVLW 0x5
480:           }
1CCA  0008     RETURN
481:           
482:           
483:           static i2c_fsm_states_t I2C_DO_RX_NACK_STOP(void)
484:           {
485:               I2C_MasterSendNack();
1CCB  319C     MOVLP 0x1C
1CCC  2498     CALL 0x498
1CCD  319C     MOVLP 0x1C
486:               return I2C_SEND_STOP;
1CCE  300A     MOVLW 0xA
487:           }
1CCF  0008     RETURN
488:           
489:           static i2c_fsm_states_t I2C_DO_RX_NACK_RESTART(void)
490:           {
491:               I2C_MasterSendNack();
1CD0  319C     MOVLP 0x1C
1CD1  2498     CALL 0x498
1CD2  319C     MOVLP 0x1C
492:               return I2C_SEND_RESTART;
1CD3  3009     MOVLW 0x9
493:           }
1CD4  0008     RETURN
494:           
495:           static i2c_fsm_states_t I2C_DO_RESET(void)
496:           {
497:               I2C_Status.busy = false;
1CD5  0023     MOVLB 0x3
1CD6  10E4     BCF 0x1E4, 0x1
498:               I2C_Status.error = I2C_NOERR;
1CD7  01E3     CLRF 0x1E3
499:               return I2C_RESET;
1CD8  300E     MOVLW 0xE
500:           }
1CD9  0008     RETURN
501:           static i2c_fsm_states_t I2C_DO_ADDRESS_NACK(void)
502:           {
503:               I2C_Status.addressNackCheck = 0;
11D1  0023     MOVLB 0x3
11D2  1064     BCF 0x1E4, 0x0
504:               I2C_Status.error = I2C_FAIL;
11D3  3002     MOVLW 0x2
11D4  00FA     MOVWF 0x1FA
11D5  087A     MOVF 0x1FA, W
11D6  00E3     MOVWF 0x1E3
505:               switch(I2C_Status.callbackTable[I2C_ADDR_NACK](I2C_Status.callbackPayload[I2C_ADDR_NACK]))
11D7  29E0     GOTO 0x1E0
506:               {
507:                   case I2C_RESTART_READ:
508:                   case I2C_RESTART_WRITE:
509:                       return I2C_DO_SEND_RESTART();
11D8  319C     MOVLP 0x1C
11D9  24BC     CALL 0x4BC
11DA  3191     MOVLP 0x11
11DB  29FD     GOTO 0x1FD
510:                   default:
511:                       return I2C_DO_SEND_STOP();
11DC  319C     MOVLP 0x1C
11DD  24C1     CALL 0x4C1
11DE  3191     MOVLP 0x11
11DF  29FD     GOTO 0x1FD
512:               }
11E0  0856     MOVF 0x1D6, W
11E1  00FA     MOVWF 0x1FA
11E2  087A     MOVF 0x1FA, W
11E3  00F9     MOVWF 0x1F9
11E4  3004     MOVLW 0x4
11E5  3EC8     ADDLW 0xC8
11E6  0086     MOVWF FSR1L
11E7  3001     MOVLW 0x1
11E8  0087     MOVWF FSR1H
11E9  3F41     MOVIW 1[FSR1]
11EA  008A     MOVWF PCLATH
11EB  3F40     MOVIW 0[FSR1]
11EC  000A     CALLW
11ED  3191     MOVLP 0x11
11EE  00FB     MOVWF 0x1FB
11EF  01FC     CLRF 0x1FC
11F0  087C     MOVF 0x1FC, W
11F1  3A00     XORLW 0x0
11F2  1903     BTFSC STATUS, 0x2
11F3  29F5     GOTO 0x1F5
11F4  29DC     GOTO 0x1DC
11F5  087B     MOVF 0x1FB, W
11F6  3A02     XORLW 0x2
11F7  1903     BTFSC STATUS, 0x2
11F8  29D8     GOTO 0x1D8
11F9  3A01     XORLW 0x1
11FA  1903     BTFSC STATUS, 0x2
11FB  29D8     GOTO 0x1D8
11FC  29DC     GOTO 0x1DC
513:           }
11FD  0008     RETURN
514:           
515:           void I2C_BusCollisionIsr(void)
516:           {
517:               I2C_MasterClearBusCollision();
518:               I2C_Status.state = I2C_RESET;
519:           }
520:           
521:           i2c_operations_t I2C_CallbackReturnStop(void *funPtr)
522:           {
523:               return I2C_STOP;
1C7C  3001     MOVLW 0x1
524:           }
1C7D  0008     RETURN
525:           
526:           i2c_operations_t I2C_CallbackReturnReset(void *funPtr)
527:           {
528:               return I2C_RESET_LINK;
0002  3005     MOVLW 0x5
529:           }
0003  0008     RETURN
530:           
531:           i2c_operations_t I2C_CallbackRestartWrite(void *funPtr)
532:           {
533:               return I2C_RESTART_WRITE;
534:           }
535:           
536:           i2c_operations_t I2C_CallbackRestartRead(void *funPtr)
537:           {
538:               return I2C_RESTART_READ;
539:           }
540:           
541:           
542:           
543:           /* I2C Register Level interfaces */
544:           static inline bool I2C_MasterOpen(void)
545:           {
546:               if(!SSPCON1bits.SSPEN)
547:               {
548:                   SSPSTAT = 0xC0;
549:                   SSPCON1 = 0x08;
550:                   SSPCON2 = 0x00;
551:                   SSPADD = 0x4F;
552:                   SSPCON1bits.SSPEN = 1;
553:                   return true;
554:               }
555:               return false;
556:           }
557:           
558:           static inline void I2C_MasterClose(void)
559:           {
560:               //Disable I2C
561:               SSPCON1bits.SSPEN = 0;
562:           }
563:           
564:           static inline uint8_t I2C_MasterGetRxData(void)
565:           {
566:               return SSPBUF;
1C87  0024     MOVLB 0x4
1C88  0811     MOVF SSPBUF, W
567:           }
1C89  0008     RETURN
568:           
569:           static inline void I2C_MasterSendTxData(uint8_t data)
1CA8  00F0     MOVWF 0x270
570:           {
571:               SSPBUF  = data;
1CA9  0870     MOVF 0x270, W
1CAA  0024     MOVLB 0x4
1CAB  0091     MOVWF SSPBUF
572:           }
1CAC  0008     RETURN
573:           
574:           static inline void I2C_MasterEnableRestart(void)
575:           {
576:               SSPCON2bits.RSEN = 1;
1C7E  0024     MOVLB 0x4
1C7F  1496     BSF SSPCON2, 0x1
577:           }
1C80  0008     RETURN
578:           
579:           static inline void I2C_MasterDisableRestart(void)
580:           {
581:               SSPCON2bits.RSEN = 0;
582:           }
583:           
584:           static inline void I2C_MasterStartRx(void)
585:           {
586:               SSPCON2bits.RCEN = 1;
1C84  0024     MOVLB 0x4
1C85  1596     BSF SSPCON2, 0x3
587:           }
1C86  0008     RETURN
588:           
589:           static inline void I2C_MasterStart(void)
590:           {
591:               SSPCON2bits.SEN = 1;
592:           }
593:           
594:           static inline void I2C_MasterStop(void)
595:           {
596:               SSPCON2bits.PEN = 1;
1C81  0024     MOVLB 0x4
1C82  1516     BSF SSPCON2, 0x2
597:           }
1C83  0008     RETURN
598:           
599:           static inline bool I2C_MasterIsNack(void)
600:           {
601:               return SSPCON2bits.ACKSTAT;
1CDA  0024     MOVLB 0x4
1CDB  0E16     SWAPF SSPCON2, W
1CDC  0C89     RRF WREG, F
1CDD  0C89     RRF WREG, F
1CDE  3901     ANDLW 0x1
602:           }
1CDF  0008     RETURN
603:           
604:           static inline void I2C_MasterSendAck(void)
605:           {
606:               SSPCON2bits.ACKDT = 0;
1C9C  0024     MOVLB 0x4
1C9D  1296     BCF SSPCON2, 0x5
607:               SSPCON2bits.ACKEN = 1;
1C9E  1616     BSF SSPCON2, 0x4
608:           }
1C9F  0008     RETURN
609:           
610:           static inline void I2C_MasterSendNack(void)
611:           {
612:               SSPCON2bits.ACKDT = 1;
1C98  0024     MOVLB 0x4
1C99  1696     BSF SSPCON2, 0x5
613:               SSPCON2bits.ACKEN = 1;
1C9A  1616     BSF SSPCON2, 0x4
614:           }
1C9B  0008     RETURN
615:           
616:           static inline void I2C_MasterClearBusCollision(void)
617:           {
618:               PIR2bits.BCLIF = 0;
619:           }
620:           
621:           
622:           static inline bool I2C_MasterIsRxBufFull(void)
623:           {
624:               return SSPSTATbits.BF;
625:           }
626:           
627:           static inline void I2C_MasterEnableIrq(void)
628:           {
629:               PIE1bits.SSPIE = 1;
630:           }
631:           
632:           static inline bool I2C_MasterIsIrqEnabled(void)
633:           {
634:               return PIE1bits.SSPIE;
635:           }
636:           
637:           static inline void I2C_MasterDisableIrq(void)
638:           {
639:               PIE1bits.SSPIE = 0;
640:           }
641:           
642:           static inline void I2C_MasterClearIrq(void)
643:           {
644:               PIR1bits.SSPIF = 0;
1C8D  0020     MOVLB 0x0
1C8E  1191     BCF PIR1, 0x3
645:           }
1C8F  0008     RETURN
646:           
647:           static inline void I2C_MasterSetIrq(void)
648:           {
649:               PIR1bits.SSPIF = 1;
1C8A  0020     MOVLB 0x0
1C8B  1591     BSF PIR1, 0x3
650:           }
1C8C  0008     RETURN
651:           
652:           static inline void I2C_MasterWaitForEvent(void)
653:           {
654:               while(1)
655:               {
656:                   if(PIR1bits.SSPIF)
657:                   {    
658:                       break;
659:                   }
660:               }
661:           }
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/examples/i2c_master_example.c  ---
1:             /**
2:               I2C Generated Example Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 i2c_master_example.c
9:             
10:              @Summary
11:                This is the generated driver examples implementation file for the I2C driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for I2C.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  1.0.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above or later
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "i2c_master_example.h"
48:            
49:            
50:            typedef struct
51:            {
52:                size_t len;
53:                uint8_t *data;
54:            }i2c_buffer_t;
55:            
56:            static i2c_operations_t rd1RegCompleteHandler(void *ptr);
57:            static i2c_operations_t rd2RegCompleteHandler(void *ptr);
58:            static i2c_operations_t wr1RegCompleteHandler(void *ptr);
59:            static i2c_operations_t wr2RegCompleteHandler(void *ptr);
60:            static i2c_operations_t rdBlkRegCompleteHandler(void *ptr);
61:            
62:            
63:            uint8_t I2C_Read1ByteRegister(i2c_address_t address, uint8_t reg)
64:            {
65:                uint8_t returnValue = 0x00;
66:                
67:                while(!I2C_Open(address)); // sit here until we get the bus..
68:                I2C_SetDataCompleteCallback(rd1RegCompleteHandler,&returnValue);
69:                I2C_SetBuffer(&reg,1);
70:                I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
71:                I2C_MasterWrite();
72:                while(I2C_BUSY == I2C_Close()); // sit here until finished.
73:                
74:                return returnValue;
75:            }
76:            
77:            uint16_t I2C_Read2ByteRegister(i2c_address_t address, uint8_t reg)
78:            {
79:                uint16_t returnValue =0x00; // returnValue is little endian
80:            
81:                while(!I2C_Open(address)); // sit here until we get the bus..
82:                I2C_SetDataCompleteCallback(rd2RegCompleteHandler,&returnValue);
83:                I2C_SetBuffer(&reg,1);
84:                I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
85:                I2C_MasterWrite();
86:                while(I2C_BUSY == I2C_Close()); // sit here until finished.
87:              
88:                return (returnValue << 8 | returnValue >> 8);
89:            }
90:            
91:            void I2C_Write1ByteRegister(i2c_address_t address, uint8_t reg, uint8_t data)
92:            {
93:                while(!I2C_Open(address)); // sit here until we get the bus..
94:                I2C_SetDataCompleteCallback(wr1RegCompleteHandler,&data);
95:                I2C_SetBuffer(&reg,1);
96:                I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
97:                I2C_MasterWrite();
98:                while(I2C_BUSY == I2C_Close()); // sit here until finished.
99:            }
100:           
101:           void I2C_Write2ByteRegister(i2c_address_t address, uint8_t reg, uint16_t data)
102:           {
103:               while(!I2C_Open(address)); // sit here until we get the bus..
104:               I2C_SetDataCompleteCallback(wr2RegCompleteHandler,&data);
105:               I2C_SetBuffer(&reg,1);
106:               I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
107:               I2C_MasterWrite();
108:               while(I2C_BUSY == I2C_Close()); // sit here until finished.
109:           }
110:           
111:           void I2C_WriteNBytes(i2c_address_t address, uint8_t* data, size_t len)
112:           {
113:               while(!I2C_Open(address)); // sit here until we get the bus..
114:               I2C_SetBuffer(data,len);
115:               I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
116:               I2C_MasterWrite();
117:               while(I2C_BUSY == I2C_Close()); // sit here until finished.
118:           }
119:           
120:           void I2C_ReadNBytes(i2c_address_t address, uint8_t *data, size_t len)
121:           {
122:               while(!I2C_Open(address)); // sit here until we get the bus..
123:               I2C_SetBuffer(data,len);
124:               I2C_MasterRead();
125:               while(I2C_BUSY == I2C_Close()); // sit here until finished.
126:           }
127:           
128:           void I2C_ReadDataBlock(i2c_address_t address, uint8_t reg, uint8_t *data, size_t len)
129:           {
130:               i2c_buffer_t bufferBlock; // result is little endian
131:               bufferBlock.data = data;
132:               bufferBlock.len = len;
133:           
134:               while(!I2C_Open(address)); // sit here until we get the bus..
135:               I2C_SetDataCompleteCallback(rdBlkRegCompleteHandler,&bufferBlock);
136:               I2C_SetBuffer(&reg,1);
137:               I2C_SetAddressNackCallback(NULL,NULL); //NACK polling?
138:               I2C_MasterWrite();
139:               while(I2C_BUSY == I2C_Close()); // sit here until finished.
140:           }
141:           
142:           static i2c_operations_t rd1RegCompleteHandler(void *ptr)
143:           {
144:               I2C_SetBuffer(ptr,1);
1E1F  3001     MOVLW 0x1
1E20  00F0     MOVWF __pcstackCOMMON
1E21  3000     MOVLW 0x0
1E22  00F1     MOVWF 0x71
1E23  0879     MOVF ptr, W
1E24  319D     MOVLP 0x1D
1E25  25FE     CALL 0x5FE
1E26  319E     MOVLP 0x1E
145:               I2C_SetDataCompleteCallback(NULL,NULL);
1E27  3000     MOVLW 0x0
1E28  00F5     MOVWF cb
1E29  00F6     MOVWF 0x76
1E2A  01F7     CLRF ptr
1E2B  319D     MOVLP 0x1D
1E2C  257C     CALL 0x57C
1E2D  319E     MOVLP 0x1E
146:               return I2C_RESTART_READ;
1E2E  3002     MOVLW 0x2
147:           }
1E2F  0008     RETURN
148:           
149:           static i2c_operations_t rd2RegCompleteHandler(void *ptr)
150:           {
151:               I2C_SetBuffer(ptr,2);
1E30  3002     MOVLW 0x2
1E31  00F0     MOVWF __pcstackCOMMON
1E32  3000     MOVLW 0x0
1E33  00F1     MOVWF 0x71
1E34  0879     MOVF ptr, W
1E35  319D     MOVLP 0x1D
1E36  25FE     CALL 0x5FE
1E37  319E     MOVLP 0x1E
152:               I2C_SetDataCompleteCallback(NULL,NULL);
1E38  3000     MOVLW 0x0
1E39  00F5     MOVWF cb
1E3A  00F6     MOVWF 0x76
1E3B  01F7     CLRF ptr
1E3C  319D     MOVLP 0x1D
1E3D  257C     CALL 0x57C
1E3E  319E     MOVLP 0x1E
153:               return I2C_RESTART_READ;
1E3F  3002     MOVLW 0x2
154:           }
1E40  0008     RETURN
155:           
156:           static i2c_operations_t wr1RegCompleteHandler(void *ptr)
157:           {
158:               I2C_SetBuffer(ptr,1);
1E41  3001     MOVLW 0x1
1E42  00F0     MOVWF __pcstackCOMMON
1E43  3000     MOVLW 0x0
1E44  00F1     MOVWF 0x71
1E45  0879     MOVF ptr, W
1E46  319D     MOVLP 0x1D
1E47  25FE     CALL 0x5FE
1E48  319E     MOVLP 0x1E
159:               I2C_SetDataCompleteCallback(NULL,NULL);
1E49  3000     MOVLW 0x0
1E4A  00F5     MOVWF cb
1E4B  00F6     MOVWF 0x76
1E4C  01F7     CLRF ptr
1E4D  319D     MOVLP 0x1D
1E4E  257C     CALL 0x57C
1E4F  319E     MOVLP 0x1E
160:               return I2C_CONTINUE;
1E50  3004     MOVLW 0x4
161:           }
1E51  0008     RETURN
162:           
163:           static i2c_operations_t wr2RegCompleteHandler(void *ptr)
164:           {
165:               I2C_SetBuffer(ptr,2);
1E0E  3002     MOVLW 0x2
1E0F  00F0     MOVWF __pcstackCOMMON
1E10  3000     MOVLW 0x0
1E11  00F1     MOVWF 0x71
1E12  0879     MOVF ptr, W
1E13  319D     MOVLP 0x1D
1E14  25FE     CALL 0x5FE
1E15  319E     MOVLP 0x1E
166:               I2C_SetDataCompleteCallback(NULL,NULL);
1E16  3000     MOVLW 0x0
1E17  00F5     MOVWF cb
1E18  00F6     MOVWF 0x76
1E19  01F7     CLRF ptr
1E1A  319D     MOVLP 0x1D
1E1B  257C     CALL 0x57C
1E1C  319E     MOVLP 0x1E
167:               return I2C_CONTINUE;
1E1D  3004     MOVLW 0x4
168:           }
1E1E  0008     RETURN
169:           
170:           static i2c_operations_t rdBlkRegCompleteHandler(void *ptr)
171:           {
172:               I2C_SetBuffer(((i2c_buffer_t *)ptr)->data,((i2c_buffer_t*)ptr)->len);
1EBB  0879     MOVF ptr, W
1EBC  0086     MOVWF FSR1
1EBD  0187     CLRF FSR1H
1EBE  3F40     MOVIW 0[FSR1]
1EBF  00F0     MOVWF __pcstackCOMMON
1EC0  3F41     MOVIW 1[FSR1]
1EC1  00F1     MOVWF 0x71
1EC2  0879     MOVF ptr, W
1EC3  3E02     ADDLW 0x2
1EC4  0086     MOVWF FSR1
1EC5  0187     CLRF FSR1H
1EC6  0801     MOVF INDF1, W
1EC7  319D     MOVLP 0x1D
1EC8  25FE     CALL 0x5FE
1EC9  319E     MOVLP 0x1E
173:               I2C_SetDataCompleteCallback(NULL,NULL);
1ECA  3000     MOVLW 0x0
1ECB  00F5     MOVWF cb
1ECC  00F6     MOVWF 0x76
1ECD  01F7     CLRF ptr
1ECE  319D     MOVLP 0x1D
1ECF  257C     CALL 0x57C
1ED0  319E     MOVLP 0x1E
174:               return I2C_RESTART_READ;
1ED1  3002     MOVLW 0x2
175:           }
1ED2  0008     RETURN
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/eusart.c  ------------------------
1:             /**
2:               EUSART Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  2.1.1
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB 	          :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include "eusart.h"
51:            
52:            /**
53:              Section: Macro Declarations
54:            */
55:            
56:            #define EUSART_TX_BUFFER_SIZE 8
57:            #define EUSART_RX_BUFFER_SIZE 8
58:            
59:            /**
60:              Section: Global Variables
61:            */
62:            volatile uint8_t eusartTxHead = 0;
63:            volatile uint8_t eusartTxTail = 0;
64:            volatile uint8_t eusartTxBuffer[EUSART_TX_BUFFER_SIZE];
65:            volatile uint8_t eusartTxBufferRemaining;
66:            
67:            volatile uint8_t eusartRxHead = 0;
68:            volatile uint8_t eusartRxTail = 0;
69:            volatile uint8_t eusartRxBuffer[EUSART_RX_BUFFER_SIZE];
70:            volatile eusart_status_t eusartRxStatusBuffer[EUSART_RX_BUFFER_SIZE];
71:            volatile uint8_t eusartRxCount;
72:            volatile eusart_status_t eusartRxLastError;
73:            
74:            /**
75:              Section: EUSART APIs
76:            */
77:            void (*EUSART_TxDefaultInterruptHandler)(void);
78:            void (*EUSART_RxDefaultInterruptHandler)(void);
79:            
80:            void (*EUSART_FramingErrorHandler)(void);
81:            void (*EUSART_OverrunErrorHandler)(void);
82:            void (*EUSART_ErrorHandler)(void);
83:            
84:            void EUSART_DefaultFramingErrorHandler(void);
85:            void EUSART_DefaultOverrunErrorHandler(void);
86:            void EUSART_DefaultErrorHandler(void);
87:            
88:            void EUSART_Initialize(void)
89:            {
90:                // disable interrupts before changing states
91:                PIE1bits.RCIE = 0;
142E  0021     MOVLB 0x1
142F  1291     BCF PIE1, 0x5
92:                EUSART_SetRxInterruptHandler(EUSART_Receive_ISR);
1430  301D     MOVLW 0x1D
1431  0020     MOVLB 0x0
1432  00A3     MOVWF data
1433  3013     MOVLW 0x13
1434  00A4     MOVWF Data
1435  319D     MOVLP 0x1D
1436  2534     CALL 0x534
1437  3194     MOVLP 0x14
93:                PIE1bits.TXIE = 0;
1438  0021     MOVLB 0x1
1439  1211     BCF PIE1, 0x4
94:                EUSART_SetTxInterruptHandler(EUSART_Transmit_ISR);
143A  3052     MOVLW 0x52
143B  0020     MOVLB 0x0
143C  00A3     MOVWF data
143D  3010     MOVLW 0x10
143E  00A4     MOVWF Data
143F  319D     MOVLP 0x1D
1440  253D     CALL 0x53D
1441  3194     MOVLP 0x14
95:                // Set the EUSART module to the options selected in the user interface.
96:            
97:                // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
98:                BAUDCON = 0x08;
1442  3008     MOVLW 0x8
1443  0023     MOVLB 0x3
1444  009F     MOVWF BAUDCON
99:            
100:               // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
101:               RCSTA = 0x90;
1445  3090     MOVLW 0x90
1446  009D     MOVWF RCSTA
102:           
103:               // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
104:               TXSTA = 0x24;
1447  3024     MOVLW 0x24
1448  009E     MOVWF TXSTA
105:           
106:               // SPBRGL 64; 
107:               SPBRGL = 0x40;
1449  3040     MOVLW 0x40
144A  009B     MOVWF SP1BRG
108:           
109:               // SPBRGH 3; 
110:               SPBRGH = 0x03;
144B  3003     MOVLW 0x3
144C  009C     MOVWF SP1BRGH
111:           
112:           
113:               EUSART_SetFramingErrorHandler(EUSART_DefaultFramingErrorHandler);
144D  307A     MOVLW 0x7A
144E  0020     MOVLB 0x0
144F  00A3     MOVWF data
1450  301C     MOVLW 0x1C
1451  00A4     MOVWF Data
1452  319D     MOVLP 0x1D
1453  2522     CALL 0x522
1454  3194     MOVLP 0x14
114:               EUSART_SetOverrunErrorHandler(EUSART_DefaultOverrunErrorHandler);
1455  3094     MOVLW 0x94
1456  0020     MOVLB 0x0
1457  00A3     MOVWF data
1458  301C     MOVLW 0x1C
1459  00A4     MOVWF Data
145A  319D     MOVLP 0x1D
145B  252B     CALL 0x52B
145C  3194     MOVLP 0x14
115:               EUSART_SetErrorHandler(EUSART_DefaultErrorHandler);
145D  3090     MOVLW 0x90
145E  0020     MOVLB 0x0
145F  00A3     MOVWF data
1460  301C     MOVLW 0x1C
1461  00A4     MOVWF Data
1462  319D     MOVLP 0x1D
1463  2519     CALL 0x519
1464  3194     MOVLP 0x14
116:           
117:               eusartRxLastError.status = 0;
1465  0022     MOVLB 0x2
1466  01CC     CLRF eusartRxLastError
118:           
119:               // initializing the driver state
120:               eusartTxHead = 0;
1467  01FD     CLRF 0x17D
121:               eusartTxTail = 0;
1468  0021     MOVLB 0x1
1469  01E6     CLRF eusartTxTail
122:               eusartTxBufferRemaining = sizeof(eusartTxBuffer);
146A  3008     MOVLW 0x8
146B  0020     MOVLB 0x0
146C  00A5     MOVWF txData
146D  0825     MOVF txData, W
146E  0021     MOVLB 0x1
146F  00E5     MOVWF eusartTxBufferRemaining
123:           
124:               eusartRxHead = 0;
1470  0020     MOVLB 0x0
1471  01EC     CLRF eusartRxHead
125:               eusartRxTail = 0;
1472  01EB     CLRF eusartRxTail
126:               eusartRxCount = 0;
1473  01EA     CLRF eusartRxCount
127:           
128:               // enable receive interrupt
129:               PIE1bits.RCIE = 1;
1474  0021     MOVLB 0x1
1475  1691     BSF PIE1, 0x5
130:           }
1476  0008     RETURN
131:           
132:           bool EUSART_is_tx_ready(void)
133:           {
134:               return (eusartTxBufferRemaining ? true : false);
135:           }
136:           
137:           bool EUSART_is_rx_ready(void)
138:           {
139:               return (eusartRxCount ? true : false);
140:           }
141:           
142:           bool EUSART_is_tx_done(void)
143:           {
144:               return TXSTAbits.TRMT;
145:           }
146:           
147:           eusart_status_t EUSART_get_last_status(void){
148:               return eusartRxLastError;
149:           }
150:           
151:           uint8_t EUSART_Read(void)
152:           {
153:               uint8_t readValue  = 0;
154:               
155:               while(0 == eusartRxCount)
12B7  0020     MOVLB 0x0
12B8  086A     MOVF eusartRxCount, W
12B9  1903     BTFSC STATUS, 0x2
12BA  2ABC     GOTO 0x2BC
12BB  2ABD     GOTO 0x2BD
12BC  2AB7     GOTO 0x2B7
156:               {
157:               }
158:           
159:               eusartRxLastError = eusartRxStatusBuffer[eusartRxTail];
12BD  086B     MOVF eusartRxTail, W
12BE  3E20     ADDLW 0x20
12BF  0086     MOVWF FSR1
12C0  3001     MOVLW 0x1
12C1  0087     MOVWF FSR1H
12C2  0801     MOVF INDF1, W
12C3  00A3     MOVWF data
12C4  0823     MOVF data, W
12C5  0022     MOVLB 0x2
12C6  00CC     MOVWF eusartRxLastError
160:           
161:               readValue = eusartRxBuffer[eusartRxTail++];
12C7  0020     MOVLB 0x0
12C8  086B     MOVF eusartRxTail, W
12C9  3E28     ADDLW 0x28
12CA  0086     MOVWF FSR1
12CB  3001     MOVLW 0x1
12CC  0087     MOVWF FSR1H
12CD  0801     MOVF INDF1, W
12CE  00A3     MOVWF data
12CF  0823     MOVF data, W
12D0  00A4     MOVWF Data
12D1  3001     MOVLW 0x1
12D2  00A3     MOVWF data
12D3  0823     MOVF data, W
12D4  07EB     ADDWF eusartRxTail, F
162:               if(sizeof(eusartRxBuffer) <= eusartRxTail)
12D5  3008     MOVLW 0x8
12D6  026B     SUBWF eusartRxTail, W
12D7  1C03     BTFSS STATUS, 0x0
12D8  2ADA     GOTO 0x2DA
12D9  2ADB     GOTO 0x2DB
12DA  2ADC     GOTO 0x2DC
163:               {
164:                   eusartRxTail = 0;
12DB  01EB     CLRF eusartRxTail
165:               }
166:               PIE1bits.RCIE = 0;
12DC  0021     MOVLB 0x1
12DD  1291     BCF PIE1, 0x5
167:               eusartRxCount--;
12DE  3001     MOVLW 0x1
12DF  0020     MOVLB 0x0
12E0  02EA     SUBWF eusartRxCount, F
168:               PIE1bits.RCIE = 1;
12E1  0021     MOVLB 0x1
12E2  1691     BSF PIE1, 0x5
169:           
170:               return readValue;
12E3  0020     MOVLB 0x0
12E4  0824     MOVF Data, W
171:           }
12E5  0008     RETURN
172:           
173:           void EUSART_Write(uint8_t txData)
11FE  0020     MOVLB 0x0
11FF  00A4     MOVWF Data
174:           {
175:               while(0 == eusartTxBufferRemaining)
1200  0021     MOVLB 0x1
1201  0865     MOVF eusartTxBufferRemaining, W
1202  1903     BTFSC STATUS, 0x2
1203  2A05     GOTO 0x205
1204  2A06     GOTO 0x206
1205  2A00     GOTO 0x200
176:               {
177:               }
178:           
179:               if(0 == PIE1bits.TXIE)
1206  1A11     BTFSC PIE1, 0x4
1207  2A09     GOTO 0x209
1208  2A0A     GOTO 0x20A
1209  2A0F     GOTO 0x20F
180:               {
181:                   TXREG = txData;
120A  0020     MOVLB 0x0
120B  0824     MOVF Data, W
120C  0023     MOVLB 0x3
120D  009A     MOVWF TXREG
182:               }
120E  2A28     GOTO 0x228
183:               else
184:               {
185:                   PIE1bits.TXIE = 0;
120F  1211     BCF EEADR, 0x4
186:                   eusartTxBuffer[eusartTxHead++] = txData;
1210  0020     MOVLB 0x0
1211  0824     MOVF Data, W
1212  00A3     MOVWF data
1213  087D     MOVF eusartTxHead, W
1214  3E30     ADDLW 0x30
1215  0086     MOVWF FSR1
1216  3001     MOVLW 0x1
1217  0087     MOVWF FSR1H
1218  0823     MOVF data, W
1219  0081     MOVWF INDF1
121A  3001     MOVLW 0x1
121B  00A3     MOVWF data
121C  0823     MOVF data, W
121D  07FD     ADDWF eusartTxHead, F
187:                   if(sizeof(eusartTxBuffer) <= eusartTxHead)
121E  3008     MOVLW 0x8
121F  027D     SUBWF eusartTxHead, W
1220  1C03     BTFSS STATUS, 0x0
1221  2A23     GOTO 0x223
1222  2A24     GOTO 0x224
1223  2A25     GOTO 0x225
188:                   {
189:                       eusartTxHead = 0;
1224  01FD     CLRF eusartTxHead
190:                   }
191:                   eusartTxBufferRemaining--;
1225  3001     MOVLW 0x1
1226  0021     MOVLB 0x1
1227  02E5     SUBWF eusartTxBufferRemaining, F
192:               }
193:               PIE1bits.TXIE = 1;
1228  0021     MOVLB 0x1
1229  1611     BSF PIE1, 0x4
194:           }
122A  0008     RETURN
195:           
196:           char getch(void)
197:           {
198:               return EUSART_Read();
199:           }
200:           
201:           void putch(char txData)
1CF9  0020     MOVLB 0x0
1CFA  00A5     MOVWF txData
202:           {
203:               EUSART_Write(txData);
1CFB  0825     MOVF txData, W
1CFC  3191     MOVLP 0x11
1CFD  21FE     CALL 0x1FE
1CFE  319C     MOVLP 0x1C
204:           }
1CFF  0008     RETURN
205:           
206:           void EUSART_Transmit_ISR(void)
207:           {
208:           
209:               // add your EUSART interrupt custom code
210:               if(sizeof(eusartTxBuffer) > eusartTxBufferRemaining)
1052  3008     MOVLW 0x8
1053  0021     MOVLB 0x1
1054  0265     SUBWF eusartTxBufferRemaining, W
1055  1803     BTFSC STATUS, 0x0
1056  2858     GOTO 0x58
1057  2859     GOTO 0x59
1058  2872     GOTO 0x72
211:               {
212:                   TXREG = eusartTxBuffer[eusartTxTail++];
1059  0866     MOVF eusartTxTail, W
105A  3E30     ADDLW 0x30
105B  0086     MOVWF FSR1L
105C  3001     MOVLW 0x1
105D  0087     MOVWF FSR1H
105E  0801     MOVF INDF1, W
105F  0023     MOVLB 0x3
1060  009A     MOVWF TXREG
1061  3001     MOVLW 0x1
1062  00F0     MOVWF 0x1F0
1063  0870     MOVF 0x1F0, W
1064  0021     MOVLB 0x1
1065  07E6     ADDWF eusartTxTail, F
213:                   if(sizeof(eusartTxBuffer) <= eusartTxTail)
1066  3008     MOVLW 0x8
1067  0266     SUBWF eusartTxTail, W
1068  1C03     BTFSS STATUS, 0x0
1069  286B     GOTO 0x6B
106A  286C     GOTO 0x6C
106B  286D     GOTO 0x6D
214:                   {
215:                       eusartTxTail = 0;
106C  01E6     CLRF eusartTxTail
216:                   }
217:                   eusartTxBufferRemaining++;
106D  3001     MOVLW 0x1
106E  00F0     MOVWF 0xF0
106F  0870     MOVF 0xF0, W
1070  07E5     ADDWF eusartTxBufferRemaining, F
218:               }
1071  2873     GOTO 0x73
219:               else
220:               {
221:                   PIE1bits.TXIE = 0;
1072  1211     BCF PIE1, 0x4
222:               }
223:           }
1073  0008     RETURN
224:           
225:           void EUSART_Receive_ISR(void)
226:           {
227:               
228:               eusartRxStatusBuffer[eusartRxHead].status = 0;
131D  0020     MOVLB 0x0
131E  086C     MOVF eusartRxHead, W
131F  3E20     ADDLW 0x20
1320  0086     MOVWF FSR1
1321  3001     MOVLW 0x1
1322  0087     MOVWF FSR1H
1323  0181     CLRF INDF1
229:           
230:               if(RCSTAbits.FERR){
1324  0023     MOVLB 0x3
1325  1D1D     BTFSS RCSTA, 0x2
1326  2B28     GOTO 0x328
1327  2B29     GOTO 0x329
1328  2B36     GOTO 0x336
231:                   eusartRxStatusBuffer[eusartRxHead].ferr = 1;
1329  0020     MOVLB 0x0
132A  086C     MOVF eusartRxHead, W
132B  3E20     ADDLW 0x20
132C  0086     MOVWF FSR1
132D  3001     MOVLW 0x1
132E  0087     MOVWF FSR1H
132F  1481     BSF INDF1, 0x1
232:                   EUSART_FramingErrorHandler();
1330  0022     MOVLB 0x2
1331  0843     MOVF 0x143, W
1332  008A     MOVWF PCLATH
1333  0842     MOVF EUSART_FramingErrorHandler, W
1334  000A     CALLW
1335  3193     MOVLP 0x13
233:               }
234:           
235:               if(RCSTAbits.OERR){
1336  0023     MOVLB 0x3
1337  1C9D     BTFSS RCSTA, 0x1
1338  2B3A     GOTO 0x33A
1339  2B3B     GOTO 0x33B
133A  2B48     GOTO 0x348
236:                   eusartRxStatusBuffer[eusartRxHead].oerr = 1;
133B  0020     MOVLB 0x0
133C  086C     MOVF eusartRxHead, W
133D  3E20     ADDLW 0x20
133E  0086     MOVWF FSR1
133F  3001     MOVLW 0x1
1340  0087     MOVWF FSR1H
1341  1501     BSF INDF1, 0x2
237:                   EUSART_OverrunErrorHandler();
1342  0022     MOVLB 0x2
1343  0841     MOVF 0x141, W
1344  008A     MOVWF PCLATH
1345  0840     MOVF EUSART_OverrunErrorHandler, W
1346  000A     CALLW
1347  3193     MOVLP 0x13
238:               }
239:               
240:               if(eusartRxStatusBuffer[eusartRxHead].status){
1348  0020     MOVLB 0x0
1349  086C     MOVF eusartRxHead, W
134A  3E20     ADDLW 0x20
134B  0086     MOVWF FSR1
134C  3001     MOVLW 0x1
134D  0087     MOVWF FSR1H
134E  0801     MOVF INDF1, W
134F  1903     BTFSC STATUS, 0x2
1350  2B52     GOTO 0x352
1351  2B53     GOTO 0x353
1352  2B5A     GOTO 0x35A
241:                   EUSART_ErrorHandler();
1353  0022     MOVLB 0x2
1354  083F     MOVF 0x13F, W
1355  008A     MOVWF PCLATH
1356  083E     MOVF EUSART_ErrorHandler, W
1357  000A     CALLW
1358  3193     MOVLP 0x13
242:               } else {
1359  2B5D     GOTO 0x35D
243:                   EUSART_RxDataHandler();
135A  319F     MOVLP 0x1F
135B  2736     CALL 0x736
135C  3193     MOVLP 0x13
244:               }
245:               
246:               // or set custom function using EUSART_SetRxInterruptHandler()
247:           }
135D  0008     RETURN
248:           
249:           void EUSART_RxDataHandler(void){
250:               // use this default receive interrupt handler code
251:               eusartRxBuffer[eusartRxHead++] = RCREG;
1F36  0023     MOVLB 0x3
1F37  0819     MOVF RCREG, W
1F38  00F0     MOVWF 0x1F0
1F39  0020     MOVLB 0x0
1F3A  086C     MOVF eusartRxHead, W
1F3B  3E28     ADDLW 0x28
1F3C  0086     MOVWF FSR1
1F3D  3001     MOVLW 0x1
1F3E  0087     MOVWF FSR1H
1F3F  0870     MOVF __pcstackCOMMON, W
1F40  0081     MOVWF INDF1
1F41  3001     MOVLW 0x1
1F42  00F0     MOVWF __pcstackCOMMON
1F43  0870     MOVF __pcstackCOMMON, W
1F44  07EC     ADDWF eusartRxHead, F
252:               if(sizeof(eusartRxBuffer) <= eusartRxHead)
1F45  3008     MOVLW 0x8
1F46  026C     SUBWF eusartRxHead, W
1F47  1C03     BTFSS STATUS, 0x0
1F48  2F4A     GOTO 0x74A
1F49  2F4B     GOTO 0x74B
1F4A  2F4C     GOTO 0x74C
253:               {
254:                   eusartRxHead = 0;
1F4B  01EC     CLRF eusartRxHead
255:               }
256:               eusartRxCount++;
1F4C  3001     MOVLW 0x1
1F4D  00F0     MOVWF __pcstackCOMMON
1F4E  0870     MOVF __pcstackCOMMON, W
1F4F  07EA     ADDWF eusartRxCount, F
257:           }
1F50  0008     RETURN
258:           
259:           void EUSART_DefaultFramingErrorHandler(void){}
1C7A  0008     RETURN
260:           
261:           void EUSART_DefaultOverrunErrorHandler(void){
262:               // EUSART error - restart
263:           
264:               RCSTAbits.CREN = 0;
1C94  0023     MOVLB 0x3
1C95  121D     BCF RCSTA, 0x4
265:               RCSTAbits.CREN = 1;
1C96  161D     BSF RCSTA, 0x4
266:           
267:           }
1C97  0008     RETURN
268:           
269:           void EUSART_DefaultErrorHandler(void){
270:               EUSART_RxDataHandler();
1C90  319F     MOVLP 0x1F
1C91  2736     CALL 0x736
1C92  319C     MOVLP 0x1C
271:           }
1C93  0008     RETURN
272:           
273:           void EUSART_SetFramingErrorHandler(void (* interruptHandler)(void)){
274:               EUSART_FramingErrorHandler = interruptHandler;
1D22  0020     MOVLB 0x0
1D23  0824     MOVF Data, W
1D24  0022     MOVLB 0x2
1D25  00C3     MOVWF 0x143
1D26  0020     MOVLB 0x0
1D27  0823     MOVF data, W
1D28  0022     MOVLB 0x2
1D29  00C2     MOVWF EUSART_FramingErrorHandler
275:           }
1D2A  0008     RETURN
276:           
277:           void EUSART_SetOverrunErrorHandler(void (* interruptHandler)(void)){
278:               EUSART_OverrunErrorHandler = interruptHandler;
1D2B  0020     MOVLB 0x0
1D2C  0824     MOVF Data, W
1D2D  0022     MOVLB 0x2
1D2E  00C1     MOVWF 0x141
1D2F  0020     MOVLB 0x0
1D30  0823     MOVF data, W
1D31  0022     MOVLB 0x2
1D32  00C0     MOVWF EUSART_OverrunErrorHandler
279:           }
1D33  0008     RETURN
280:           
281:           void EUSART_SetErrorHandler(void (* interruptHandler)(void)){
282:               EUSART_ErrorHandler = interruptHandler;
1D19  0020     MOVLB 0x0
1D1A  0824     MOVF Data, W
1D1B  0022     MOVLB 0x2
1D1C  00BF     MOVWF 0x13F
1D1D  0020     MOVLB 0x0
1D1E  0823     MOVF data, W
1D1F  0022     MOVLB 0x2
1D20  00BE     MOVWF EUSART_ErrorHandler
283:           }
1D21  0008     RETURN
284:           
285:           void EUSART_SetTxInterruptHandler(void (* interruptHandler)(void)){
286:               EUSART_TxDefaultInterruptHandler = interruptHandler;
1D3D  0020     MOVLB 0x0
1D3E  0824     MOVF Data, W
1D3F  0022     MOVLB 0x2
1D40  00C7     MOVWF 0x147
1D41  0020     MOVLB 0x0
1D42  0823     MOVF data, W
1D43  0022     MOVLB 0x2
1D44  00C6     MOVWF EUSART_TxDefaultInterruptHandler
287:           }
1D45  0008     RETURN
288:           
289:           void EUSART_SetRxInterruptHandler(void (* interruptHandler)(void)){
290:               EUSART_RxDefaultInterruptHandler = interruptHandler;
1D34  0020     MOVLB 0x0
1D35  0824     MOVF Data, W
1D36  0022     MOVLB 0x2
1D37  00C5     MOVWF 0x145
1D38  0020     MOVLB 0x0
1D39  0823     MOVF data, W
1D3A  0022     MOVLB 0x2
1D3B  00C4     MOVWF EUSART_RxDefaultInterruptHandler
291:           }
1D3C  0008     RETURN
292:           /**
293:             End of File
294:           */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/mcc_generated_files/adc.c  ---------------------------
1:             /**
2:               ADC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.81.7
17:                    Device            :  PIC16LF1939
18:                    Driver Version    :  2.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.31 and above
21:                    MPLAB             :  MPLAB X 5.45
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adc.h"
53:            #include "device_config.h"
54:            
55:            /**
56:              Section: Macro Declarations
57:            */
58:            
59:            #define ACQ_US_DELAY 5
60:            
61:            void (*ADC_InterruptHandler)(void);
62:            
63:            /**
64:              Section: ADC Module APIs
65:            */
66:            
67:            void ADC_Initialize(void)
68:            {
69:                // set the ADC to the options selected in the User Interface
70:                
71:                // ADFM right; ADNREF VSS; ADPREF VDD; ADCS Frc; 
72:                ADCON1 = 0xF0;
1D08  30F0     MOVLW 0xF0
1D09  0021     MOVLB 0x1
1D0A  009E     MOVWF ADCON1
73:                
74:                // ADRESL 0; 
75:                ADRESL = 0x00;
1D0B  019B     CLRF ADRES
76:                
77:                // ADRESH 0; 
78:                ADRESH = 0x00;
1D0C  019C     CLRF ADRESH
79:                
80:                // GO_nDONE stop; ADON enabled; CHS AN0; 
81:                ADCON0 = 0x01;
1D0D  3001     MOVLW 0x1
1D0E  009D     MOVWF ADCON0
82:                
83:            }
1D0F  0008     RETURN
84:            
85:            void ADC_SelectChannel(adc_channel_t channel)
86:            {
87:                // select the A/D channel
88:                ADCON0bits.CHS = channel;    
89:                // Turn on the ADC module
90:                ADCON0bits.ADON = 1;  
91:            }
92:            
93:            void ADC_StartConversion(void)
94:            {
95:                // Start the conversion
96:                ADCON0bits.GO_nDONE = 1;
97:            }
98:            
99:            
100:           bool ADC_IsConversionDone(void)
101:           {
102:               // Start the conversion
103:              return ((bool)(!ADCON0bits.GO_nDONE));
104:           }
105:           
106:           adc_result_t ADC_GetConversionResult(void)
107:           {
108:               // Conversion finished, return the result
109:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
110:           }
111:           
112:           adc_result_t ADC_GetConversion(adc_channel_t channel)
1010  0020     MOVLB 0x0
1011  00A6     MOVWF Nibble
113:           {
114:               // select the A/D channel
115:               ADCON0bits.CHS = channel;    
1012  0826     MOVF Nibble, W
1013  00A5     MOVWF txData
1014  0DA5     RLF txData, F
1015  0DA5     RLF txData, F
1016  0021     MOVLB 0x1
1017  081D     MOVF ADCON0, W
1018  0020     MOVLB 0x0
1019  0625     XORWF txData, W
101A  3983     ANDLW 0x83
101B  0625     XORWF txData, W
101C  0021     MOVLB 0x1
101D  009D     MOVWF ADCON0
116:               
117:               // Turn on the ADC module
118:               ADCON0bits.ADON = 1;
101E  141D     BSF ADCON0, 0x0
119:           
120:               // Acquisition time delay
121:               __delay_us(ACQ_US_DELAY);
101F  300D     MOVLW 0xD
1020  0B89     DECFSZ WREG, F
1021  2820     GOTO 0x20
1022  0000     NOP
122:           
123:               // Start the conversion
124:               ADCON0bits.GO_nDONE = 1;
1023  0021     MOVLB 0x1
1024  149D     BSF ADCON0, 0x1
125:           
126:               // Wait for the conversion to finish
127:               while (ADCON0bits.GO_nDONE)
128:               {
129:               }
1025  189D     BTFSC ADCON0, 0x1
1026  2828     GOTO 0x28
1027  2829     GOTO 0x29
1028  2825     GOTO 0x25
130:           
131:               // Conversion finished, return the result
132:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
1029  081C     MOVF ADRESH, W
102A  0020     MOVLB 0x0
102B  00A4     MOVWF Data
102C  0021     MOVLB 0x1
102D  081B     MOVF ADRES, W
102E  0020     MOVLB 0x0
102F  00A3     MOVWF data
133:           }
1030  0008     RETURN
134:           
135:           void ADC_TemperatureAcquisitionDelay(void)
136:           {
137:               __delay_us(200);
138:           }
139:           /**
140:            End of File
141:           */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/main.c  ----------------------------------------------
1:             /**
2:              TEST CARTE D925ED4 - BOX GALEO BLTH
3:              * 
4:              * Septembre 2023
5:              * 
6:              * Michel LOPEZ
7:              * 
8:              */
9:             
10:            /*
11:             Equipement: automate v1.0
12:             * PIC16LF1939
13:             * 
14:             * Relais:
15:             * 
16:             * R1: alimentation
17:             * R2: BP1
18:             * R3: BP2
19:             * R4: Horloge
20:             * R5: Cavalier P1
21:             * R6: Cavalier P2
22:             * R7: Touche clavier - "Doigt"
23:             * R8: Avant séquence de test = indicateur inhibition tests des leds; dans sequence de test = indicateur éclairage clavier
24:             * 
25:             * Entrées:
26:             * 
27:             * J13/(IN1 dans le code): NC1
28:             * J15/IN2: NO1
29:             * J16/IN4: NC2
30:             * J17/IN5: NO2
31:             * J19/IN6: NC3
32:             * J18/IN7: NO3
33:             * J14/IN3: Bouton de validation OK 
34:             * J20/IN8: Bouton de confirmation NOK
35:             * J21/AN1: test éclairage clavier par mesure analogique
36:             * 
37:             * Sorties:
38:             * J25.1/C2: led rouge (indication non conforme)
39:             * J25.2/C4: led verte (indication conforme)
40:             * J25.3/C2: led jaune (indication test en cours)
41:             * J26(serigraphie OV)/GPIO1: inhibition test des leds - starp au OV = tests des leds inhibé
42:             * 
43:             * Mode d'emploi:
44:             * 1- Sélectionner mode de test des leds (strap = inhibition)
45:             * 2- Appuyer sur OK, pour lancer la séquence
46:             * 3- Appuyer sur OK pour valider / sur NOK pour invalider
47:             * 4- En fin de séquence le résultat est donné par la led verte ou rouge
48:             * 5- Acquiter le résultat en appuyant sur OK
49:             * 
50:             * 
51:             */
52:            
53:            #include "mcc_generated_files/mcc.h"
54:            #include "I2C_LCD.h"
55:            #include "tester.h"
56:            #include "display.h"
57:            #include <stdlib.h>
58:            
59:            /*
60:                                     Main application
61:             */
62:            void main(void) {
63:                // initialize the device
64:                SYSTEM_Initialize();
0E0E  319E     MOVLP 0x1E
65:            
66:                // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
67:                // Use the following macros to:
68:            
69:                // Enable the Global Interrupts
70:                INTERRUPT_GlobalInterruptEnable();
0E11  178B     BSF INTCON, 0x7
71:            
72:                // Enable the Peripheral Interrupts
73:                INTERRUPT_PeripheralInterruptEnable();
0E12  170B     BSF INTCON, 0x6
74:            
75:                // Disable the Global Interrupts
76:                //INTERRUPT_GlobalInterruptDisable();
77:            
78:                // Disable the Peripheral Interrupts
79:                //INTERRUPT_PeripheralInterruptDisable();
80:            
81:            
82:                // lCD
83:                I2C_Master_Init();
0E13  319D     MOVLP 0x1D
84:                LCD_Init(0x4E); // Initialize LCD module with I2C address = 0x4E
0E16  304E     MOVLW 0x4E
85:                bool testActif = false;
0E1A  0024     MOVLB 0x4
86:                bool testVoyants = false;
0E1C  01E1     CLRF testVoyants
87:                int lectureAN1;
88:                char slectureAN1[5];
89:                bool testLeds = true;
90:                bool automatique = false;
0E1D  01E0     CLRF automatique
91:            
92:            
93:            
94:            
95:                // Affichage message d'accueil
96:            
97:                displayManager(TITRE, BOARD_REQUEST, OK_REQUEST, LIGNE_VIDE);
0E1E  30AE     MOVLW 0xAE
98:                __delay_ms(1000);
0E32  3015     MOVLW 0x15
99:            
100:           
101:               while (1) {
102:           
103:           
104:                   // sélection test individuel des leds
105:                   // le test est inhibé si l'entrée GPIO1 est à zéro
106:           
107:                   if (GPIO1_GetValue() == 1) {
0E3F  0020     MOVLB 0x0
108:           
109:                       REL8_SetHigh();
0E44  0022     MOVLB 0x2
110:                       testLeds = true;
0E46  0024     MOVLB 0x4
111:           
112:                   } else {
0E49  2E4E     GOTO 0x64E
113:           
114:                       testLeds = false;
0E4A  0024     MOVLB 0x4
115:                       REL8_SetLow();
0E4C  0022     MOVLB 0x2
116:                   }
117:           
118:           
119:                   // Attente de démarrage
120:           
121:                   displayManager(TITRE, ATTENTE, CAVALIERS, OK_REQUEST);
0E4E  30AE     MOVLW 0xAE
122:                   __delay_ms(100);
0E62  3003     MOVLW 0x3
123:                   // attenteDemarrage(&automatique, &testActif);
124:                   attenteDemarrage2(&automatique, &testActif);
0E6E  3062     MOVLW 0x62
125:                   testActif = true;
126:                   startAlert();
0E77  3190     MOVLP 0x10
127:                   displayManager("ETAPE 1", "TEST 3 RELAIS ON", LIGNE_VIDE, LIGNE_VIDE);
0E7A  30B6     MOVLW 0xB6
128:                   testActif = true;
0E8E  0024     MOVLB 0x4
129:                   ledConforme(false);
0E91  3000     MOVLW 0x0
130:                   ledNonConforme(false);
0E95  3000     MOVLW 0x0
131:                   ledProgession(true);
0E99  3001     MOVLW 0x1
132:                   REL8_SetLow();
0E9D  0022     MOVLB 0x2
133:                   // entrée dans la séquence de test
134:           
135:                   // ETAPE 1
136:           
137:           
138:                   pressBP1(true);
0E9F  3001     MOVLW 0x1
139:                   pressBP2(true);
0EA3  3001     MOVLW 0x1
140:                   __delay_ms(100);
0EA7  3003     MOVLW 0x3
141:                   alimenter(true);
0EB3  3001     MOVLW 0x1
142:                   __delay_ms(2000); // 2000 pour D925ED4; 10000 pour D850
0EB7  3029     MOVLW 0x29
143:           
144:           
145:                   if (testR1(true) && testR2(true) && testR3(true)) {
0EC3  3001     MOVLW 0x1
0EC8  1903     BTFSC STATUS, 0x2
0ED1  1903     BTFSC STATUS, 0x2
0EDA  1903     BTFSC STATUS, 0x2
146:           
147:                   } else {
148:           
149:                       testActif = false;
0EDF  0024     MOVLB 0x4
150:                       pressBP1(false);
0EE1  3000     MOVLW 0x0
151:                       pressBP2(false);
0EE5  3000     MOVLW 0x0
152:                       alerteDefaut("ETAPE 1", &testActif, &testVoyants);
0EE9  30B6     MOVLW 0xB6
153:                       sortieErreur(&automatique, &testActif, &testVoyants);
0EF9  3060     MOVLW 0x60
154:           
155:                   }
156:           
157:                   __delay_ms(1000);
0F09  3015     MOVLW 0x15
158:           
159:                   pressBP1(false);
0F16  3000     MOVLW 0x0
160:                   pressBP2(false);
0F1A  3000     MOVLW 0x0
161:           
162:                   // ETAPE 2
163:           
164:                   if (testActif) {
0F1E  0024     MOVLB 0x4
165:           
166:                       displayManager("ETAPE 2", "TEST 3 RELAIS OFF", LIGNE_VIDE, LIGNE_VIDE);
0F24  30C6     MOVLW 0xC6
167:                       pressBP1(false);
0F38  3000     MOVLW 0x0
168:                       pressBP2(false);
0F3C  3000     MOVLW 0x0
169:                       __delay_ms(500);
0F40  300B     MOVLW 0xB
170:                       if (!testR1(true) && !testR2(true) && !testR3(true)) {
0F4D  3001     MOVLW 0x1
0F52  1D03     BTFSS STATUS, 0x2
0F5B  1D03     BTFSS STATUS, 0x2
0F64  1D03     BTFSS STATUS, 0x2
171:           
172:                       } else {
173:           
174:                           testActif = false;
0F69  0024     MOVLB 0x4
175:                           alerteDefaut("ETAPE 2", &testActif, &testVoyants);
0F6B  30C6     MOVLW 0xC6
176:                           sortieErreur(&automatique, &testActif, &testVoyants);
0F7B  3060     MOVLW 0x60
177:                       }
178:                   }
179:           
180:           
181:                   // ETAPE 3
182:           
183:                   if (testActif) {
0F8B  0024     MOVLB 0x4
184:           
185:                       displayManager("ETAPE 3", "TEST LED ROUGE", LIGNE_VIDE, LIGNE_VIDE);
0F91  30D6     MOVLW 0xD6
186:                       pressBP1(true);
0FA5  3001     MOVLW 0x1
187:                       __delay_ms(250);
0FA9  3006     MOVLW 0x6
188:                       pressBP1(false);
0FB6  3000     MOVLW 0x0
189:                       if (testLeds) {
0FBA  0024     MOVLB 0x4
190:           
191:                           printf("Attente validation led rouge\r\n");
0FC0  3069     MOVLW 0x69
192:                           testVoyants = reponseOperateur(automatique);
0FC8  0024     MOVLB 0x4
193:                           if (!testVoyants) {
0FD2  0861     MOVF testVoyants, W
194:           
195:                               testActif = false;
0FD7  01E2     CLRF testActif
196:                               alerteDefaut("ETAPE 3", &testActif, &testVoyants);
0FD8  30D6     MOVLW 0xD6
197:                               sortieErreur(&automatique, &testActif, &testVoyants);
0FE8  3060     MOVLW 0x60
198:                           }
199:                       }
200:           
201:           
202:                   }
203:           
204:                   // ETAPE 4
205:           
206:                   if (testActif) {
0FF8  0024     MOVLB 0x4
207:           
208:                       displayManager("ETAPE 4", "TEST LED BLEUE", LIGNE_VIDE, LIGNE_VIDE);
0091  30DE     MOVLW 0xDE
209:                       pressBP1(true);
00A5  3001     MOVLW 0x1
210:                       __delay_ms(250);
00A9  3006     MOVLW 0x6
211:                       pressBP1(false);
00B6  3000     MOVLW 0x0
212:                       if (testLeds) {
00BA  0024     MOVLB 0x4
213:           
214:                           testVoyants = reponseOperateur(automatique);
00C0  0860     MOVF automatique, W
215:                           if (!testVoyants) {
00C9  0861     MOVF testVoyants, W
216:           
217:                               testActif = false;
00CE  01E2     CLRF testActif
218:                               alerteDefaut("ETAPE 4", &testActif, &testVoyants);
00CF  30DE     MOVLW 0xDE
219:                               sortieErreur(&automatique, &testActif, &testVoyants);
00DF  3060     MOVLW 0x60
220:                           }
221:                       }
222:           
223:           
224:                   }
225:           
226:                   // ETAPE 5
227:           
228:                   if (testActif) {
00EF  0024     MOVLB 0x4
229:           
230:                       displayManager("ETAPE 5", "TEST LED VERTE", LIGNE_VIDE, LIGNE_VIDE);
00F5  30E6     MOVLW 0xE6
231:                       pressBP1(true);
0109  3001     MOVLW 0x1
232:                       __delay_ms(250);
010D  3006     MOVLW 0x6
233:                       pressBP1(false);
011A  3000     MOVLW 0x0
234:                       if (testLeds) {
011E  0024     MOVLB 0x4
235:           
236:                           testVoyants = reponseOperateur(automatique);
0124  0860     MOVF automatique, W
237:                           if (!testVoyants) {
012D  0861     MOVF testVoyants, W
238:           
239:                               testActif = false;
0132  01E2     CLRF testActif
240:                               alerteDefaut("ETAPE 5", &testActif, &testVoyants);
0133  30E6     MOVLW 0xE6
241:                               sortieErreur(&automatique, &testActif, &testVoyants);
0143  3060     MOVLW 0x60
242:                           }
243:                       }
244:           
245:                   }
246:           
247:           
248:           
249:                   // ETAPE 6
250:           
251:                   if (testActif) {
0153  0024     MOVLB 0x4
252:           
253:                       displayManager("ETAPE 6", "TEST R1 ON", LIGNE_VIDE, LIGNE_VIDE);
0159  30EE     MOVLW 0xEE
254:                       pressBP1(true);
016D  3001     MOVLW 0x1
255:                       __delay_ms(1000);
0171  3015     MOVLW 0x15
256:                       pressBP1(false);
017E  3000     MOVLW 0x0
257:           
258:                       __delay_ms(1000);
0182  3015     MOVLW 0x15
259:           
260:                       if (testR1(true)) {
018F  3001     MOVLW 0x1
0194  1903     BTFSC STATUS, 0x2
261:           
262:                       } else {
263:           
264:                           testActif = false;
0199  0024     MOVLB 0x4
265:                           alerteDefaut("ETAPE 6", &testActif, &testVoyants);
019B  30EE     MOVLW 0xEE
266:                           sortieErreur(&automatique, &testActif, &testVoyants);
01AB  3060     MOVLW 0x60
267:                       }
268:           
269:                   }
270:           
271:                   // ETAPE 7
272:           
273:                   if (testActif) {
01BB  0024     MOVLB 0x4
274:           
275:                       displayManager("ETAPE 7", "TEST R1 OFF - R2 ON", LIGNE_VIDE, LIGNE_VIDE);
01C1  30F6     MOVLW 0xF6
276:                       pressBP1(true);
01D5  3001     MOVLW 0x1
277:                       __delay_ms(1000);
01D9  3015     MOVLW 0x15
278:                       pressBP1(false);
01E6  3000     MOVLW 0x0
279:           
280:                       __delay_ms(1000);
01EA  3015     MOVLW 0x15
281:           
282:                       if (testR1(false) && testR2(true)) {
01F7  3000     MOVLW 0x0
01FC  1903     BTFSC STATUS, 0x2
0205  1903     BTFSC STATUS, 0x2
283:           
284:                       } else {
285:           
286:                           testActif = false;
020A  0024     MOVLB 0x4
287:                           alerteDefaut("ETAPE 7", &testActif, &testVoyants);
020C  30F6     MOVLW 0xF6
288:                           sortieErreur(&automatique, &testActif, &testVoyants);
021C  3060     MOVLW 0x60
289:                       }
290:           
291:                   }
292:           
293:                   // ETAPE 8
294:           
295:                   if (testActif) {
022C  0024     MOVLB 0x4
296:           
297:                       displayManager("ETAPE 8", "TEST R2 OFF - R3 ON", LIGNE_VIDE, LIGNE_VIDE);
0232  30FE     MOVLW 0xFE
298:                       pressBP1(true);
0246  3001     MOVLW 0x1
299:                       __delay_ms(1000);
024A  3015     MOVLW 0x15
300:                       pressBP1(false);
0257  3000     MOVLW 0x0
301:           
302:                       __delay_ms(1000);
025B  3015     MOVLW 0x15
303:           
304:                       if (testR2(false) && testR3(true)) {
0268  3000     MOVLW 0x0
026D  1903     BTFSC STATUS, 0x2
0276  1903     BTFSC STATUS, 0x2
305:           
306:                       } else {
307:           
308:                           testActif = false;
027B  0024     MOVLB 0x4
309:                           alerteDefaut("ETAPE 8", &testActif, &testVoyants);
027D  30FE     MOVLW 0xFE
310:                           sortieErreur(&automatique, &testActif, &testVoyants);
028D  3060     MOVLW 0x60
311:                       }
312:           
313:                   }
314:           
315:                   // ETAPE 9
316:           
317:                   if (testActif) {
029D  0024     MOVLB 0x4
318:           
319:                       displayManager("ETAPE 9", "TEST LED CLAVIER", "CLAVIER ECLAIRE?", LIGNE_VIDE);
02A3  3006     MOVLW 0x6
320:                       pressBP1(true);
02B7  3001     MOVLW 0x1
321:                       __delay_ms(250);
02BB  3006     MOVLW 0x6
322:                       pressBP1(false);
02C8  3000     MOVLW 0x0
323:                       __delay_ms(500);
02CC  300B     MOVLW 0xB
324:                       // Lecture analogique
325:                       // Led on: Van = 433
326:                       // Led off: Van = 587
327:           
328:                       lectureAN1 = ADC_GetConversion(VIN1);
02D9  300C     MOVLW 0xC
329:                       int buffer = sprintf(slectureAN1, "%d", lectureAN1);
02E5  300E     MOVLW 0xE
330:                       if (lectureAN1 < LIM_H) {
02FE  085F     MOVF 0x25F, W
0304  1D03     BTFSS STATUS, 0x2
0309  1803     BTFSC STATUS, 0x0
331:           
332:           
333:                           REL8_SetHigh();
030D  0022     MOVLB 0x2
334:           
335:                       } else {
336:           
337:                           alerteDefaut("ETAPE 9", &testActif, &testVoyants);
0310  3006     MOVLW 0x6
338:                           //displayManager("ETAPE 9", "TEST LED CLAVIER", slectureAN1, LIGNE_VIDE); // Ligne de test: affichage valeur de mesure analogique
339:                           REL8_SetLow();
0320  0022     MOVLB 0x2
340:                           sortieErreur(&automatique, &testActif, &testVoyants);
0322  3060     MOVLW 0x60
341:           
342:                       }
343:           
344:                       __delay_ms(2000);
0332  3029     MOVLW 0x29
345:           
346:                   }
347:           
348:                   // ETAPE 10
349:           
350:                   if (testActif) {
033E  0024     MOVLB 0x4
351:           
352:                       displayManager("ETAPE 10", "TEST LED CLAVIER", "CLAVIER ETEINT?", LIGNE_VIDE);
0344  305D     MOVLW 0x5D
353:                       pressBP1(true);
0358  3001     MOVLW 0x1
354:                       __delay_ms(250);
035C  3006     MOVLW 0x6
355:                       pressBP1(false);
0369  3000     MOVLW 0x0
356:           
357:                       // Lecture analogique
358:                       // Led on: Van = 433
359:                       // Led off: Van = 587
360:                       __delay_ms(500);
036D  300B     MOVLW 0xB
361:                       lectureAN1 = ADC_GetConversion(VIN1);
037A  300C     MOVLW 0xC
362:                       int buffer = sprintf(slectureAN1, "%d", lectureAN1);
0386  300E     MOVLW 0xE
363:           
364:                       if (lectureAN1 < LIM_L) {
039F  085F     MOVF 0x25F, W
03A5  1D03     BTFSS STATUS, 0x2
03AA  1803     BTFSC STATUS, 0x0
365:           
366:           
367:                           REL8_SetLow();
03AE  0022     MOVLB 0x2
368:           
369:                       } else {
370:           
371:                           alerteDefaut("ETAPE 10", &testActif, &testVoyants);
03B1  305D     MOVLW 0x5D
372:                           //displayManager("ETAPE 10", "TEST LED CLAVIER", slectureAN1, LIGNE_VIDE); // Ligne de test: affichage valeur de mesure analogique
373:                           REL8_SetHigh();
03C1  0022     MOVLB 0x2
374:                           sortieErreur(&automatique, &testActif, &testVoyants);
03C3  3060     MOVLW 0x60
375:           
376:                       }
377:                       __delay_ms(2000);
03D3  3029     MOVLW 0x29
378:           
379:                   }
380:           
381:           
382:                   // ETAPE 12
383:           
384:                   if (testActif) {
03DF  0024     MOVLB 0x4
385:           
386:                       displayManager("ETAPE 12", "TEST SFLASH", LIGNE_VIDE, LIGNE_VIDE);
03E5  3066     MOVLW 0x66
387:                       __delay_ms(500);
03F9  300B     MOVLW 0xB
388:                       pressBP1(true);
0406  3001     MOVLW 0x1
389:                       __delay_ms(250);
040A  3006     MOVLW 0x6
390:                       pressBP1(false);
0417  3000     MOVLW 0x0
391:           
392:                       __delay_ms(3000);
041B  303D     MOVLW 0x3D
393:           
394:                       pressBP1(true);
0428  3001     MOVLW 0x1
395:                       __delay_ms(250);
042C  3006     MOVLW 0x6
396:                       pressBP1(false);
0439  3000     MOVLW 0x0
397:                       __delay_ms(750);
043D  3010     MOVLW 0x10
398:           
399:                       if (testR1(true) && testR2(true) && testR3(false)) {
044A  3001     MOVLW 0x1
044F  1903     BTFSC STATUS, 0x2
0458  1903     BTFSC STATUS, 0x2
0461  1903     BTFSC STATUS, 0x2
400:           
401:                       } else {
402:           
403:                           testActif = false;
0466  0024     MOVLB 0x4
404:                           pressBP1(false);
0468  3000     MOVLW 0x0
405:                           pressBP2(false);
046C  3000     MOVLW 0x0
406:                           alerteDefaut("ETAPE 12", &testActif, &testVoyants);
0470  3066     MOVLW 0x66
407:                           sortieErreur(&automatique, &testActif, &testVoyants);
0480  3060     MOVLW 0x60
408:           
409:                       }
410:           
411:                       __delay_ms(1000);
0490  3015     MOVLW 0x15
412:           
413:                       pressBP1(false);
049D  3000     MOVLW 0x0
414:                       pressBP2(false);
04A1  3000     MOVLW 0x0
415:           
416:                   }
417:           
418:                   // ETAPE 13
419:           
420:           
421:                   if (testActif) {
04A5  0024     MOVLB 0x4
422:           
423:                       displayManager("ETAPE 13", "TEST LEDS CARTE", "LEDS ALLUMEES", "PRESSER OK / NOK");
04AB  3078     MOVLW 0x78
424:                       pressBP1(true);
04BF  3001     MOVLW 0x1
425:                       __delay_ms(250);
04C3  3006     MOVLW 0x6
426:                       pressBP1(false);
04D0  3000     MOVLW 0x0
427:           
428:                       printf("ATTENTE VALIDATION LEDS\r\n");
04D4  301A     MOVLW 0x1A
429:                       testVoyants = reponseOperateur(automatique);
04DC  0024     MOVLB 0x4
430:                       if (!testVoyants) {
04E6  0861     MOVF testVoyants, W
431:           
432:                           testActif = false;
04EB  01E2     CLRF testActif
433:                           alerteDefaut("ETAPE 13", &testActif, &testVoyants);
04EC  3078     MOVLW 0x78
434:                           sortieErreur(&automatique, &testActif, &testVoyants);
04FC  3060     MOVLW 0x60
435:                           /*
436:                           attenteAquittement(&automatique, &testActif);
437:                           initialConditions(&testActif, &testVoyants, &automatique);
438:                           __delay_ms(2000);
439:                            */
440:                       }
441:                   }
442:           
443:                   // ETAPE 14
444:           
445:                   if (testActif) {
050C  0024     MOVLB 0x4
446:           
447:                       displayManager("ETAPE 14", "TEST BP2", LIGNE_VIDE, LIGNE_VIDE);
0512  3081     MOVLW 0x81
448:                       pressBP2(true);
0526  3001     MOVLW 0x1
449:                       __delay_ms(250);
052A  3006     MOVLW 0x6
450:                       pressBP2(false);
0537  3000     MOVLW 0x0
451:                       __delay_ms(500);
053B  300B     MOVLW 0xB
452:           
453:                       if (testR1(true) && testR2(true) && testR3(true)) {
0548  3001     MOVLW 0x1
054D  1903     BTFSC STATUS, 0x2
0556  1903     BTFSC STATUS, 0x2
055F  1903     BTFSC STATUS, 0x2
454:           
455:                       } else {
456:           
457:                           testActif = false;
0564  0024     MOVLB 0x4
458:                           alerteDefaut("ETAPE 14", &testActif, &testVoyants);
0566  3081     MOVLW 0x81
459:                           sortieErreur(&automatique, &testActif, &testVoyants);
0576  3060     MOVLW 0x60
460:                       }
461:           
462:                   }
463:           
464:                   // ETAPE 15
465:           
466:                   if (testActif) {
0586  0024     MOVLB 0x4
467:           
468:                       displayManager("ETAPE 15", "TEST HORLOGE", LIGNE_VIDE, LIGNE_VIDE);
058C  308A     MOVLW 0x8A
469:                       setHorloge(true);
05A0  3001     MOVLW 0x1
470:                       __delay_ms(250);
05A4  3006     MOVLW 0x6
471:                       setHorloge(false);
05B1  3000     MOVLW 0x0
472:                       __delay_ms(500);
05B5  300B     MOVLW 0xB
473:           
474:                       if (testR1(false) && testR2(false) && testR3(false)) {
05C2  3000     MOVLW 0x0
05C7  1903     BTFSC STATUS, 0x2
05D0  1903     BTFSC STATUS, 0x2
05D9  1903     BTFSC STATUS, 0x2
475:           
476:                       } else {
477:           
478:                           testActif = false;
05DE  0024     MOVLB 0x4
479:                           alerteDefaut("ETAPE 15", &testActif, &testVoyants);
05E0  308A     MOVLW 0x8A
480:                           sortieErreur(&automatique, &testActif, &testVoyants);
05F0  3060     MOVLW 0x60
481:                       }
482:           
483:                   }
484:           
485:                   // ETAPE 16
486:           
487:                   if (testActif) {
0600  0024     MOVLB 0x4
488:           
489:                       displayManager("ETAPE 16", "TEST P1", LIGNE_VIDE, LIGNE_VIDE);
0606  3093     MOVLW 0x93
490:                       setP1(true);
061A  3001     MOVLW 0x1
491:                       __delay_ms(1200); // 1200 pour D925ED2
061E  3019     MOVLW 0x19
492:           
493:                       setP1(false);
062B  3000     MOVLW 0x0
494:                       __delay_ms(500);
062F  300B     MOVLW 0xB
495:                       if (testR1(true) && testR2(true) && testR3(true)) {
063C  3001     MOVLW 0x1
0641  1903     BTFSC STATUS, 0x2
064A  1903     BTFSC STATUS, 0x2
0653  1903     BTFSC STATUS, 0x2
496:           
497:           
498:           
499:                       } else {
500:           
501:                           //testActif = false;
502:                           alerteDefautEtape16("ETAPE 16", &testActif, &testVoyants, &automatique);
0658  3093     MOVLW 0x93
503:                           //sortieErreur(&automatique, &testActif, &testVoyants);
504:                       }
505:           
506:                   }
507:           
508:                   // ETAPE 17
509:           
510:                   if (testActif) {
066C  0024     MOVLB 0x4
511:           
512:                       displayManager("ETAPE 17", "TEST P2", LIGNE_VIDE, LIGNE_VIDE);
0672  309C     MOVLW 0x9C
513:                       setP2(true);
0686  3001     MOVLW 0x1
514:                       __delay_ms(1200);
068A  3019     MOVLW 0x19
515:                       setP2(false);
0697  3000     MOVLW 0x0
516:                       __delay_ms(500);
069B  300B     MOVLW 0xB
517:           
518:                       if (testR1(false) && testR2(false) && testR3(false)) {
06A8  3000     MOVLW 0x0
06AD  1903     BTFSC STATUS, 0x2
06B6  1903     BTFSC STATUS, 0x2
06BF  1903     BTFSC STATUS, 0x2
519:           
520:                       } else {
521:           
522:                           testActif = false;
06C4  0024     MOVLB 0x4
523:                           alerteDefaut("ETAPE 17", &testActif, &testVoyants);
06C6  309C     MOVLW 0x9C
524:                           sortieErreur(&automatique, &testActif, &testVoyants);
06D6  3060     MOVLW 0x60
525:                       }
526:           
527:                   }
528:           
529:           
530:                   // ETAPE 18
531:           
532:                   if (testActif) {
06E6  0024     MOVLB 0x4
533:           
534:                       displayManager("ETAPE 18", "TEST BLUETOOTH", "VOIR APPLI", "PRESSER OK / NOK");
06EC  30A5     MOVLW 0xA5
535:                       activerTouche();
0700  319F     MOVLP 0x1F
536:                       printf("ATTENTE VALIDATION BLUETOOTH\r\n");
0703  304A     MOVLW 0x4A
537:                       testVoyants = reponseOperateur(automatique);
070B  0024     MOVLB 0x4
538:                       if (!testVoyants) {
0715  0861     MOVF testVoyants, W
539:           
540:                           testActif = false;
071A  01E2     CLRF testActif
541:                           alerteDefaut("ETAPE 18", &testActif, &testVoyants);
071B  30A5     MOVLW 0xA5
542:                           sortieErreur(&automatique, &testActif, &testVoyants);
072B  3060     MOVLW 0x60
543:                           //initialConditions(&testActif, &testVoyants, &automatique);
544:                           __delay_ms(2000);
073B  3029     MOVLW 0x29
545:                       }
546:                   }
547:           
548:           
549:                   // ETAPE: SORTIE
550:           
551:                   if (testActif) {
0747  0024     MOVLB 0x4
552:           
553:                       displayManager("FIN DE TEST", "CONFORME", "RETIRER CARTE", ACQ);
074E  303B     MOVLW 0x3B
554:                       ledConforme(true);
0762  3001     MOVLW 0x1
555:                       alimenter(false);
0766  3000     MOVLW 0x0
556:                       okAlert();
076A  3190     MOVLP 0x10
557:                       //attenteDemarrage(&automatique, &testActif);
558:                       attenteAquittement(&automatique, &testActif);
076D  3060     MOVLW 0x60
559:                       initialConditions(&testActif, &testVoyants, &automatique);
0779  3062     MOVLW 0x62
560:                       __delay_ms(2000);
0789  3029     MOVLW 0x29
561:           
562:                   }
563:           
564:               } // fin boucle infinie
565:           
566:           
567:           
568:           } // fin fonction main
569:           
570:           /**
571:            End of File
572:            */
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/display.c  -------------------------------------------
1:             
2:             
3:             #include <xc.h>
4:             #include "mcc_generated_files/mcc.h"
5:             #include "I2C_LCD.h"
6:             
7:             void displayManager(char s1[], char s2[], char s3[], char s4[]) {
8:             
9:                 LCD_Clear();
14C3  319D     MOVLP 0x1D
14C4  2546     CALL 0x546
14C5  3194     MOVLP 0x14
10:                LCD_CMD(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME);
14C6  3006     MOVLW 0x6
14C7  319E     MOVLP 0x1E
14C8  26EB     CALL 0x6EB
14C9  3194     MOVLP 0x14
11:                __delay_ms(50);
14CA  3002     MOVLW 0x2
14CB  0020     MOVLB 0x0
14CC  00B7     MOVWF p
14CD  3004     MOVLW 0x4
14CE  00B6     MOVWF buf
14CF  30BA     MOVLW 0xBA
14D0  0B89     DECFSZ WREG, F
14D1  2CD0     GOTO 0x4D0
14D2  0BB6     DECFSZ buf, F
14D3  2CD0     GOTO 0x4D0
14D4  0BB7     DECFSZ p, F
14D5  2CD0     GOTO 0x4D0
14D6  0000     NOP
12:                LCD_Set_Cursor(1, 1);
14D7  0020     MOVLB 0x0
14D8  01A9     CLRF Str
14D9  0AA9     INCF Str, F
14DA  3001     MOVLW 0x1
14DB  3192     MOVLP 0x12
14DC  2288     CALL 0x288
14DD  3194     MOVLP 0x14
13:                LCD_Write_String(s1);
14DE  0020     MOVLB 0x0
14DF  082F     MOVF s, W
14E0  00AA     MOVWF repOperateur
14E1  082E     MOVF fp, W
14E2  00A9     MOVWF Str
14E3  319F     MOVLP 0x1F
14E4  27E1     CALL 0x7E1
14E5  3194     MOVLP 0x14
14:                LCD_Set_Cursor(2, 1);
14E6  0020     MOVLB 0x0
14E7  01A9     CLRF Str
14E8  0AA9     INCF Str, F
14E9  3002     MOVLW 0x2
14EA  3192     MOVLP 0x12
14EB  2288     CALL 0x288
14EC  3194     MOVLP 0x14
15:                LCD_Write_String(s2);
14ED  0020     MOVLB 0x0
14EE  0831     MOVF d, W
14EF  00AA     MOVWF repOperateur
14F0  0830     MOVF s2, W
14F1  00A9     MOVWF Str
14F2  319F     MOVLP 0x1F
14F3  27E1     CALL 0x7E1
14F4  3194     MOVLP 0x14
16:                LCD_Set_Cursor(3, 1);
14F5  0020     MOVLB 0x0
14F6  01A9     CLRF Str
14F7  0AA9     INCF Str, F
14F8  3003     MOVLW 0x3
14F9  3192     MOVLP 0x12
14FA  2288     CALL 0x288
14FB  3194     MOVLP 0x14
17:                LCD_Write_String(s3);
14FC  0020     MOVLB 0x0
14FD  0833     MOVF dest, W
14FE  00AA     MOVWF repOperateur
14FF  0832     MOVF c, W
1500  00A9     MOVWF Str
1501  319F     MOVLP 0x1F
1502  27E1     CALL 0x7E1
1503  3194     MOVLP 0x14
18:                LCD_Set_Cursor(4, 1);
1504  0020     MOVLB 0x0
1505  01A9     CLRF Str
1506  0AA9     INCF Str, F
1507  3004     MOVLW 0x4
1508  3192     MOVLP 0x12
1509  2288     CALL 0x288
150A  3194     MOVLP 0x14
19:                LCD_Write_String(s4);
150B  0020     MOVLB 0x0
150C  0835     MOVF src, W
150D  00AA     MOVWF repOperateur
150E  0834     MOVF counter, W
150F  00A9     MOVWF Str
1510  319F     MOVLP 0x1F
1511  27E1     CALL 0x7E1
1512  3194     MOVLP 0x14
20:            
21:            }
1513  0008     RETURN
---  C:/Users/Michel/MPLABXProjects/galeoTester1.X/I2C_LCD.c  -------------------------------------------
1:             
2:             #include <xc.h>
3:             #include "I2C_LCD.h"
4:             
5:             unsigned char RS, i2c_add, BackLight_State = LCD_BACKLIGHT;
6:             
7:             //---------------[ I2C Routines ]-------------------
8:             //--------------------------------------------------
9:             void I2C_Master_Init()
10:            {
11:              SSPCON  = 0x28;
1D59  3028     MOVLW 0x28
1D5A  0024     MOVLB 0x4
1D5B  0095     MOVWF SSPCON1
12:              SSPCON2 = 0x00;
1D5C  0196     CLRF SSPCON2
13:              SSPSTAT = 0x00;
1D5D  0194     CLRF SSPSTAT
14:              SSPADD = ((_XTAL_FREQ/4)/I2C_BaudRate) - 1;
1D5E  3027     MOVLW 0x27
1D5F  0092     MOVWF SSPADD
15:              SCL_D = 1;
1D60  0021     MOVLB 0x1
1D61  158E     BSF TRISC, 0x3
16:              SDA_D = 1; 
1D62  160E     BSF TRISC, 0x4
17:            }
1D63  0008     RETURN
18:            
19:            void I2C_Master_Wait()
20:            {
21:                while ((SSPSTAT & 0x04) || (SSPCON2 & 0x1F));
1D64  0024     MOVLB 0x4
1D65  1914     BTFSC SSPSTAT, 0x2
1D66  2D68     GOTO 0x568
1D67  2D69     GOTO 0x569
1D68  2D64     GOTO 0x564
1D69  0816     MOVF SSPCON2, W
1D6A  391F     ANDLW 0x1F
1D6B  1D03     BTFSS STATUS, 0x2
1D6C  2D6E     GOTO 0x56E
1D6D  2D6F     GOTO 0x56F
1D6E  2D64     GOTO 0x564
22:            }
1D6F  0008     RETURN
23:            
24:            void I2C_Master_Start()
25:            {
26:                I2C_Master_Wait();
1CE0  319D     MOVLP 0x1D
1CE1  2564     CALL 0x564
1CE2  319C     MOVLP 0x1C
27:                SEN = 1;
1CE3  0024     MOVLB 0x4
1CE4  1416     BSF SSPCON2, 0x0
28:            }
1CE5  0008     RETURN
29:            
30:            void I2C_Master_RepeatedStart()
31:            {
32:                I2C_Master_Wait();
33:                RSEN = 1;
34:            }
35:            
36:            void I2C_Master_Stop()
37:            {
38:                I2C_Master_Wait();
1CE6  319D     MOVLP 0x1D
1CE7  2564     CALL 0x564
1CE8  319C     MOVLP 0x1C
39:                PEN = 1;
1CE9  0024     MOVLB 0x4
1CEA  1516     BSF SSPCON2, 0x2
40:            }
1CEB  0008     RETURN
41:            
42:            void I2C_ACK(void)
43:            {
44:            	ACKDT = 0;			// 0 -> ACK
45:            	I2C_Master_Wait();
46:                ACKEN = 1;			// Send ACK
47:            }
48:            
49:            void I2C_NACK(void)
50:            {
51:            	ACKDT = 1;			// 1 -> NACK
52:                I2C_Master_Wait();
53:            	ACKEN = 1;			// Send NACK
54:            }
55:            
56:            unsigned char I2C_Master_Write(unsigned char data)
1000  0020     MOVLB 0x0
1001  00A3     MOVWF data
57:            {
58:                I2C_Master_Wait();
1002  319D     MOVLP 0x1D
1003  2564     CALL 0x564
1004  3190     MOVLP 0x10
59:                SSPBUF = data;
1005  0020     MOVLB 0x0
1006  0823     MOVF data, W
1007  0024     MOVLB 0x4
1008  0091     MOVWF SSPBUF
60:                while(!SSPIF);  // Wait Until Completion
1009  0020     MOVLB 0x0
100A  1D91     BTFSS PIR1, 0x3
100B  280D     GOTO 0xD
100C  280E     GOTO 0xE
100D  2809     GOTO 0x9
61:            	SSPIF = 0;
100E  1191     BCF PIR1, 0x3
62:                return ACKSTAT;
63:            }
100F  0008     RETURN
64:            
65:            unsigned char I2C_Read_Byte(void)
66:            {
67:                //---[ Receive & Return A Byte ]---
68:            	I2C_Master_Wait();
69:                RCEN = 1;		  // Enable & Start Reception
70:            	while(!SSPIF);	  // Wait Until Completion
71:            	SSPIF = 0;		  // Clear The Interrupt Flag Bit
72:                I2C_Master_Wait();
73:                return SSPBUF;	  // Return The Received Byte
74:            }
75:            //======================================================
76:            
77:            //---------------[ LCD Routines ]----------------
78:            //------------------------------------------------------
79:            
80:            void LCD_Init(unsigned char I2C_Add) 
1774  0020     MOVLB 0x0
1775  00AB     MOVWF I2C_Add
81:            {
82:              i2c_add = I2C_Add;
1776  082B     MOVF I2C_Add, W
1777  00A9     MOVWF Str
1778  0829     MOVF Str, W
1779  0021     MOVLB 0x1
177A  00E3     MOVWF i2c_add
83:              IO_Expander_Write(0x00);
177B  3000     MOVLW 0x0
177C  319E     MOVLP 0x1E
177D  2679     CALL 0x679
177E  3197     MOVLP 0x17
84:              __delay_ms(30);
177F  309C     MOVLW 0x9C
1780  0020     MOVLB 0x0
1781  00A9     MOVWF Str
1782  30D7     MOVLW 0xD7
1783  0B89     DECFSZ WREG, F
1784  2F83     GOTO 0x783
1785  0BA9     DECFSZ Str, F
1786  2F83     GOTO 0x783
85:              LCD_CMD(0x03);
1787  3003     MOVLW 0x3
1788  319E     MOVLP 0x1E
1789  26EB     CALL 0x6EB
178A  3197     MOVLP 0x17
86:              __delay_ms(5);
178B  301A     MOVLW 0x1A
178C  0020     MOVLB 0x0
178D  00A9     MOVWF Str
178E  30F8     MOVLW 0xF8
178F  0B89     DECFSZ WREG, F
1790  2F8F     GOTO 0x78F
1791  0BA9     DECFSZ Str, F
1792  2F8F     GOTO 0x78F
1793  0000     NOP
87:              LCD_CMD(0x03);
1794  3003     MOVLW 0x3
1795  319E     MOVLP 0x1E
1796  26EB     CALL 0x6EB
1797  3197     MOVLP 0x17
88:              __delay_ms(5);
1798  301A     MOVLW 0x1A
1799  0020     MOVLB 0x0
179A  00A9     MOVWF Str
179B  30F8     MOVLW 0xF8
179C  0B89     DECFSZ WREG, F
179D  2F9C     GOTO 0x79C
179E  0BA9     DECFSZ Str, F
179F  2F9C     GOTO 0x79C
17A0  0000     NOP
89:              LCD_CMD(0x03);
17A1  3003     MOVLW 0x3
17A2  319E     MOVLP 0x1E
17A3  26EB     CALL 0x6EB
17A4  3197     MOVLP 0x17
90:              __delay_ms(5);
17A5  301A     MOVLW 0x1A
17A6  0020     MOVLB 0x0
17A7  00A9     MOVWF Str
17A8  30F8     MOVLW 0xF8
17A9  0B89     DECFSZ WREG, F
17AA  2FA9     GOTO 0x7A9
17AB  0BA9     DECFSZ Str, F
17AC  2FA9     GOTO 0x7A9
17AD  0000     NOP
91:              LCD_CMD(LCD_RETURN_HOME);
17AE  3002     MOVLW 0x2
17AF  319E     MOVLP 0x1E
17B0  26EB     CALL 0x6EB
17B1  3197     MOVLP 0x17
92:              __delay_ms(5);
17B2  301A     MOVLW 0x1A
17B3  0020     MOVLB 0x0
17B4  00A9     MOVWF Str
17B5  30F8     MOVLW 0xF8
17B6  0B89     DECFSZ WREG, F
17B7  2FB6     GOTO 0x7B6
17B8  0BA9     DECFSZ Str, F
17B9  2FB6     GOTO 0x7B6
17BA  0000     NOP
93:              LCD_CMD(0x20 | (LCD_TYPE << 2));
17BB  3028     MOVLW 0x28
17BC  319E     MOVLP 0x1E
17BD  26EB     CALL 0x6EB
17BE  3197     MOVLP 0x17
94:              __delay_ms(50);
17BF  3002     MOVLW 0x2
17C0  0020     MOVLB 0x0
17C1  00AA     MOVWF repOperateur
17C2  3004     MOVLW 0x4
17C3  00A9     MOVWF Str
17C4  30BA     MOVLW 0xBA
17C5  0B89     DECFSZ WREG, F
17C6  2FC5     GOTO 0x7C5
17C7  0BA9     DECFSZ Str, F
17C8  2FC5     GOTO 0x7C5
17C9  0BAA     DECFSZ repOperateur, F
17CA  2FC5     GOTO 0x7C5
17CB  0000     NOP
95:              LCD_CMD(LCD_TURN_ON);
17CC  300C     MOVLW 0xC
17CD  319E     MOVLP 0x1E
17CE  26EB     CALL 0x6EB
17CF  3197     MOVLP 0x17
96:              __delay_ms(50);
17D0  3002     MOVLW 0x2
17D1  0020     MOVLB 0x0
17D2  00AA     MOVWF repOperateur
17D3  3004     MOVLW 0x4
17D4  00A9     MOVWF Str
17D5  30BA     MOVLW 0xBA
17D6  0B89     DECFSZ WREG, F
17D7  2FD6     GOTO 0x7D6
17D8  0BA9     DECFSZ Str, F
17D9  2FD6     GOTO 0x7D6
17DA  0BAA     DECFSZ repOperateur, F
17DB  2FD6     GOTO 0x7D6
17DC  0000     NOP
97:              LCD_CMD(LCD_CLEAR);
17DD  3001     MOVLW 0x1
17DE  319E     MOVLP 0x1E
17DF  26EB     CALL 0x6EB
17E0  3197     MOVLP 0x17
98:              __delay_ms(50);
17E1  3002     MOVLW 0x2
17E2  0020     MOVLB 0x0
17E3  00AA     MOVWF repOperateur
17E4  3004     MOVLW 0x4
17E5  00A9     MOVWF Str
17E6  30BA     MOVLW 0xBA
17E7  0B89     DECFSZ WREG, F
17E8  2FE7     GOTO 0x7E7
17E9  0BA9     DECFSZ Str, F
17EA  2FE7     GOTO 0x7E7
17EB  0BAA     DECFSZ repOperateur, F
17EC  2FE7     GOTO 0x7E7
17ED  0000     NOP
99:              LCD_CMD(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME);
17EE  3006     MOVLW 0x6
17EF  319E     MOVLP 0x1E
17F0  26EB     CALL 0x6EB
17F1  3197     MOVLP 0x17
100:             __delay_ms(50);
17F2  3002     MOVLW 0x2
17F3  0020     MOVLB 0x0
17F4  00AA     MOVWF repOperateur
17F5  3004     MOVLW 0x4
17F6  00A9     MOVWF Str
17F7  30BA     MOVLW 0xBA
17F8  0B89     DECFSZ WREG, F
17F9  2FF8     GOTO 0x7F8
17FA  0BA9     DECFSZ Str, F
17FB  2FF8     GOTO 0x7F8
17FC  0BAA     DECFSZ repOperateur, F
17FD  2FF8     GOTO 0x7F8
17FE  0000     NOP
101:           }
17FF  0008     RETURN
102:           
103:           void IO_Expander_Write(unsigned char Data) 
1E79  0020     MOVLB 0x0
1E7A  00A4     MOVWF Data
104:           {
105:             I2C_Master_Start();
1E7B  319C     MOVLP 0x1C
1E7C  24E0     CALL 0x4E0
1E7D  319E     MOVLP 0x1E
106:             I2C_Master_Write(i2c_add);
1E7E  0021     MOVLB 0x1
1E7F  0863     MOVF i2c_add, W
1E80  3190     MOVLP 0x10
1E81  2000     CALL 0x0
1E82  319E     MOVLP 0x1E
107:             I2C_Master_Write(Data | BackLight_State);
1E83  0020     MOVLB 0x0
1E84  0824     MOVF Data, W
1E85  0022     MOVLB 0x2
1E86  046E     IORWF BackLight_State, W
1E87  3190     MOVLP 0x10
1E88  2000     CALL 0x0
1E89  319E     MOVLP 0x1E
108:             I2C_Master_Stop();
1E8A  319C     MOVLP 0x1C
1E8B  24E6     CALL 0x4E6
1E8C  319E     MOVLP 0x1E
109:           }
1E8D  0008     RETURN
110:           
111:           void LCD_Write_4Bit(unsigned char Nibble) 
1ED3  0020     MOVLB 0x0
1ED4  00A6     MOVWF Nibble
112:           {
113:             // Get The RS Value To LSB OF Data  
114:             Nibble |= RS;
1ED5  0021     MOVLB 0x1
1ED6  0864     MOVF RS, W
1ED7  0020     MOVLB 0x0
1ED8  00A5     MOVWF txData
1ED9  0825     MOVF txData, W
1EDA  04A6     IORWF Nibble, F
115:             IO_Expander_Write(Nibble | 0x04);
1EDB  0826     MOVF Nibble, W
1EDC  3804     IORLW 0x4
1EDD  319E     MOVLP 0x1E
1EDE  2679     CALL 0x679
1EDF  319E     MOVLP 0x1E
116:             IO_Expander_Write(Nibble & 0xFB);
1EE0  0020     MOVLB 0x0
1EE1  0826     MOVF Nibble, W
1EE2  39FB     ANDLW 0xFB
1EE3  319E     MOVLP 0x1E
1EE4  2679     CALL 0x679
1EE5  319E     MOVLP 0x1E
117:             __delay_us(50);
1EE6  3042     MOVLW 0x42
1EE7  0B89     DECFSZ WREG, F
1EE8  2EE7     GOTO 0x6E7
1EE9  3200     BRA 0x1EEA
118:           }
1EEA  0008     RETURN
119:           
120:           void LCD_CMD(unsigned char CMD) 
1EEB  0020     MOVLB 0x0
1EEC  00A8     MOVWF Data
121:           {
122:             RS = 0; // Command Register Select
1EED  0021     MOVLB 0x1
1EEE  01E4     CLRF RS
123:             LCD_Write_4Bit(CMD & 0xF0);
1EEF  0020     MOVLB 0x0
1EF0  0828     MOVF Data, W
1EF1  39F0     ANDLW 0xF0
1EF2  319E     MOVLP 0x1E
1EF3  26D3     CALL 0x6D3
1EF4  319E     MOVLP 0x1E
124:             LCD_Write_4Bit((CMD << 4) & 0xF0);
1EF5  0020     MOVLB 0x0
1EF6  0828     MOVF Data, W
1EF7  00A7     MOVWF reception
1EF8  3003     MOVLW 0x3
1EF9  35A7     LSLF reception, F
1EFA  3EFF     ADDLW 0xFF
1EFB  1D03     BTFSS STATUS, 0x2
1EFC  2EF9     GOTO 0x6F9
1EFD  3527     LSLF reception, W
1EFE  39F0     ANDLW 0xF0
1EFF  319E     MOVLP 0x1E
1F00  26D3     CALL 0x6D3
1F01  319E     MOVLP 0x1E
125:           }
1F02  0008     RETURN
126:           
127:           void LCD_Write_Char(char Data)
1F03  0020     MOVLB 0x0
1F04  00A8     MOVWF Data
128:           {
129:             RS = 1;  // Data Register Select
1F05  0021     MOVLB 0x1
1F06  01E4     CLRF RS
1F07  0AE4     INCF RS, F
130:             LCD_Write_4Bit(Data & 0xF0);
1F08  0020     MOVLB 0x0
1F09  0828     MOVF Data, W
1F0A  39F0     ANDLW 0xF0
1F0B  319E     MOVLP 0x1E
1F0C  26D3     CALL 0x6D3
1F0D  319F     MOVLP 0x1F
131:             LCD_Write_4Bit((Data << 4) & 0xF0);
1F0E  0020     MOVLB 0x0
1F0F  0828     MOVF Data, W
1F10  00A7     MOVWF reception
1F11  3003     MOVLW 0x3
1F12  35A7     LSLF reception, F
1F13  3EFF     ADDLW 0xFF
1F14  1D03     BTFSS STATUS, 0x2
1F15  2F12     GOTO 0x712
1F16  3527     LSLF reception, W
1F17  39F0     ANDLW 0xF0
1F18  319E     MOVLP 0x1E
1F19  26D3     CALL 0x6D3
1F1A  319F     MOVLP 0x1F
132:           }
1F1B  0008     RETURN
133:           
134:           void LCD_Write_String(char* Str)
135:           {
136:               for(int i=0; Str[i]!='\0'; i++)
1FE1  0020     MOVLB 0x0
1FE2  01AC     CLRF i
1FE3  01AD     CLRF 0x2D
1FE4  2FF4     GOTO 0x7F4
137:                  LCD_Write_Char(Str[i]); 
1FE5  0829     MOVF Str, W
1FE6  072C     ADDWF i, W
1FE7  0084     MOVWF FSR0
1FE8  082A     MOVF repOperateur, W
1FE9  3D2D     ADDWFC 0x2D, W
1FEA  0085     MOVWF FSR0H
1FEB  0800     MOVF INDF0, W
1FEC  319F     MOVLP 0x1F
1FED  2703     CALL 0x703
1FEE  319F     MOVLP 0x1F
1FEF  3001     MOVLW 0x1
1FF0  0020     MOVLB 0x0
1FF1  07AC     ADDWF i, F
1FF2  3000     MOVLW 0x0
1FF3  3DAD     ADDWFC 0x2D, F
1FF4  0829     MOVF Str, W
1FF5  072C     ADDWF i, W
1FF6  0084     MOVWF FSR0
1FF7  082A     MOVF repOperateur, W
1FF8  3D2D     ADDWFC 0x2D, W
1FF9  0085     MOVWF FSR0H
1FFA  0012     MOVIW FSR0++
1FFB  1D03     BTFSS STATUS, 0x2
1FFC  2FFE     GOTO 0x7FE
1FFD  2FFF     GOTO 0x7FF
1FFE  2FE5     GOTO 0x7E5
138:           }
1FFF  0008     RETURN
139:           
140:           void LCD_Set_Cursor(unsigned char ROW, unsigned char COL) 
1288  0020     MOVLB 0x0
1289  00AC     MOVWF i
141:           {    
142:             switch(ROW) 
128A  2AA3     GOTO 0x2A3
143:             {
144:               case 2:
145:                 LCD_CMD(0xC0 + COL-1);
128B  0829     MOVF Str, W
128C  3EBF     ADDLW 0xBF
128D  319E     MOVLP 0x1E
128E  26EB     CALL 0x6EB
128F  3192     MOVLP 0x12
146:                 break;
1290  2AB6     GOTO 0x2B6
147:               case 3:
148:                 LCD_CMD(0x94 + COL-1);
1291  0829     MOVF Str, W
1292  3E93     ADDLW 0x93
1293  319E     MOVLP 0x1E
1294  26EB     CALL 0x6EB
1295  3192     MOVLP 0x12
149:                 break;
1296  2AB6     GOTO 0x2B6
150:               case 4:
151:                 LCD_CMD(0xD4 + COL-1);
1297  0829     MOVF Str, W
1298  3ED3     ADDLW 0xD3
1299  319E     MOVLP 0x1E
129A  26EB     CALL 0x6EB
129B  3192     MOVLP 0x12
152:                 break;
129C  2AB6     GOTO 0x2B6
153:               // Case 1  
154:               default:
155:                 LCD_CMD(0x80 + COL-1);
129D  0829     MOVF Str, W
129E  3E7F     ADDLW 0x7F
129F  319E     MOVLP 0x1E
12A0  26EB     CALL 0x6EB
12A1  3192     MOVLP 0x12
156:             }
12A2  2AB6     GOTO 0x2B6
12A3  082C     MOVF i, W
12A4  00AA     MOVWF repOperateur
12A5  01AB     CLRF I2C_Add
12A6  082B     MOVF I2C_Add, W
12A7  3A00     XORLW 0x0
12A8  1903     BTFSC STATUS, 0x2
12A9  2AAB     GOTO 0x2AB
12AA  2A9D     GOTO 0x29D
12AB  082A     MOVF repOperateur, W
12AC  3A02     XORLW 0x2
12AD  1903     BTFSC STATUS, 0x2
12AE  2A8B     GOTO 0x28B
12AF  3A01     XORLW 0x1
12B0  1903     BTFSC STATUS, 0x2
12B1  2A91     GOTO 0x291
12B2  3A07     XORLW 0x7
12B3  1903     BTFSC STATUS, 0x2
12B4  2A97     GOTO 0x297
12B5  2A9D     GOTO 0x29D
157:           }
12B6  0008     RETURN
158:           
159:           void Backlight() 
160:           {
161:             BackLight_State = LCD_BACKLIGHT;
162:             IO_Expander_Write(0);
163:           }
164:           
165:           void noBacklight() 
166:           {
167:             BackLight_State = LCD_NOBACKLIGHT;
168:             IO_Expander_Write(0);
169:           }
170:           
171:           void LCD_SL()
172:           {
173:             LCD_CMD(0x18);
174:             __delay_us(40);
175:           }
176:           
177:           void LCD_SR()
178:           {
179:             LCD_CMD(0x1C);
180:             __delay_us(40);
181:           }
182:           
183:           void LCD_Clear()
184:           {
185:             LCD_CMD(0x01); 
1D46  3001     MOVLW 0x1
1D47  319E     MOVLP 0x1E
1D48  26EB     CALL 0x6EB
1D49  319D     MOVLP 0x1D
186:             __delay_us(40);
1D4A  3035     MOVLW 0x35
1D4B  0B89     DECFSZ WREG, F
1D4C  2D4B     GOTO 0x54B
1D4D  0000     NOP
187:           }
1D4E  0008     RETURN
---  C:/Users/Michel/AppData/Local/Temp/xcAspvg.s  ------------------------------------------------------
07FA  00FE     MOVWF btemp
07FB  0012     MOVIW FSR0++
07FC  001E     MOVWI FSR1++
07FD  0BFE     DECFSZ btemp, F
07FE  2FFB     GOTO 0x7FB
07FF  3400     RETLW 0x0
004C  0022     MOVLB 0x2
004D  319C     MOVLP 0x1C
0050  00EE     MOVWF BackLight_State
0051  302A     MOVLW 0x2A
0052  0084     MOVWF FSR0L
0053  3091     MOVLW 0x91
0054  0085     MOVWF FSR0H
0055  30A0     MOVLW 0xA0
0056  0086     MOVWF FSR1L
0057  3001     MOVLW 0x1
0058  0087     MOVWF FSR1H
0059  3028     MOVLW 0x28
005A  3187     MOVLP 0x7
005D  3065     MOVLW 0x65
005E  0084     MOVWF FSR0L
005F  309E     MOVLW 0x9E
0060  0085     MOVWF FSR0H
0061  3040     MOVLW 0x40
0062  0086     MOVWF FSR1L
0063  3002     MOVLW 0x2
0064  0087     MOVWF FSR1H
0065  3014     MOVLW 0x14
0066  3187     MOVLP 0x7
1CEC  0064     CLRWDT
1CED  0180     CLRF INDF0
1CEE  3101     ADDFSR 0, 1
1CEF  0B89     DECFSZ WREG, F
1CF0  2CED     GOTO 0x4ED
1CF1  3400     RETLW 0x0
0069  01FD     CLRF 0x17D
006A  0020     MOVLB 0x0
006B  01EA     CLRF eusartRxCount
006C  01EB     CLRF eusartRxTail
006D  01EC     CLRF eusartRxHead
006E  0021     MOVLB 0x1
006F  01E1     CLRF flags
0070  01E2     CLRF 0xE2
0071  01E3     CLRF i2c_add
0072  01E4     CLRF RS
0073  01E5     CLRF eusartTxBufferRemaining
0074  01E6     CLRF eusartTxTail
0075  3020     MOVLW 0x20
0076  0084     MOVWF FSR0L
0077  3001     MOVLW 0x1
0078  0085     MOVWF FSR0H
0079  302D     MOVLW 0x2D
007A  319C     MOVLP 0x1C
007D  30C8     MOVLW 0xC8
007E  0084     MOVWF FSR0L
007F  3001     MOVLW 0x1
0080  0085     MOVWF FSR0H
0081  301D     MOVLW 0x1D
0082  319C     MOVLP 0x1C
0085  3020     MOVLW 0x20
0086  0084     MOVWF FSR0L
0087  3002     MOVLW 0x2
0088  0085     MOVWF FSR0H
0089  3020     MOVLW 0x20
008A  319C     MOVLP 0x1C
008D  107E     BCF 0xFE, 0x0
008E  0020     MOVLB 0x0
008F  318E     MOVLP 0xE
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/strlen.c  ------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
6:             {
7:             	const char *a = s;
1F1C  0020     MOVLB 0x0
1F1D  0824     MOVF Data, W
1F1E  00A6     MOVWF Nibble
1F1F  0823     MOVF data, W
1F20  00A5     MOVWF txData
8:             	while(*s) {
1F21  2F26     GOTO 0x726
1F26  0823     MOVF data, W
1F27  0086     MOVWF FSR1
1F28  0824     MOVF Data, W
1F29  0087     MOVWF FSR1H
1F2A  0801     MOVF INDF1, W
1F2B  1D03     BTFSS STATUS, 0x2
1F2C  2F2E     GOTO 0x72E
1F2D  2F2F     GOTO 0x72F
1F2E  2F22     GOTO 0x722
9:             		s++;
1F22  3001     MOVLW 0x1
1F23  07A3     ADDWF data, F
1F24  3000     MOVLW 0x0
1F25  3DA4     ADDWFC Data, F
10:            	}
11:            	return (size_t)(s-a);
1F2F  0825     MOVF txData, W
1F30  0223     SUBWF data, W
1F31  00A3     MOVWF data
1F32  0826     MOVF Nibble, W
1F33  3B24     SUBWFB Data, W
1F34  00A4     MOVWF Data
12:            }
1F35  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/strcpy.c  ------------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
4:             {
5:             	const char *s = src;
1103  0020     MOVLB 0x0
1104  082A     MOVF repOperateur, W
1105  00B0     MOVWF s2
1106  0829     MOVF Str, W
1107  00AF     MOVWF s
6:             	char *d = dest;
1108  0828     MOVF Data, W
1109  00B2     MOVWF c
110A  0827     MOVF reception, W
110B  00B1     MOVWF d
7:             	while ((*d++ = *s++));
110C  0832     MOVF c, W
110D  00AC     MOVWF i
110E  0831     MOVF d, W
110F  00AB     MOVWF I2C_Add
1110  0AB1     INCF d, F
1111  1903     BTFSC STATUS, 0x2
1112  0AB2     INCF c, F
1113  082B     MOVF I2C_Add, W
1114  0086     MOVWF FSR1
1115  082C     MOVF i, W
1116  0087     MOVWF FSR1H
1117  0830     MOVF s2, W
1118  00AE     MOVWF fp
1119  082F     MOVF s, W
111A  00AD     MOVWF 0x2D
111B  0AAF     INCF s, F
111C  1903     BTFSC STATUS, 0x2
111D  0AB0     INCF s2, F
111E  082D     MOVF 0x2D, W
111F  0084     MOVWF FSR0
1120  082E     MOVF fp, W
1121  0085     MOVWF FSR0H
1122  0800     MOVF INDF0, W
1123  3FC0     MOVWI 0[FSR1]
1124  0889     MOVF WREG, F
1125  1D03     BTFSS STATUS, 0x2
1126  2928     GOTO 0x128
1127  2929     GOTO 0x129
1128  290C     GOTO 0x10C
8:             	return dest;
9:             }
1129  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/strcat.c  ------------------------------
1:             #include <string.h>
2:             
3:             char *strcat(char *restrict dest, const char *restrict src)
4:             {
5:             	strcpy(dest + strlen(dest), src);
1EA4  0020     MOVLB 0x0
1EA5  0834     MOVF counter, W
1EA6  00A4     MOVWF Data
1EA7  0833     MOVF dest, W
1EA8  00A3     MOVWF data
1EA9  319F     MOVLP 0x1F
1EAA  271C     CALL 0x71C
1EAB  319E     MOVLP 0x1E
1EAC  0020     MOVLB 0x0
1EAD  0823     MOVF data, W
1EAE  0733     ADDWF dest, W
1EAF  00A7     MOVWF reception
1EB0  0824     MOVF Data, W
1EB1  3D34     ADDWFC counter, W
1EB2  00A8     MOVWF Data
1EB3  0836     MOVF buf, W
1EB4  00AA     MOVWF repOperateur
1EB5  0835     MOVF src, W
1EB6  00A9     MOVWF Str
1EB7  3191     MOVLP 0x11
1EB8  2103     CALL 0x103
1EB9  319E     MOVLP 0x1E
6:             	return dest;
7:             }
1EBA  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/printf.c  ------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
1E8E  30AF     MOVLW 0xAF
1E8F  0020     MOVLB 0x0
1E90  00E9     MOVWF 0x69
1E91  0869     MOVF 0x69, W
1E92  0021     MOVLB 0x1
1E93  00AF     MOVWF ap
10:            	ret = vfprintf(stdout, fmt, ap);
1E94  082E     MOVF 0xAE, W
1E95  0020     MOVLB 0x0
1E96  00E5     MOVWF 0x65
1E97  0021     MOVLB 0x1
1E98  082D     MOVF fmt, W
1E99  0020     MOVLB 0x0
1E9A  00E4     MOVWF fmt
1E9B  30AF     MOVLW 0xAF
1E9C  00E9     MOVWF 0x69
1E9D  0869     MOVF 0x69, W
1E9E  00E6     MOVWF ap
1E9F  3000     MOVLW 0x0
1EA0  3192     MOVLP 0x12
1EA1  22E6     CALL 0x2E6
1EA2  319E     MOVLP 0x1E
11:            	va_end(ap);
12:            	return ret;
13:            }
1EA3  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/nf_sprintf.c  --------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
0800  0021     MOVLB 0x1
0801  00B4     MOVWF s
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
0802  30AF     MOVLW 0xAF
0803  0020     MOVLB 0x0
0804  00E9     MOVWF 0x69
0805  0869     MOVF 0x69, W
0806  0021     MOVLB 0x1
0807  00B3     MOVWF ap
16:            	f.buffer = s;
0808  0834     MOVF s, W
0809  0020     MOVLB 0x0
080A  00E9     MOVWF 0x69
080B  0869     MOVF 0x69, W
080C  0021     MOVLB 0x1
080D  00B5     MOVWF f
17:            	f.count = 0;
080E  01B6     CLRF reception
080F  01B7     CLRF repOperateur
18:            	f.limit = 0;
0810  01B8     CLRF autom
0811  01B9     CLRF 0xB9
19:            	ret = vfprintf(&f, fmt, ap);
0812  082E     MOVF 0xAE, W
0813  0020     MOVLB 0x0
0814  00E5     MOVWF 0x65
0815  0021     MOVLB 0x1
0816  082D     MOVF fmt, W
0817  0020     MOVLB 0x0
0818  00E4     MOVWF fmt
0819  30B3     MOVLW 0xB3
081A  00E9     MOVWF 0x69
081B  0869     MOVF 0x69, W
081C  00E6     MOVWF ap
081D  30B5     MOVLW 0xB5
081E  3192     MOVLP 0x12
081F  22E6     CALL 0x2E6
0820  3188     MOVLP 0x8
0821  0020     MOVLB 0x0
0822  0865     MOVF 0x65, W
0823  0021     MOVLB 0x1
0824  00B2     MOVWF testVoy
0825  0020     MOVLB 0x0
0826  0864     MOVF fmt, W
0827  0021     MOVLB 0x1
0828  00B1     MOVWF ret
20:            	s[f.count] = '\0';
0829  0836     MOVF reception, W
082A  0734     ADDWF s, W
082B  0020     MOVLB 0x0
082C  00E9     MOVWF 0x69
082D  0869     MOVF 0x69, W
082E  0086     MOVWF FSR1
082F  3002     MOVLW 0x2
0830  0087     MOVWF FSR1H
0831  0181     CLRF INDF1
21:            	va_end(ap);
22:            	return ret;
0832  0021     MOVLB 0x1
0833  0832     MOVF testVoy, W
0834  00AE     MOVWF 0xAE
0835  0831     MOVF ret, W
0836  00AD     MOVWF fmt
23:            }
0837  0008     RETURN
24:            
25:            #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/nf_fputs.c  ----------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
1152  0020     MOVLB 0x0
1153  00B5     MOVWF src
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1154  01B3     CLRF dest
1155  01B4     CLRF counter
14:                while ((c = *(s + i))) {
1156  296A     GOTO 0x16A
116A  0833     MOVF dest, W
116B  0735     ADDWF src, W
116C  00AF     MOVWF s
116D  082F     MOVF s, W
116E  0086     MOVWF FSR1
116F  3002     MOVLW 0x2
1170  0087     MOVWF FSR1H
1171  0801     MOVF INDF1, W
1172  00B0     MOVWF s2
1173  0830     MOVF s2, W
1174  00B2     MOVWF c
1175  0832     MOVF c, W
1176  1D03     BTFSS STATUS, 0x2
1177  2979     GOTO 0x179
1178  297A     GOTO 0x17A
1179  2957     GOTO 0x157
15:            	fputc(c,fp);
1157  0832     MOVF c, W
1158  00AF     MOVWF s
1159  01B0     CLRF s2
115A  082F     MOVF s, W
115B  00A6     MOVWF Nibble
115C  0830     MOVF s2, W
115D  00A7     MOVWF reception
115E  082E     MOVF fp, W
115F  00B1     MOVWF d
1160  0831     MOVF d, W
1161  00A8     MOVWF Data
1162  3195     MOVLP 0x15
1163  2514     CALL 0x514
1164  3191     MOVLP 0x11
16:                    ++i;
1165  3001     MOVLW 0x1
1166  0020     MOVLB 0x0
1167  07B3     ADDWF dest, F
1168  3000     MOVLW 0x0
1169  3DB4     ADDWFC counter, F
116A  0833     MOVF dest, W
116B  0735     ADDWF src, W
116C  00AF     MOVWF s
116D  082F     MOVF s, W
116E  0086     MOVWF FSR1
116F  3002     MOVLW 0x2
1170  0087     MOVWF FSR1H
1171  0801     MOVF INDF1, W
1172  00B0     MOVWF s2
1173  0830     MOVF s2, W
1174  00B2     MOVWF c
1175  0832     MOVF c, W
1176  1D03     BTFSS STATUS, 0x2
1177  2979     GOTO 0x179
1178  297A     GOTO 0x17A
1179  2957     GOTO 0x157
17:                }
18:                return i;
19:            }
117A  0008     RETURN
20:            
21:            #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/nf_fputc.c  ----------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
1514  0020     MOVLB 0x0
1515  0828     MOVF Data, W
1516  1903     BTFSC STATUS, 0x2
1517  2D19     GOTO 0x519
1518  2D1A     GOTO 0x51A
1519  2D1F     GOTO 0x51F
151A  0828     MOVF Data, W
151B  1D03     BTFSS STATUS, 0x2
151C  2D1E     GOTO 0x51E
151D  2D1F     GOTO 0x51F
151E  2D24     GOTO 0x524
13:                    putch((char)c);
151F  0826     MOVF Nibble, W
1520  319C     MOVLP 0x1C
1521  24F9     CALL 0x4F9
1522  3195     MOVLP 0x15
14:                } else {
1523  2D65     GOTO 0x565
15:            		if((fp->limit == 0) || (fp->count < fp->limit)) {
1524  0828     MOVF Data, W
1525  3E03     ADDLW 0x3
1526  0086     MOVWF FSR1
1527  0187     CLRF FSR1H
1528  0016     MOVIW FSR1++
1529  0401     IORWF INDF1, W
152A  1903     BTFSC STATUS, 0x2
152B  2D2D     GOTO 0x52D
152C  2D2E     GOTO 0x52E
152D  2D4B     GOTO 0x54B
152E  0828     MOVF Data, W
152F  3E03     ADDLW 0x3
1530  0086     MOVWF FSR1
1531  0187     CLRF FSR1H
1532  3F40     MOVIW 0[FSR1]
1533  00A9     MOVWF Str
1534  3F41     MOVIW 1[FSR1]
1535  00AA     MOVWF repOperateur
1536  0A28     INCF Data, W
1537  0086     MOVWF FSR1
1538  0187     CLRF FSR1H
1539  3F40     MOVIW 0[FSR1]
153A  00AB     MOVWF I2C_Add
153B  3F41     MOVIW 1[FSR1]
153C  00AC     MOVWF i
153D  082C     MOVF i, W
153E  3A80     XORLW 0x80
153F  00AD     MOVWF 0x2D
1540  082A     MOVF repOperateur, W
1541  3A80     XORLW 0x80
1542  022D     SUBWF 0x2D, W
1543  1D03     BTFSS STATUS, 0x2
1544  2D47     GOTO 0x547
1545  0829     MOVF Str, W
1546  022B     SUBWF I2C_Add, W
1547  1803     BTFSC STATUS, 0x0
1548  2D4A     GOTO 0x54A
1549  2D4B     GOTO 0x54B
154A  2D65     GOTO 0x565
16:            #pragma warning push
17:            #pragma warning disable 1498
18:            			fp->buffer[fp->count] = (char)c;
154B  0020     MOVLB 0x0
154C  0826     MOVF Nibble, W
154D  00A9     MOVWF Str
154E  0828     MOVF Data, W
154F  0086     MOVWF FSR1
1550  0187     CLRF FSR1H
1551  0A28     INCF Data, W
1552  0084     MOVWF FSR0
1553  0185     CLRF FSR0H
1554  0800     MOVF INDF0, W
1555  0701     ADDWF INDF1, W
1556  00AA     MOVWF repOperateur
1557  082A     MOVF repOperateur, W
1558  0086     MOVWF FSR1
1559  3002     MOVLW 0x2
155A  0087     MOVWF FSR1H
155B  0829     MOVF Str, W
155C  0081     MOVWF INDF1
19:            #pragma warning pop
20:            			++fp->count;
155D  0A28     INCF Data, W
155E  0086     MOVWF FSR1
155F  0187     CLRF FSR1H
1560  3001     MOVLW 0x1
1561  0781     ADDWF INDF1, F
1562  3141     ADDFSR 1, 1
1563  1803     BTFSC STATUS, 0x0
1564  0A81     INCF INDF1, F
21:            		}
22:                }
23:                return (unsigned char)c;
24:            }
1565  0008     RETURN
25:            
26:            #endif
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/doprnt.c  ------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
1617  0020     MOVLB 0x0
1618  00BE     MOVWF fp
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
1619  0021     MOVLB 0x1
161A  1C61     BTFSS flags, 0x0
161B  2E1D     GOTO 0x61D
161C  2E1E     GOTO 0x61E
161D  2E27     GOTO 0x627
78:                    fputs((const char *)buf, fp);
161E  0020     MOVLB 0x0
161F  083E     MOVF fp, W
1620  00B9     MOVWF 0x39
1621  0839     MOVF 0x39, W
1622  00AE     MOVWF fp
1623  0836     MOVF buf, W
1624  3191     MOVLP 0x11
1625  2152     CALL 0x152
1626  3196     MOVLP 0x16
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
1627  0020     MOVLB 0x0
1628  1BB8     BTFSC 0x38, 0x7
1629  2E2B     GOTO 0x62B
162A  2E2C     GOTO 0x62C
162B  2E31     GOTO 0x631
162C  0838     MOVF 0x38, W
162D  00BD     MOVWF 0x3D
162E  0837     MOVF p, W
162F  00BC     MOVWF w
1630  2E33     GOTO 0x633
1631  01BC     CLRF w
1632  01BD     CLRF 0x3D
83:                i = 0;
1633  01BA     CLRF i
1634  01BB     CLRF 0x3B
84:                while (i < w) {
1635  2E47     GOTO 0x647
1647  083B     MOVF 0x3B, W
1648  3A80     XORLW 0x80
1649  00B9     MOVWF 0x39
164A  083D     MOVF 0x3D, W
164B  3A80     XORLW 0x80
164C  0239     SUBWF 0x39, W
164D  1D03     BTFSS STATUS, 0x2
164E  2E51     GOTO 0x651
164F  083C     MOVF w, W
1650  023A     SUBWF i, W
1651  1C03     BTFSS STATUS, 0x0
1652  2E54     GOTO 0x654
1653  2E55     GOTO 0x655
1654  2E36     GOTO 0x636
85:                    fputc(' ', fp);
1636  3020     MOVLW 0x20
1637  0020     MOVLB 0x0
1638  00A6     MOVWF Nibble
1639  3000     MOVLW 0x0
163A  00A7     MOVWF reception
163B  083E     MOVF fp, W
163C  00B9     MOVWF 0x39
163D  0839     MOVF 0x39, W
163E  00A8     MOVWF Data
163F  3195     MOVLP 0x15
1640  2514     CALL 0x514
1641  3196     MOVLP 0x16
86:                    ++i;
1642  3001     MOVLW 0x1
1643  0020     MOVLB 0x0
1644  07BA     ADDWF i, F
1645  3000     MOVLW 0x0
1646  3DBB     ADDWFC 0x3B, F
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
1655  0021     MOVLB 0x1
1656  1861     BTFSC flags, 0x0
1657  2E59     GOTO 0x659
1658  2E5A     GOTO 0x65A
1659  2E63     GOTO 0x663
91:                    fputs((const char *)buf, fp);
165A  0020     MOVLB 0x0
165B  083E     MOVF fp, W
165C  00B9     MOVWF 0x39
165D  0839     MOVF 0x39, W
165E  00AE     MOVWF fp
165F  0836     MOVF buf, W
1660  3191     MOVLP 0x11
1661  2152     CALL 0x152
1662  3196     MOVLP 0x16
92:                }
93:            
94:                return (int)(strlen(buf) + (size_t)w);
1663  0020     MOVLB 0x0
1664  0836     MOVF buf, W
1665  00A3     MOVWF data
1666  3002     MOVLW 0x2
1667  00A4     MOVWF Data
1668  319F     MOVLP 0x1F
1669  271C     CALL 0x71C
166A  3196     MOVLP 0x16
166B  0020     MOVLB 0x0
166C  083C     MOVF w, W
166D  0723     ADDWF data, W
166E  00B6     MOVWF buf
166F  083D     MOVF 0x3D, W
1670  3D24     ADDWFC Data, W
1671  00B7     MOVWF p
95:            }
1672  0008     RETURN
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? (int)'0' + d : (int)'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = (char)d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
265:           
266:               /* Left justify ? Put out character */
267:               if (flags & MINUS_FLAG) {
268:                   fputc(c, fp);
269:               }
270:               /* Put out padding */
271:               w = (w < 0) ? 0 : w;
272:               l = 0;
273:               while (l < w) {
274:                   fputc(' ', fp);
275:                   ++l;
276:               }
277:               /* Right justify ? Put out string */
278:               if (!(flags & MINUS_FLAG)) {
279:                   fputc(c, fp);
280:               }
281:           
282:               return l+1;
283:           }
284:           #endif
285:           
286:           #ifdef _VFPF_D
287:           static _INLINE int dtoa(FILE *fp, long long d)
0C9C  0020     MOVLB 0x0
0C9D  00CA     MOVWF fp
288:           {
289:               int i, p, s, w;
290:               long long n;
291:           
292:               /* Record sign, get absolute value */
293:               n = d;
0C9E  083F     MOVF d, W
0C9F  00D3     MOVWF n
0CA0  0840     MOVF 0x40, W
0CA1  00D4     MOVWF 0x54
0CA2  0841     MOVF 0x41, W
0CA3  00D5     MOVWF 0x55
0CA4  0842     MOVF 0x42, W
0CA5  00D6     MOVWF 0x56
0CA6  0843     MOVF 0x43, W
0CA7  00D7     MOVWF 0x57
0CA8  0844     MOVF 0x44, W
0CA9  00D8     MOVWF 0x58
0CAA  0845     MOVF 0x45, W
0CAB  00D9     MOVWF 0x59
0CAC  0846     MOVF 0x46, W
0CAD  00DA     MOVWF 0x5A
294:               s = n < 0 ? 1 : 0;
0CAE  3053     MOVLW 0x53
0CAF  0086     MOVWF FSR1
0CB0  3000     MOVLW 0x0
0CB1  0087     MOVWF FSR1H
0CB2  3F47     MOVIW 7[FSR1]
0CB3  00C7     MOVWF 0x47
0CB4  1BC7     BTFSC 0x47, 0x7
0CB5  2CB7     GOTO 0x4B7
0CB6  2CB9     GOTO 0x4B9
0CB7  3001     MOVLW 0x1
0CB8  2CBA     GOTO 0x4BA
0CB9  3000     MOVLW 0x0
0CBA  0020     MOVLB 0x0
0CBB  00C8     MOVWF 0x48
0CBC  01C9     CLRF 0x49
0CBD  0848     MOVF 0x48, W
0CBE  00D1     MOVWF s
0CBF  0849     MOVF 0x49, W
0CC0  00D2     MOVWF 0x52
295:               if (s) {
0CC1  0851     MOVF s, W
0CC2  0452     IORWF 0x52, W
0CC3  1903     BTFSC STATUS, 0x2
0CC4  2CC6     GOTO 0x4C6
0CC5  2CC7     GOTO 0x4C7
0CC6  2CE5     GOTO 0x4E5
296:                   n = -n;
0CC7  09D3     COMF n, F
0CC8  09D4     COMF 0x54, F
0CC9  09D5     COMF 0x55, F
0CCA  09D6     COMF 0x56, F
0CCB  09D7     COMF 0x57, F
0CCC  09D8     COMF 0x58, F
0CCD  09D9     COMF 0x59, F
0CCE  09DA     COMF 0x5A, F
0CCF  0AD3     INCF n, F
0CD0  1D03     BTFSS STATUS, 0x2
0CD1  2CE5     GOTO 0x4E5
0CD2  0AD4     INCF 0x54, F
0CD3  1D03     BTFSS STATUS, 0x2
0CD4  2CE5     GOTO 0x4E5
0CD5  0AD5     INCF 0x55, F
0CD6  1D03     BTFSS STATUS, 0x2
0CD7  2CE5     GOTO 0x4E5
0CD8  0AD6     INCF 0x56, F
0CD9  1D03     BTFSS STATUS, 0x2
0CDA  2CE5     GOTO 0x4E5
0CDB  0AD7     INCF 0x57, F
0CDC  1D03     BTFSS STATUS, 0x2
0CDD  2CE5     GOTO 0x4E5
0CDE  0AD8     INCF 0x58, F
0CDF  1D03     BTFSS STATUS, 0x2
0CE0  2CE5     GOTO 0x4E5
0CE1  0AD9     INCF 0x59, F
0CE2  1D03     BTFSS STATUS, 0x2
0CE3  2CE5     GOTO 0x4E5
0CE4  0ADA     INCF 0x5A, F
297:               }
298:           
299:               /* Adjust flags, precision, width */
300:               if (!(prec < 0)) {
0CE5  0022     MOVLB 0x2
0CE6  1BBD     BTFSC 0x13D, 0x7
0CE7  2CE9     GOTO 0x4E9
0CE8  2CEA     GOTO 0x4EA
0CE9  2CEF     GOTO 0x4EF
301:                   flags &= ~ZERO_FLAG;
0CEA  30FD     MOVLW 0xFD
0CEB  0021     MOVLB 0x1
0CEC  05E1     ANDWF flags, F
0CED  30FF     MOVLW 0xFF
0CEE  05E2     ANDWF 0xE2, F
302:               }
0CEF  0022     MOVLB 0x2
0CF0  083D     MOVF 0x13D, W
0CF1  3A80     XORLW 0x80
0CF2  0020     MOVLB 0x0
0CF3  00C7     MOVWF 0x47
0CF4  3080     MOVLW 0x80
0CF5  0247     SUBWF 0x47, W
303:               p = (0 < prec) ? prec : 1;
0CF6  1D03     BTFSS STATUS, 0x2
0CF7  2CFB     GOTO 0x4FB
0CF8  3001     MOVLW 0x1
0CF9  0022     MOVLB 0x2
0CFA  023C     SUBWF prec, W
0CFB  1803     BTFSC STATUS, 0x0
0CFC  2CFE     GOTO 0x4FE
0CFD  2CFF     GOTO 0x4FF
0CFE  2D05     GOTO 0x505
0CFF  3001     MOVLW 0x1
0D00  0020     MOVLB 0x0
0D01  00CD     MOVWF p
0D02  3000     MOVLW 0x0
0D03  00CE     MOVWF 0x4E
0D04  2D0D     GOTO 0x50D
0D05  0022     MOVLB 0x2
0D06  083D     MOVF 0x13D, W
0D07  0020     MOVLB 0x0
0D08  00CE     MOVWF 0x4E
0D09  0022     MOVLB 0x2
0D0A  083C     MOVF prec, W
0D0B  0020     MOVLB 0x0
0D0C  00CD     MOVWF p
304:               w = width;
0D0D  0022     MOVLB 0x2
0D0E  083B     MOVF 0x13B, W
0D0F  0020     MOVLB 0x0
0D10  00D0     MOVWF 0x50
0D11  0022     MOVLB 0x2
0D12  083A     MOVF width, W
0D13  0020     MOVLB 0x0
0D14  00CF     MOVWF w
305:               if (s || (flags & PLUS_FLAG)) {
0D15  0851     MOVF s, W
0D16  0452     IORWF 0x52, W
0D17  1D03     BTFSS STATUS, 0x2
0D18  2D1A     GOTO 0x51A
0D19  2D1B     GOTO 0x51B
0D1A  2D20     GOTO 0x520
0D1B  0021     MOVLB 0x1
0D1C  1D61     BTFSS flags, 0x2
0D1D  2D1F     GOTO 0x51F
0D1E  2D20     GOTO 0x520
0D1F  2D25     GOTO 0x525
306:                   --w;
0D20  30FF     MOVLW 0xFF
0D21  0020     MOVLB 0x0
0D22  07CF     ADDWF w, F
0D23  30FF     MOVLW 0xFF
0D24  3DD0     ADDWFC 0x50, F
307:               }
308:           
309:               /* Convert to decimal, possibly filling on the left with zeroes */
310:               i = sizeof(dbuf) - 1;
0D25  301F     MOVLW 0x1F
0D26  0020     MOVLB 0x0
0D27  00DB     MOVWF i
0D28  3000     MOVLW 0x0
0D29  00DC     MOVWF 0x5C
311:               dbuf[i] = '\0';
0D2A  0024     MOVLB 0x4
0D2B  01BF     CLRF 0x23F
312:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
0D2C  2D96     GOTO 0x596
0D9C  1D03     BTFSS STATUS, 0x2
0D9D  2DA0     GOTO 0x5A0
0D9E  3001     MOVLW 0x1
0D9F  025B     SUBWF 0x25B, W
0DA0  1C03     BTFSS STATUS, 0x0
0DA1  2DA3     GOTO 0x5A3
0DA2  2DA4     GOTO 0x5A4
0DA3  2DD1     GOTO 0x5D1
0DA4  0020     MOVLB 0x0
0DA5  0853     MOVF n, W
0DA6  0454     IORWF 0x54, W
0DA7  0455     IORWF 0x55, W
0DA8  0456     IORWF 0x56, W
0DA9  0457     IORWF 0x57, W
0DAA  0458     IORWF 0x58, W
0DAB  0459     IORWF 0x59, W
0DAC  045A     IORWF 0x5A, W
0DAD  1D03     BTFSS STATUS, 0x2
0DAE  2DB0     GOTO 0x5B0
0DAF  2DB1     GOTO 0x5B1
0DB0  2D2D     GOTO 0x52D
0DB1  084E     MOVF 0x4E, W
0DB2  3A80     XORLW 0x80
0DB3  00C7     MOVWF 0x47
0DB4  3080     MOVLW 0x80
0DB5  0247     SUBWF 0x47, W
0DB6  1D03     BTFSS STATUS, 0x2
0DB7  2DBA     GOTO 0x5BA
0DB8  3001     MOVLW 0x1
0DB9  024D     SUBWF p, W
0DBA  1803     BTFSC STATUS, 0x0
0DBB  2DBD     GOTO 0x5BD
0DBC  2DBE     GOTO 0x5BE
0DBD  2D2D     GOTO 0x52D
0DBE  0020     MOVLB 0x0
0DBF  0850     MOVF 0x50, W
0DC0  3A80     XORLW 0x80
0DC1  00C7     MOVWF 0x47
0DC2  3080     MOVLW 0x80
0DC3  0247     SUBWF 0x47, W
0DC4  1D03     BTFSS STATUS, 0x2
0DC5  2DC8     GOTO 0x5C8
0DC6  3001     MOVLW 0x1
0DC7  024F     SUBWF w, W
0DC8  1C03     BTFSS STATUS, 0x0
0DC9  2DCB     GOTO 0x5CB
0DCA  2DCC     GOTO 0x5CC
0DCB  2DD1     GOTO 0x5D1
0DCC  0021     MOVLB 0x1
0DCD  18E1     BTFSC flags, 0x1
0DCE  2DD0     GOTO 0x5D0
0DCF  2DD1     GOTO 0x5D1
0DD0  2D2D     GOTO 0x52D
313:                   --i;
0D2D  30FF     MOVLW 0xFF
0D2E  0020     MOVLB 0x0
0D2F  07DB     ADDWF i, F
0D30  30FF     MOVLW 0xFF
0D31  3DDC     ADDWFC 0x5C, F
314:                   dbuf[i] = (char)((int)'0' + abs(n % 10));
0D32  300A     MOVLW 0xA
0D33  00A3     MOVWF data
0D34  01A4     CLRF Data
0D35  01A5     CLRF txData
0D36  01A6     CLRF Nibble
0D37  01A7     CLRF reception
0D38  01A8     CLRF Data
0D39  01A9     CLRF Str
0D3A  01AA     CLRF repOperateur
0D3B  0853     MOVF n, W
0D3C  00AB     MOVWF I2C_Add
0D3D  0854     MOVF 0x54, W
0D3E  00AC     MOVWF i
0D3F  0855     MOVF 0x55, W
0D40  00AD     MOVWF 0x2D
0D41  0856     MOVF 0x56, W
0D42  00AE     MOVWF fp
0D43  0857     MOVF 0x57, W
0D44  00AF     MOVWF s
0D45  0858     MOVF 0x58, W
0D46  00B0     MOVWF s2
0D47  0859     MOVF 0x59, W
0D48  00B1     MOVWF d
0D49  085A     MOVF 0x5A, W
0D4A  00B2     MOVWF c
0D4B  3188     MOVLP 0x8
0D4C  2038     CALL 0x38
0D4D  318C     MOVLP 0xC
0D4E  0020     MOVLB 0x0
0D4F  0824     MOVF Data, W
0D50  00B7     MOVWF p
0D51  0823     MOVF data, W
0D52  00B6     MOVWF buf
0D53  319F     MOVLP 0x1F
0D54  2787     CALL 0x787
0D55  318C     MOVLP 0xC
0D56  0020     MOVLB 0x0
0D57  0836     MOVF buf, W
0D58  3E30     ADDLW 0x30
0D59  00C7     MOVWF 0x47
0D5A  085B     MOVF i, W
0D5B  3E20     ADDLW 0x20
0D5C  0086     MOVWF FSR1
0D5D  3002     MOVLW 0x2
0D5E  0087     MOVWF FSR1H
0D5F  0847     MOVF 0x47, W
0D60  0081     MOVWF INDF1
315:                   --p;
0D61  30FF     MOVLW 0xFF
0D62  07CD     ADDWF p, F
0D63  30FF     MOVLW 0xFF
0D64  3DCE     ADDWFC 0x4E, F
316:                   --w;
0D65  30FF     MOVLW 0xFF
0D66  07CF     ADDWF w, F
0D67  30FF     MOVLW 0xFF
0D68  3DD0     ADDWFC 0x50, F
317:                   n = n / 10;
0D69  300A     MOVLW 0xA
0D6A  00A3     MOVWF data
0D6B  01A4     CLRF Data
0D6C  01A5     CLRF txData
0D6D  01A6     CLRF Nibble
0D6E  01A7     CLRF reception
0D6F  01A8     CLRF Data
0D70  01A9     CLRF Str
0D71  01AA     CLRF repOperateur
0D72  0853     MOVF n, W
0D73  00AB     MOVWF I2C_Add
0D74  0854     MOVF 0x54, W
0D75  00AC     MOVWF i
0D76  0855     MOVF 0x55, W
0D77  00AD     MOVWF 0x2D
0D78  0856     MOVF 0x56, W
0D79  00AE     MOVWF fp
0D7A  0857     MOVF 0x57, W
0D7B  00AF     MOVWF s
0D7C  0858     MOVF 0x58, W
0D7D  00B0     MOVWF s2
0D7E  0859     MOVF 0x59, W
0D7F  00B1     MOVWF d
0D80  085A     MOVF 0x5A, W
0D81  00B2     MOVWF c
0D82  3189     MOVLP 0x9
0D83  2125     CALL 0x125
0D84  318C     MOVLP 0xC
0D85  0020     MOVLB 0x0
0D86  0823     MOVF data, W
0D87  00D3     MOVWF n
0D88  0824     MOVF Data, W
0D89  00D4     MOVWF 0x54
0D8A  0825     MOVF txData, W
0D8B  00D5     MOVWF 0x55
0D8C  0826     MOVF Nibble, W
0D8D  00D6     MOVWF 0x56
0D8E  0827     MOVF reception, W
0D8F  00D7     MOVWF 0x57
0D90  0828     MOVF Data, W
0D91  00D8     MOVWF 0x58
0D92  0829     MOVF Str, W
0D93  00D9     MOVWF 0x59
0D94  082A     MOVF repOperateur, W
0D95  00DA     MOVWF 0x5A
318:               }
0D96  0020     MOVLB 0x0
0D97  085C     MOVF 0x5C, W
0D98  3A80     XORLW 0x80
0D99  00C7     MOVWF 0x47
0D9A  3080     MOVLW 0x80
0D9B  0247     SUBWF 0x47, W
319:           
320:               /* Display sign if required */
321:               if (s || (flags & PLUS_FLAG)) {
0DD1  0020     MOVLB 0x0
0DD2  0851     MOVF s, W
0DD3  0452     IORWF 0x52, W
0DD4  1D03     BTFSS STATUS, 0x2
0DD5  2DD7     GOTO 0x5D7
0DD6  2DD8     GOTO 0x5D8
0DD7  2DDD     GOTO 0x5DD
0DD8  0021     MOVLB 0x1
0DD9  1D61     BTFSS flags, 0x2
0DDA  2DDC     GOTO 0x5DC
0DDB  2DDD     GOTO 0x5DD
0DDC  2DFA     GOTO 0x5FA
322:                   --i;
0DDD  30FF     MOVLW 0xFF
0DDE  0020     MOVLB 0x0
0DDF  07DB     ADDWF i, F
0DE0  30FF     MOVLW 0xFF
0DE1  3DDC     ADDWFC 0x5C, F
323:                   dbuf[i] = s ? '-' : '+';
0DE2  0851     MOVF s, W
0DE3  0452     IORWF 0x52, W
0DE4  1D03     BTFSS STATUS, 0x2
0DE5  2DE7     GOTO 0x5E7
0DE6  2DE8     GOTO 0x5E8
0DE7  2DED     GOTO 0x5ED
0DE8  302B     MOVLW 0x2B
0DE9  00CB     MOVWF 0x4B
0DEA  3000     MOVLW 0x0
0DEB  00CC     MOVWF 0x4C
0DEC  2DF1     GOTO 0x5F1
0DED  302D     MOVLW 0x2D
0DEE  00CB     MOVWF 0x4B
0DEF  3000     MOVLW 0x0
0DF0  00CC     MOVWF 0x4C
0DF1  084B     MOVF 0x4B, W
0DF2  00C7     MOVWF 0x47
0DF3  085B     MOVF i, W
0DF4  3E20     ADDLW 0x20
0DF5  0086     MOVWF FSR1
0DF6  3002     MOVLW 0x2
0DF7  0087     MOVWF FSR1H
0DF8  0847     MOVF 0x47, W
0DF9  0081     MOVWF INDF1
324:               }
325:           
326:               /* Put out padded string */
327:               return pad(fp, &dbuf[i], w);
0DFA  0020     MOVLB 0x0
0DFB  085B     MOVF i, W
0DFC  3E20     ADDLW 0x20
0DFD  00C7     MOVWF 0x47
0DFE  0847     MOVF 0x47, W
0DFF  00B6     MOVWF buf
0E00  0850     MOVF 0x50, W
0E01  00B8     MOVWF 0x38
0E02  084F     MOVF w, W
0E03  00B7     MOVWF p
0E04  084A     MOVF fp, W
0E05  3196     MOVLP 0x16
0E06  2617     CALL 0x617
0E07  318C     MOVLP 0xC
0E08  0020     MOVLB 0x0
0E09  0837     MOVF p, W
0E0A  00C0     MOVWF 0x40
0E0B  0836     MOVF buf, W
0E0C  00BF     MOVWF d
328:           }
0E0D  0008     RETURN
329:           #endif
330:           
331:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
332:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
333:           {
334:               char mode, nmode;
335:               int d, e, i, m, n, ne, p, pp, sign, t, w;
336:               long double g, h, l, ou, u;
337:           
338:               /* Record sign, get absolute value */
339:               sign = 0;
340:               g = f;
341:               if (g < 0.0) {
342:                   sign = 1;
343:                   g = -g;
344:               }
345:           
346:               /* Print sign */
347:               n = 0;
348:               w = width;
349:               if (sign || (flags & PLUS_FLAG)) {
350:                   dbuf[n] = sign ? '-' : '+';
351:                   ++n;
352:                   --w;
353:               }
354:           
355:               /* Catch infinities, NaNs here */
356:               if (isinf(g)) {
357:                   if (isupper((int)c)) {
358:                       strcpy(&dbuf[n], "INF");
359:                   } else {
360:                       strcpy(&dbuf[n], "inf");
361:                   }
362:                   w -= CSTRLEN("inf");
363:                   return pad(fp, &dbuf[0], w);
364:               }
365:               if (isnan(g)) {
366:                   if (isupper((int)c)) {
367:                       strcpy(&dbuf[n], "NAN");
368:                   } else {
369:                       strcpy(&dbuf[n], "nan");
370:                   }
371:                   w -= CSTRLEN("inf");
372:                   return pad(fp, &dbuf[0], w);
373:               }
374:           
375:               /* First find the largest power of 10 not larger than number to print */
376:               u = 1.0;
377:               e = 0;
378:               if (!(g == 0.0)) {
379:                   while (!(g < (u*10.0))) {
380:                       u = u*10.0;
381:                       ++e;
382:                   }
383:                   while (g < u) {
384:                       u = u/10.0;
385:                       --e;
386:                   }
387:               }
388:           
389:               /* Get mode, precision */
390:               mode = (char)tolower((int)c);
391:               nmode = mode;
392:               if (mode == 'g') {
393:           		if (prec == 0) {
394:           			prec = 1;
395:           		}
396:                   p = (0 < prec) ? prec : 6;
397:               } else {
398:                   p = (prec < 0) ? 6 : prec;
399:               }
400:           
401:               /* Choose e or f mode from g mode */
402:               if (mode == 'g') {
403:                   if (!(e < -4) && !((p - 1) < e)) {
404:                       nmode = 'f';
405:                   } else {
406:                       nmode = 'e';
407:                   }
408:               }
409:           
410:               /* Decimal places or significant digits */
411:               m = p;
412:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
413:                   ++m;
414:               }
415:           
416:               /* Adjust starting exponent, string length for 'f' conversions */
417:               if (nmode == 'f') {
418:                   if (e < 0) {
419:                       u = 1.0;
420:                       e = 0;
421:                   }
422:                   if (!(mode == 'g')) {
423:                       m += e;
424:                   }
425:               }
426:           
427:               /* Go through the conversion once to get to the rounding step */
428:               i = 0;
429:               h = g;
430:               ou = u;
431:               while (i < m) {
432:                   l = floor(h/u);
433:                   d = (int)l;
434:                   h -= l*u;
435:                   u = u/10.0;
436:                   ++i;
437:               }
438:               
439:               /* Remainder >= halfway ? */
440:               l = u*5.0;
441:               if (h < l) {
442:                   l = 0.0;
443:               } else {
444:                   /* On tie choose even number */
445:                   if ((h == l) && !(d % 2)) {
446:                       l = 0.0;
447:                   }
448:               }
449:           
450:               /* Round */
451:               h = g + l;
452:               /* Has rounding increased the power above 10^0? */
453:           	if (h >= (ou*10.0)) {
454:           		e++;
455:           		ou *= 10.0;
456:           		if (nmode == 'f') {
457:           			// the increase in power will only affect the number of digits in 'f' mode
458:           			m++;
459:           		}
460:           	}
461:               
462:               /* Convert again, after rounding */
463:               u = ou;
464:               ne = (nmode == 'e') ? 0 : e;
465:               pp = 0;
466:               t = 0;
467:               i = 0;
468:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
469:                   l = floor(h/u);
470:                   d = (int)l;
471:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
472:                       ++t;
473:                   } else {
474:                       if (!pp && (ne < 0)) {
475:                           dbuf[n++] = '.';
476:                           --w;
477:                           pp = 1;
478:                       }
479:                       while (t) {
480:                           dbuf[n++] = '0';
481:                           --w;
482:                           --t;
483:                       }
484:                       dbuf[n++] = (char)((int)'0' + d);
485:                       --w;
486:                   }
487:                   h -= l*u;
488:                   u = u/10.0;
489:                   --ne;
490:                   ++i;
491:               }
492:               if (!pp && (flags & POUND_FLAG)) {
493:                   dbuf[n++] = '.';
494:               }
495:               dbuf[n] = '\0';
496:           
497:               /* Convert exponent */
498:               if (nmode == 'e') {
499:                   i = sizeof(dbuf) - 1;
500:                   dbuf[i] = '\0';
501:                   sign = 0;
502:                   if (e < 0) {
503:                       sign = 1;
504:                       e = -e;
505:                   }
506:                   p = 2;
507:                   while (e || (0 < p)) {
508:                       --i;
509:                       dbuf[i] = '0' + (e % 10);
510:                       e = e / 10;
511:                       --p;
512:                       --w;
513:                   }
514:                   --i;
515:                   dbuf[i] = sign ? '-' : '+';
516:                   --w;
517:                   --i;
518:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
519:                   --w;
520:                   strcpy(&dbuf[n], &dbuf[i]);
521:               }
522:           
523:               /* Put out padded string */
524:               return pad(fp, &dbuf[0], w);
525:           }
526:           #endif
527:           
528:           #ifdef _VFPF_O
529:           static _INLINE int otoa(FILE *fp, unsigned long long d)
530:           {
531:               int i, p, t, w;
532:               unsigned long long n;
533:           
534:               /* Adjust flags, precision, width */
535:               if (!(prec < 0)) {
536:                   flags &= ~ZERO_FLAG;
537:               }
538:               p = (0 < prec) ? prec : 1;
539:               w = width;
540:           
541:               /* Convert to octal, possibly filling on the left with zeroes */
542:               n = d;
543:               i = sizeof(dbuf) - 1;
544:               dbuf[i] = '\0';
545:               t = 0;
546:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
547:                   --i;
548:                   t = n & 07;
549:                   dbuf[i] = (char)((int)'0' + t);
550:                   --p;
551:                   --w;
552:                   n = n >> 3;
553:               }
554:           
555:               /* Display prefix if required */
556:               if ((flags & POUND_FLAG) && t) {
557:                   --i;
558:                   dbuf[i] = '0';
559:                   --w;
560:               }
561:           
562:               /* Put out padded string */
563:               return pad(fp, &dbuf[i], w);
564:           }
565:           #endif
566:           
567:           #ifdef _VFPF_S
568:           static _INLINE int stoa(FILE *fp, char *s)
569:           {
570:               char *cp, nuls[] = "(null)";
571:               int i, l, p, w;
572:           
573:               /* Check for null string */
574:               cp = s;
575:               if (!cp) {
576:                   cp = nuls;
577:               }
578:           
579:               /* Get length, precision, width */
580:               l = (int)strlen(cp);
581:               p = prec;
582:               l = (!(p < 0) && (p < l)) ? p : l;
583:               p = l;
584:               w = width;
585:           
586:               /* Right justify, pad on left ? */
587:               if (!(flags & MINUS_FLAG)) {
588:                   while (l < w) {
589:                       fputc(' ', fp);
590:                       ++l;
591:                   }
592:               }
593:           
594:               /* Put out string */
595:               i = 0;
596:               while (i < p) {
597:                   fputc(*cp, fp);
598:                   ++cp;
599:                   ++i;
600:               }
601:           
602:               /* Left justify, pad on right ? */
603:               if (flags & MINUS_FLAG) {
604:                   while (l < w) {
605:                       fputc(' ', fp);
606:                       ++l;
607:                   }
608:               }
609:           
610:               return l;
611:           }
612:           #endif
613:           
614:           #ifdef _VFPF_U
615:           static _INLINE int utoa(FILE *fp, unsigned long long d)
616:           {
617:               int i, p, w;
618:               unsigned long long n;
619:           
620:               /* Adjust flags, precision, width */
621:               if (!(prec < 0)) {
622:                   flags &= ~ZERO_FLAG;
623:               }
624:               p = (0 < prec) ? prec : 1;
625:               w = width;
626:           
627:               /* Convert to decimal, possibly filling on the left with zeroes */
628:               n = d;
629:               i = sizeof(dbuf) - 1;
630:               dbuf[i] = '\0';
631:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
632:                   --i;
633:                   dbuf[i] = '0' + (n % 10);
634:                   --p;
635:                   --w;
636:                   n = n / 10;
637:               }
638:           
639:               /* Put out padded string */
640:               return pad(fp, &dbuf[i], w);
641:           }
642:           #endif
643:           
644:           #if defined(_VFPF_X) || defined(_VFPF_P)
645:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
646:           {
647:               int c, i, p, w;
648:               unsigned long long n;
649:           
650:               /* Adjust, flags, precision, width */
651:               if (!(prec < 0)) {
652:                   flags &= ~ZERO_FLAG;
653:               }
654:               p = (0 < prec) ? prec : 1;
655:               w = width;
656:               if (flags & POUND_FLAG) {
657:                   w -= 2;
658:               }
659:           
660:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
661:               n = d;
662:               i = sizeof(dbuf) - 1;
663:               dbuf[i] = '\0';
664:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
665:                   --i;
666:                   c = n & 0x0f;
667:                   c = (c < 10) ? (int)'0' + c : (int)'a' + (c - 10);
668:                   if (isupper((int)x) && isalpha(c)) {
669:                       c = toupper(c);
670:                   }
671:                   dbuf[i] = (char)c;
672:                   --p;
673:                   --w;
674:                   n = n >> 4;
675:               }
676:           
677:               /* Display prefix if required */
678:               if (flags & POUND_FLAG) {
679:                   --i;
680:                   dbuf[i] = x;
681:                   --i;
682:                   dbuf[i] = '0';
683:               }
684:           
685:               /* Put out padded string */
686:               return pad(fp, &dbuf[i], w);
687:           }
688:           #endif
689:           
690:           /* Consume and convert the next part of the format string */
691:           #ifdef _VFPF_CONVERT
692:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
0A2A  0021     MOVLB 0x1
0A2B  00A9     MOVWF fp
693:           {
694:               char c, *cp, ct[3];
695:               int done, i;
696:               long long ll;
697:               unsigned long long llu;
698:               long double f;
699:               void *vp;
700:           
701:               /* Conversion ? */
702:               if ((*fmt)[0] == '%') {
0A2C  0020     MOVLB 0x0
0A2D  085D     MOVF fmt, W
0A2E  0086     MOVWF FSR1
0A2F  0187     CLRF FSR1H
0A30  3F40     MOVIW 0[FSR1]
0A31  00DF     MOVWF 0x5F
0A32  3F41     MOVIW 1[FSR1]
0A33  00E0     MOVWF 0x60
0A34  085F     MOVF 0x5F, W
0A35  0084     MOVWF FSR0
0A36  0860     MOVF 0x60, W
0A37  0085     MOVWF FSR0H
0A38  0012     MOVIW FSR0++
0A39  3A25     XORLW 0x25
0A3A  1D03     BTFSS STATUS, 0x2
0A3B  2A3D     GOTO 0x23D
0A3C  2A3E     GOTO 0x23E
0A3D  2B28     GOTO 0x328
703:                   ++*fmt;
0A3E  085D     MOVF fmt, W
0A3F  0086     MOVWF FSR1
0A40  0187     CLRF FSR1H
0A41  3001     MOVLW 0x1
0A42  0781     ADDWF INDF1, F
0A43  3141     ADDFSR 1, 1
0A44  1803     BTFSC STATUS, 0x0
0A45  0A81     INCF INDF1, F
704:           
705:                   flags = width = 0;
0A46  0022     MOVLB 0x2
0A47  01BA     CLRF width
0A48  01BB     CLRF 0x13B
0A49  0021     MOVLB 0x1
0A4A  01E1     CLRF flags
0A4B  01E2     CLRF 0xE2
706:                   prec = -1;
0A4C  30FF     MOVLW 0xFF
0A4D  0022     MOVLB 0x2
0A4E  00BC     MOVWF prec
0A4F  30FF     MOVLW 0xFF
0A50  00BD     MOVWF 0x13D
707:           
708:           #ifdef _VFPF_FLAGS
709:                   /* Get flags */
710:                   done = 0;
711:                   while (!done) {
712:                       switch ((*fmt)[0]) {
713:                           case '-' :
714:                               flags |= MINUS_FLAG;
715:                               ++*fmt;
716:                               break;
717:                           case '0' :
718:                               flags |= ZERO_FLAG;
719:                               ++*fmt;
720:                               break;
721:                           case '+' :
722:                               flags |= PLUS_FLAG;
723:                               ++*fmt;
724:                               break;
725:                           case ' ' :
726:                               flags |= SPACE_FLAG;
727:                               ++*fmt;
728:                               break;
729:                           case '#' :
730:                               flags |= POUND_FLAG;
731:                               ++*fmt;
732:                               break;
733:                           default:
734:                               done = 1;
735:                               break;
736:                       }
737:                   }
738:                   if (flags & MINUS_FLAG) {
739:                       flags &= ~ZERO_FLAG;
740:                   }
741:           #endif
742:           
743:           #ifdef _VFPF_WIDTH
744:                   /* Get field width */
745:                   if ((*fmt)[0] == '*') {
746:                       ++*fmt;
747:                       width = va_arg(ap, int);
748:                       if (width < 0) {
749:                           flags |= MINUS_FLAG;
750:                           width = -width;
751:                       }
752:                   } else {
753:                       width = atoi(*fmt);
754:                       while (isdigit((*fmt)[0])) {
755:                           ++*fmt;
756:                       }
757:                   }
758:           #endif
759:           
760:           #ifdef _VFPF_PRECISION
761:                   /* Get precision */
762:                   if ((*fmt)[0] == '.') {
763:                       prec = 0;
764:                       ++*fmt;
765:                       if ((*fmt)[0] == '*') {
766:                           ++*fmt;
767:                           prec = va_arg(ap, int);
768:                       } else {
769:                           prec = atoi(*fmt);
770:                           while (isdigit((*fmt)[0])) {
771:                               ++*fmt;
772:                           }
773:                       }
774:                   }
775:           #endif
776:           
777:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
778:                   /* Case-folded conversion types */
779:                   ct[0] = (char)tolower((int)(*fmt)[0]);
780:                   if (ct[0]) {
781:                       ct[1] = (char)tolower((int)(*fmt)[1]);
782:                       if (ct[1]) {
783:                           ct[2] = (char)tolower((int)(*fmt)[2]);
784:                       }
785:                   }
786:           #endif
787:           
788:           #ifdef _VFPF_A
789:                   /* 'a' style (hex) floating point */
790:                   if (ct[0] == 'a') {
791:           
792:                       c = (*fmt)[0];
793:                       ++*fmt;
794:                       f = (long double)va_arg(ap, double);
795:                                   
796:                       return atoa(fp, f, c);
797:                   }
798:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
799:           
800:                       c = (*fmt)[1];
801:                       if (isupper((int)(*fmt)[0])) {
802:                           f = va_arg(ap, long double);
803:                       } else {
804:                           f = (long double)va_arg(ap, double);
805:                       }
806:                       *fmt += CSTRLEN("la");
807:                                   
808:                       return atoa(fp, f, c);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_C
813:                   /* Character */
814:                   if (*fmt[0] == 'c') {
815:                       ++*fmt;
816:                       c = (unsigned char)va_arg(ap, int);
817:                       return ctoa(fp, c);
818:                   }
819:           #endif
820:           
821:           #ifdef _VFPF_D
822:           #ifdef _VFPF_HH
823:                   /* Character decimal integer */
824:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
825:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
826:           
827:                       *fmt += CSTRLEN("hhd");
828:                       ll = (long long)(signed char)va_arg(ap, int);
829:                                   
830:                       return dtoa(fp, ll);
831:                   }
832:           #endif
833:           
834:           #ifdef _VFPF_H
835:                   /* Short decimal integer */
836:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
837:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
838:           
839:                       *fmt += CSTRLEN("hd");
840:                       ll = (long long)(short)va_arg(ap, int);
841:                                   
842:                       return dtoa(fp, ll);
843:                   }
844:           #endif
845:           
846:                   /* Decimal integer */
847:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
0A51  0020     MOVLB 0x0
0A52  085D     MOVF fmt, W
0A53  0086     MOVWF FSR1
0A54  0187     CLRF FSR1H
0A55  3F40     MOVIW 0[FSR1]
0A56  00DF     MOVWF 0x5F
0A57  3F41     MOVIW 1[FSR1]
0A58  00E0     MOVWF 0x60
0A59  085F     MOVF 0x5F, W
0A5A  0084     MOVWF FSR0
0A5B  0860     MOVF 0x60, W
0A5C  0085     MOVWF FSR0H
0A5D  0012     MOVIW FSR0++
0A5E  3A64     XORLW 0x64
0A5F  1903     BTFSC STATUS, 0x2
0A60  2A62     GOTO 0x262
0A61  2A63     GOTO 0x263
0A62  2A74     GOTO 0x274
0A63  085D     MOVF fmt, W
0A64  0086     MOVWF FSR1
0A65  0187     CLRF FSR1H
0A66  3F40     MOVIW 0[FSR1]
0A67  00DF     MOVWF 0x5F
0A68  3F41     MOVIW 1[FSR1]
0A69  00E0     MOVWF 0x60
0A6A  085F     MOVF 0x5F, W
0A6B  0084     MOVWF FSR0
0A6C  0860     MOVF 0x60, W
0A6D  0085     MOVWF FSR0H
0A6E  0012     MOVIW FSR0++
0A6F  3A69     XORLW 0x69
0A70  1D03     BTFSS STATUS, 0x2
0A71  2A73     GOTO 0x273
0A72  2A74     GOTO 0x274
0A73  2AC2     GOTO 0x2C2
848:           
849:                       ++*fmt;
0A74  085D     MOVF fmt, W
0A75  0086     MOVWF FSR1
0A76  0187     CLRF FSR1H
0A77  3001     MOVLW 0x1
0A78  0781     ADDWF INDF1, F
0A79  3141     ADDFSR 1, 1
0A7A  1803     BTFSC STATUS, 0x0
0A7B  0A81     INCF INDF1, F
850:                       ll = (long long)va_arg(ap, int);
0A7C  085E     MOVF ap, W
0A7D  0086     MOVWF FSR1
0A7E  0187     CLRF FSR1H
0A7F  0801     MOVF INDF1, W
0A80  0084     MOVWF FSR0
0A81  0185     CLRF FSR0H
0A82  3002     MOVLW 0x2
0A83  0781     ADDWF INDF1, F
0A84  3F00     MOVIW 0[FSR0]
0A85  00DF     MOVWF 0x5F
0A86  3F01     MOVIW 1[FSR0]
0A87  00E0     MOVWF 0x60
0A88  085F     MOVF 0x5F, W
0A89  0021     MOVLB 0x1
0A8A  00A0     MOVWF __pcstackBANK1
0A8B  0020     MOVLB 0x0
0A8C  0860     MOVF 0x60, W
0A8D  0021     MOVLB 0x1
0A8E  00A1     MOVWF 0xA1
0A8F  0D89     RLF WREG, F
0A90  3B89     SUBWFB WREG, F
0A91  0989     COMF WREG, F
0A92  00A2     MOVWF 0xA2
0A93  00A3     MOVWF 0xA3
0A94  00A4     MOVWF 0xA4
0A95  00A5     MOVWF 0xA5
0A96  00A6     MOVWF 0xA6
0A97  00A7     MOVWF 0xA7
851:                                   
852:                       return dtoa(fp, ll);
0A98  0820     MOVF __pcstackBANK1, W
0A99  0020     MOVLB 0x0
0A9A  00BF     MOVWF d
0A9B  0021     MOVLB 0x1
0A9C  0821     MOVF 0xA1, W
0A9D  0020     MOVLB 0x0
0A9E  00C0     MOVWF 0x40
0A9F  0021     MOVLB 0x1
0AA0  0822     MOVF 0xA2, W
0AA1  0020     MOVLB 0x0
0AA2  00C1     MOVWF 0x41
0AA3  0021     MOVLB 0x1
0AA4  0823     MOVF 0xA3, W
0AA5  0020     MOVLB 0x0
0AA6  00C2     MOVWF 0x42
0AA7  0021     MOVLB 0x1
0AA8  0824     MOVF 0xA4, W
0AA9  0020     MOVLB 0x0
0AAA  00C3     MOVWF 0x43
0AAB  0021     MOVLB 0x1
0AAC  0825     MOVF 0xA5, W
0AAD  0020     MOVLB 0x0
0AAE  00C4     MOVWF 0x44
0AAF  0021     MOVLB 0x1
0AB0  0826     MOVF 0xA6, W
0AB1  0020     MOVLB 0x0
0AB2  00C5     MOVWF 0x45
0AB3  0021     MOVLB 0x1
0AB4  0827     MOVF 0xA7, W
0AB5  0020     MOVLB 0x0
0AB6  00C6     MOVWF 0x46
0AB7  0021     MOVLB 0x1
0AB8  0829     MOVF fp, W
0AB9  318C     MOVLP 0xC
0ABA  249C     CALL 0x49C
0ABB  318A     MOVLP 0xA
0ABC  0020     MOVLB 0x0
0ABD  0840     MOVF 0x40, W
0ABE  00DE     MOVWF ap
0ABF  083F     MOVF d, W
0AC0  00DD     MOVWF fmt
0AC1  2B4D     GOTO 0x34D
853:                   }
854:           
855:           #ifdef _VFPF_L
856:                   /* Long decimal integer */
857:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
858:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
859:           
860:                       *fmt += CSTRLEN("ld");
861:                       ll = (long long)va_arg(ap, long);
862:                                   
863:                       return dtoa(fp, ll);
864:                   }
865:           #endif
866:           
867:           #ifdef _VFPF_LL
868:                   /* Long long decimal integer */
869:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
870:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
871:           
872:                       *fmt += CSTRLEN("lld");
873:                       ll = va_arg(ap, long long);
874:                                   
875:                       return dtoa(fp, ll);
876:                   }
877:           #endif
878:           
879:           #ifdef _VFPF_J
880:                   /* intmax_t decimal integer */
881:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
882:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
883:           
884:                       *fmt += CSTRLEN("jd");
885:                       ll = (long long)va_arg(ap, intmax_t);
886:                                   
887:                       return dtoa(fp, ll);
888:                   }
889:           #endif
890:           
891:           #ifdef _VFPF_T
892:                   /* ptrdiff_t decimal integer */
893:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
894:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
895:           
896:                       *fmt += CSTRLEN("td");
897:                       ll = (long long)va_arg(ap, ptrdiff_t);
898:                                   
899:                       return dtoa(fp, ll);
900:                   }
901:           #endif
902:           
903:           #ifdef _VFPF_Z
904:                   /* size_t decimal integer */
905:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
906:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
907:           
908:                       *fmt += CSTRLEN("zd");
909:                       ll = (long long)va_arg(ap, size_t);
910:                                   
911:                       return dtoa(fp, ll);
912:                   }
913:           #endif
914:           #endif
915:           
916:           #ifdef _VFPF_E
917:                   /* 'e' style floating point */
918:                   if (ct[0] == 'e') {
919:           
920:                       c = (*fmt)[0];
921:                       ++*fmt;
922:                       f = (long double)va_arg(ap, double);
923:                                   
924:                       return efgtoa(fp, f, c);
925:                   }
926:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
927:           
928:                       c = (*fmt)[1];
929:                       if (isupper((int)(*fmt)[0])) {
930:                           f = va_arg(ap, long double);
931:                       } else {
932:                           f = (long double)va_arg(ap, double);
933:                       }
934:                       *fmt += CSTRLEN("lf");
935:                                   
936:                       return efgtoa(fp, f, c);
937:                   }
938:           #endif
939:           
940:           #ifdef _VFPF_F
941:                   /* 'f' style floating point */
942:                   if (ct[0] == 'f') {
943:           
944:                       c = (*fmt)[0];
945:                       ++*fmt;
946:                       f = (long double)va_arg(ap, double);
947:                                   
948:                       return efgtoa(fp, f, c);
949:                   }
950:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
951:           
952:                       c = (*fmt)[1];
953:                       if (isupper((int)(*fmt)[0])) {
954:                           f = va_arg(ap, long double);
955:                       } else {
956:                           f = (long double)va_arg(ap, double);
957:                       }
958:                       *fmt += CSTRLEN("lf");
959:                                   
960:                       return efgtoa(fp, f, c);
961:                   }
962:           #endif
963:           
964:           #ifdef _VFPF_G
965:                   /* 'g' style floating point */
966:                   if (ct[0] == 'g') {
967:           
968:                       c = (*fmt)[0];
969:                       ++*fmt;
970:                       f = (long double)va_arg(ap, double);
971:                                   
972:                       return efgtoa(fp, f, c);
973:                   }
974:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
975:           
976:                       c = (*fmt)[1];
977:                       if (isupper((int)(*fmt)[0])) {
978:                           f = va_arg(ap, long double);
979:                       } else {
980:                           f = (long double)va_arg(ap, double);
981:                       }
982:                       *fmt += CSTRLEN("lg");
983:                                   
984:                       return efgtoa(fp, f, c);
985:                   }
986:           #endif
987:           
988:           #ifdef _VFPF_O
989:           #ifdef _VFPF_HH
990:                   /* Character octal integer */
991:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
992:           
993:                       *fmt += CSTRLEN("hho");
994:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
995:                                   
996:                       return otoa(fp, llu);
997:                   }
998:           #endif
999:           
1000:          #ifdef _VFPF_H
1001:                  /* Short octal integer */
1002:                  if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
1003:          
1004:                      *fmt += CSTRLEN("ho");
1005:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1006:                                  
1007:                      return otoa(fp, llu);
1008:                  }
1009:          #endif
1010:          
1011:                  /* Octal integer */
1012:                  if (*fmt[0] == 'o') {
1013:          
1014:                      ++*fmt;
1015:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1016:                                  
1017:                      return otoa(fp, llu);
1018:                  }
1019:          
1020:          #ifdef _VFPF_L
1021:                  /* Long octal integer */
1022:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1023:          
1024:                      *fmt += CSTRLEN("lo");
1025:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_LL
1032:                  /* Long long octal integer */
1033:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1034:          
1035:                      *fmt += CSTRLEN("llo");
1036:                      llu = va_arg(ap, unsigned long long);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_J
1043:                  /* uintmax_t octal integer */
1044:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1045:          
1046:                      *fmt += CSTRLEN("jo");
1047:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          
1053:          #ifdef _VFPF_T
1054:                  /* ptrdiff_t octal integer */
1055:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1056:          
1057:                      *fmt += CSTRLEN("to");
1058:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1059:                                  
1060:                      return otoa(fp, llu);
1061:                  }
1062:          #endif
1063:          
1064:          #ifdef _VFPF_Z
1065:                  /* size_t octal integer */
1066:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1067:          
1068:                      *fmt += CSTRLEN("zo");
1069:                      llu = (unsigned long long)va_arg(ap, size_t);
1070:                                  
1071:                      return otoa(fp, llu);
1072:                  }
1073:          #endif
1074:          #endif
1075:          
1076:                  /* Character count */
1077:          #ifdef _VFPF_N
1078:          
1079:          #ifdef _VFPF_HH
1080:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1081:          
1082:                      *fmt += CSTRLEN("hhn");
1083:                      vp = (void *)va_arg(ap, char *);
1084:                      *(char *)vp = (char)nout;
1085:                      return 0;
1086:                  }
1087:          #endif
1088:          
1089:          #ifdef _VFPF_H
1090:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1091:          
1092:                      *fmt += CSTRLEN("hn");
1093:                      vp = (void *)va_arg(ap, short *);
1094:                      *(short *)vp = (short)nout;
1095:                      return 0;
1096:                  }
1097:          #endif
1098:          
1099:                  if (*fmt[0] == 'n') {
0AC2  085D     MOVF fmt, W
0AC3  0086     MOVWF FSR1
0AC4  0187     CLRF FSR1H
0AC5  3F40     MOVIW 0[FSR1]
0AC6  00DF     MOVWF 0x5F
0AC7  3F41     MOVIW 1[FSR1]
0AC8  00E0     MOVWF 0x60
0AC9  085F     MOVF 0x5F, W
0ACA  0084     MOVWF FSR0
0ACB  0860     MOVF 0x60, W
0ACC  0085     MOVWF FSR0H
0ACD  0012     MOVIW FSR0++
0ACE  3A6E     XORLW 0x6E
0ACF  1D03     BTFSS STATUS, 0x2
0AD0  2AD2     GOTO 0x2D2
0AD1  2AD3     GOTO 0x2D3
0AD2  2AF3     GOTO 0x2F3
1100:                      ++*fmt;
0AD3  085D     MOVF fmt, W
0AD4  0086     MOVWF FSR1
0AD5  0187     CLRF FSR1H
0AD6  3001     MOVLW 0x1
0AD7  0781     ADDWF INDF1, F
0AD8  3141     ADDFSR 1, 1
0AD9  1803     BTFSC STATUS, 0x0
0ADA  0A81     INCF INDF1, F
1101:                      vp = (void *)va_arg(ap, int *);
0ADB  085E     MOVF ap, W
0ADC  0086     MOVWF FSR1
0ADD  0187     CLRF FSR1H
0ADE  3F40     MOVIW 0[FSR1]
0ADF  0084     MOVWF FSR0
0AE0  0185     CLRF FSR0H
0AE1  0A81     INCF INDF1, F
0AE2  0800     MOVF INDF0, W
0AE3  00DF     MOVWF 0x5F
0AE4  085F     MOVF 0x5F, W
0AE5  0021     MOVLB 0x1
0AE6  00A8     MOVWF vp
1102:                      *(int *)vp = nout;
0AE7  0828     MOVF vp, W
0AE8  0086     MOVWF FSR1L
0AE9  0187     CLRF FSR1H
0AEA  0022     MOVLB 0x2
0AEB  0838     MOVF nout, W
0AEC  3FC0     MOVWI 0[FSR1]
0AED  0839     MOVF 0x139, W
0AEE  3FC1     MOVWI 1[FSR1]
1103:                      return 0;
0AEF  0020     MOVLB 0x0
0AF0  01DD     CLRF fmt
0AF1  01DE     CLRF ap
0AF2  2B4D     GOTO 0x34D
1104:                  }
1105:          
1106:          #ifdef _VFPF_L
1107:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1108:          
1109:                      *fmt += CSTRLEN("ln");
1110:                      vp = (void *)va_arg(ap, long *);
1111:                      *(long *)vp = (long)nout;
1112:                      return 0;
1113:                  }
1114:          #endif
1115:          
1116:          #ifdef _VFPF_LL
1117:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1118:          
1119:                      *fmt += CSTRLEN("lln");
1120:                      vp = (void *)va_arg(ap, long long *);
1121:                      *(long long *)vp = (long long)nout;
1122:                      return 0;
1123:                  }
1124:          #endif
1125:          
1126:          #ifdef _VFPF_J
1127:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1128:          
1129:                      *fmt += CSTRLEN("jn");
1130:                      vp = (void *)va_arg(ap, uintmax_t *);
1131:                      *(uintmax_t *)vp = (uintmax_t)nout;
1132:                      return 0;
1133:                  }
1134:          #endif
1135:          
1136:          #ifdef _VFPF_T
1137:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1138:          
1139:                      *fmt += CSTRLEN("tn");
1140:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1141:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1142:                      return 0;
1143:                  }
1144:          #endif
1145:          
1146:          #ifdef _VFPF_Z
1147:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1148:          
1149:                      *fmt += CSTRLEN("zn");
1150:                      vp = (void *)va_arg(ap, size_t *);
1151:                      *(size_t *)vp = (size_t)nout;
1152:                      return 0;
1153:                  }
1154:          #endif
1155:          
1156:          #endif
1157:          
1158:          #ifdef _VFPF_P
1159:                  /* Pointer */
1160:                  if (*fmt[0] == 'p') {
1161:          
1162:                      ++*fmt;
1163:                      llu = (unsigned long long)(uintptr_t)va_arg(ap, void *);
1164:                                  
1165:                      return xtoa(fp, llu, 'x');
1166:                  }
1167:          #endif
1168:          
1169:          #ifdef _VFPF_S
1170:                  /* String */
1171:                  if (*fmt[0] == 's') {
1172:          
1173:                      ++*fmt;
1174:                      cp = va_arg(ap, char *);
1175:          
1176:                      return stoa(fp, cp);
1177:                  }
1178:          #endif
1179:          
1180:          #ifdef _VFPF_U
1181:          #ifdef _VFPF_HH
1182:                  /* Unsigned character decimal integer */
1183:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1184:          
1185:                      *fmt += CSTRLEN("hhu");
1186:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1187:                                  
1188:                      return utoa(fp, llu);
1189:                  }
1190:          #endif
1191:          
1192:          #ifdef _VFPF_H
1193:                  /* Unsigned short decimal integer */
1194:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1195:          
1196:                      *fmt += CSTRLEN("hu");
1197:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1198:                                  
1199:                      return utoa(fp, llu);
1200:                  }
1201:          #endif
1202:          
1203:                  /* Unsigned decimal integer */
1204:                  if (*fmt[0] == 'u') {
1205:          
1206:                      ++*fmt;
1207:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1208:                                  
1209:                      return utoa(fp, llu);
1210:                  }
1211:          
1212:          #ifdef _VFPF_L
1213:                  /* Unsigned long decimal integer */
1214:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1215:          
1216:                      *fmt += CSTRLEN("lu");
1217:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_LL
1224:                  /* Unsigned long long decimal integer */
1225:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1226:          
1227:                      *fmt += CSTRLEN("llu");
1228:                      llu = va_arg(ap, unsigned long long);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_J
1235:                  /* uintmax_t decimal integer */
1236:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1237:          
1238:                      *fmt += CSTRLEN("ju");
1239:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          
1245:          #ifdef _VFPF_T
1246:                  /* ptrdiff_t decimal integer */
1247:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1248:          
1249:                      *fmt += CSTRLEN("tu");
1250:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1251:                                  
1252:                      return utoa(fp, llu);
1253:                  }
1254:          #endif
1255:          
1256:          #ifdef _VFPF_Z
1257:                  /* size_t decimal integer */
1258:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1259:          
1260:                      *fmt += CSTRLEN("zu");
1261:                      llu = (unsigned long long)va_arg(ap, size_t);
1262:                                  
1263:                      return utoa(fp, llu);
1264:                  }
1265:          #endif
1266:          #endif
1267:          
1268:          #ifdef _VFPF_X
1269:          #ifdef _VFPF_HH
1270:                  /* Character hexadecimal integer */
1271:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1272:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1273:          
1274:                      c = (*fmt)[2];
1275:                      *fmt += CSTRLEN("hhx");
1276:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1277:                                  
1278:                      return xtoa(fp, llu, c);
1279:                  }
1280:          #endif
1281:          
1282:          #ifdef _VFPF_H
1283:                  /* Short hexadecimal integer */
1284:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1285:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1286:          
1287:                      c = (*fmt)[1];
1288:                      *fmt += CSTRLEN("hx");
1289:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1290:                                  
1291:                      return xtoa(fp, llu, c);
1292:                  }
1293:          #endif
1294:          
1295:                  /* Hexadecimal integer */
1296:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1297:          
1298:                      c = (*fmt)[0];
1299:                      ++*fmt;
1300:                      llu = (unsigned long long)va_arg(ap, unsigned int);
1301:                                  
1302:                      return xtoa(fp, llu, c);
1303:                  }
1304:          
1305:          #ifdef _VFPF_L
1306:                  /* Long hexadecimal integer */
1307:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1308:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1309:          
1310:                      c = (*fmt)[1];
1311:                      *fmt += CSTRLEN("lx");
1312:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1313:                                  
1314:                      return xtoa(fp, llu, c);
1315:                  }
1316:          #endif
1317:          
1318:          #ifdef _VFPF_LL
1319:                  /* Long long hexadecimal integer */
1320:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1321:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1322:          
1323:                      c = (*fmt)[2];
1324:                      *fmt += CSTRLEN("llx");
1325:                      llu = va_arg(ap, unsigned long long);
1326:                                  
1327:                      return xtoa(fp, llu, c);
1328:                  }
1329:          #endif
1330:          
1331:          #ifdef _VFPF_J
1332:                  /* uintmax_t hexadecimal integer */
1333:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1334:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1335:          
1336:                      c = (*fmt)[1];
1337:                      *fmt += CSTRLEN("jx");
1338:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1339:                                  
1340:                      return xtoa(fp, llu, c);
1341:                  }
1342:          #endif
1343:          
1344:          #ifdef _VFPF_T
1345:                  /* ptrdiff_t hexadecimal integer */
1346:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1347:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1348:          
1349:                      c = (*fmt)[1];
1350:                      *fmt += CSTRLEN("tx");
1351:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1352:                                  
1353:                      return xtoa(fp, llu, c);
1354:                  }
1355:          #endif
1356:          
1357:          #ifdef _VFPF_Z
1358:                  /* size_t hexadecimal integer */
1359:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1360:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1361:          
1362:                      c = (*fmt)[1];
1363:                      *fmt += CSTRLEN("zx");
1364:                      llu = (unsigned long long)va_arg(ap, size_t);
1365:                                  
1366:                      return xtoa(fp, llu, c);
1367:                  }
1368:          #endif
1369:          #endif
1370:          
1371:                  /* 'Escaped' '%' character */
1372:                  if ((*fmt)[0] == '%') {
0AF3  085D     MOVF fmt, W
0AF4  0086     MOVWF FSR1
0AF5  0187     CLRF FSR1H
0AF6  3F40     MOVIW 0[FSR1]
0AF7  00DF     MOVWF 0x5F
0AF8  3F41     MOVIW 1[FSR1]
0AF9  00E0     MOVWF 0x60
0AFA  085F     MOVF 0x5F, W
0AFB  0084     MOVWF FSR0
0AFC  0860     MOVF 0x60, W
0AFD  0085     MOVWF FSR0H
0AFE  0012     MOVIW FSR0++
0AFF  3A25     XORLW 0x25
0B00  1D03     BTFSS STATUS, 0x2
0B01  2B03     GOTO 0x303
0B02  2B04     GOTO 0x304
0B03  2B1F     GOTO 0x31F
1373:                      ++*fmt;
0B04  085D     MOVF fmt, W
0B05  0086     MOVWF FSR1
0B06  0187     CLRF FSR1H
0B07  3001     MOVLW 0x1
0B08  0781     ADDWF INDF1, F
0B09  3141     ADDFSR 1, 1
0B0A  1803     BTFSC STATUS, 0x0
0B0B  0A81     INCF INDF1, F
1374:                      fputc((int)'%', fp);
0B0C  3025     MOVLW 0x25
0B0D  00A6     MOVWF Nibble
0B0E  3000     MOVLW 0x0
0B0F  00A7     MOVWF reception
0B10  0021     MOVLB 0x1
0B11  0829     MOVF fp, W
0B12  0020     MOVLB 0x0
0B13  00DF     MOVWF 0x5F
0B14  085F     MOVF 0x5F, W
0B15  00A8     MOVWF Data
0B16  3195     MOVLP 0x15
0B17  2514     CALL 0x514
0B18  318A     MOVLP 0xA
1375:                      return 1;
0B19  3001     MOVLW 0x1
0B1A  0020     MOVLB 0x0
0B1B  00DD     MOVWF fmt
0B1C  3000     MOVLW 0x0
0B1D  00DE     MOVWF ap
0B1E  2B4D     GOTO 0x34D
1376:                  }
1377:          
1378:                  /* Unrecognized conversion */
1379:                  ++*fmt;
0B1F  085D     MOVF fmt, W
0B20  0086     MOVWF FSR1
0B21  0187     CLRF FSR1H
0B22  3001     MOVLW 0x1
0B23  0781     ADDWF INDF1, F
0B24  3141     ADDFSR 1, 1
0B25  1803     BTFSC STATUS, 0x0
0B26  0A81     INCF INDF1, F
0B27  2AEF     GOTO 0x2EF
1380:                  return 0;
1381:              }
1382:          
1383:              /* No conversion, just intervening text */
1384:              fputc((int)(*fmt)[0], fp);
0B28  085D     MOVF fmt, W
0B29  0086     MOVWF FSR1
0B2A  0187     CLRF FSR1H
0B2B  3F40     MOVIW 0[FSR1]
0B2C  00DF     MOVWF 0x5F
0B2D  3F41     MOVIW 1[FSR1]
0B2E  00E0     MOVWF 0x60
0B2F  085F     MOVF 0x5F, W
0B30  0084     MOVWF FSR0
0B31  0860     MOVF 0x60, W
0B32  0085     MOVWF FSR0H
0B33  0800     MOVF INDF0, W
0B34  00E1     MOVWF 0x61
0B35  01E2     CLRF 0x62
0B36  0861     MOVF 0x61, W
0B37  00A6     MOVWF Nibble
0B38  0862     MOVF 0x62, W
0B39  00A7     MOVWF reception
0B3A  0021     MOVLB 0x1
0B3B  0829     MOVF fp, W
0B3C  0020     MOVLB 0x0
0B3D  00E3     MOVWF 0x63
0B3E  0863     MOVF 0x63, W
0B3F  00A8     MOVWF Data
0B40  3195     MOVLP 0x15
0B41  2514     CALL 0x514
0B42  318A     MOVLP 0xA
1385:              ++*fmt;
0B43  0020     MOVLB 0x0
0B44  085D     MOVF fmt, W
0B45  0086     MOVWF FSR1
0B46  0187     CLRF FSR1H
0B47  3001     MOVLW 0x1
0B48  0781     ADDWF INDF1, F
0B49  3141     ADDFSR 1, 1
0B4A  1803     BTFSC STATUS, 0x0
0B4B  0A81     INCF INDF1, F
0B4C  2B19     GOTO 0x319
1386:              return 1;
1387:          }
0B4D  0008     RETURN
1388:          #endif
1389:          
1390:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
12E6  0021     MOVLB 0x1
12E7  00AA     MOVWF fp
1391:          {
1392:          #ifdef _VFPF_CONVERT
1393:              char *cfmt;
1394:          
1395:              cfmt = (char *)fmt;
12E8  0020     MOVLB 0x0
12E9  0865     MOVF 0x65, W
12EA  0021     MOVLB 0x1
12EB  00AC     MOVWF 0xAC
12EC  0020     MOVLB 0x0
12ED  0864     MOVF fmt, W
12EE  0021     MOVLB 0x1
12EF  00AB     MOVWF cfmt
1396:              nout = 0;
12F0  0022     MOVLB 0x2
12F1  01B8     CLRF nout
12F2  01B9     CLRF 0x139
1397:              while (*cfmt) {
12F3  2B0A     GOTO 0x30A
130A  0021     MOVLB 0x1
130B  082B     MOVF cfmt, W
130C  0084     MOVWF FSR0L
130D  082C     MOVF 0xAC, W
130E  0085     MOVWF FSR0H
130F  0012     MOVIW FSR0++
1310  1D03     BTFSS STATUS, 0x2
1311  2B13     GOTO 0x313
1312  2B14     GOTO 0x314
1313  2AF4     GOTO 0x2F4
1398:                  nout += vfpfcnvrt(fp, &cfmt, ap);
12F4  30AB     MOVLW 0xAB
12F5  0020     MOVLB 0x0
12F6  00E7     MOVWF 0x67
12F7  0867     MOVF 0x67, W
12F8  00DD     MOVWF fmt
12F9  0866     MOVF ap, W
12FA  00E8     MOVWF 0x68
12FB  0868     MOVF 0x68, W
12FC  00DE     MOVWF ap
12FD  0021     MOVLB 0x1
12FE  082A     MOVF fp, W
12FF  318A     MOVLP 0xA
1300  222A     CALL 0x22A
1301  3192     MOVLP 0x12
1302  0020     MOVLB 0x0
1303  085D     MOVF fmt, W
1304  0022     MOVLB 0x2
1305  07B8     ADDWF nout, F
1306  0020     MOVLB 0x0
1307  085E     MOVF ap, W
1308  0022     MOVLB 0x2
1309  3DB9     ADDWFC 0x139, F
1399:              }
1400:              return nout;
1314  0022     MOVLB 0x2
1315  0839     MOVF 0x139, W
1316  0020     MOVLB 0x0
1317  00E5     MOVWF 0x65
1318  0022     MOVLB 0x2
1319  0838     MOVF nout, W
131A  0020     MOVLB 0x0
131B  00E4     MOVWF fmt
1401:          #else
1402:              return fputs(fmt, fp);
1403:          #endif
1404:          }
131C  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/aomod.c  -------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0838  0020     MOVLB 0x0
0839  01B5     CLRF src
15:            	if(dividend < 0) {
083A  302B     MOVLW 0x2B
083B  0086     MOVWF FSR1
083C  3000     MOVLW 0x0
083D  0087     MOVWF FSR1H
083E  3F47     MOVIW 7[FSR1]
083F  00B3     MOVWF dest
0840  1FB3     BTFSS dest, 0x7
0841  2843     GOTO 0x43
0842  2844     GOTO 0x44
0843  2866     GOTO 0x66
16:            		dividend = -dividend;
0844  0020     MOVLB 0x0
0845  09AB     COMF I2C_Add, F
0846  09AC     COMF i, F
0847  09AD     COMF 0x2D, F
0848  09AE     COMF fp, F
0849  09AF     COMF s, F
084A  09B0     COMF s2, F
084B  09B1     COMF d, F
084C  09B2     COMF c, F
084D  0AAB     INCF I2C_Add, F
084E  1D03     BTFSS STATUS, 0x2
084F  2863     GOTO 0x63
0850  0AAC     INCF i, F
0851  1D03     BTFSS STATUS, 0x2
0852  2863     GOTO 0x63
0853  0AAD     INCF 0x2D, F
0854  1D03     BTFSS STATUS, 0x2
0855  2863     GOTO 0x63
0856  0AAE     INCF fp, F
0857  1D03     BTFSS STATUS, 0x2
0858  2863     GOTO 0x63
0859  0AAF     INCF s, F
085A  1D03     BTFSS STATUS, 0x2
085B  2863     GOTO 0x63
085C  0AB0     INCF s2, F
085D  1D03     BTFSS STATUS, 0x2
085E  2863     GOTO 0x63
085F  0AB1     INCF d, F
0860  1D03     BTFSS STATUS, 0x2
0861  2863     GOTO 0x63
0862  0AB2     INCF c, F
17:            		sign = 1;
0863  0020     MOVLB 0x0
0864  01B5     CLRF src
0865  0AB5     INCF src, F
18:            	}
19:            	if(divisor < 0)
0866  3023     MOVLW 0x23
0867  0086     MOVWF FSR1
0868  3000     MOVLW 0x0
0869  0087     MOVWF FSR1H
086A  3F47     MOVIW 7[FSR1]
086B  0020     MOVLB 0x0
086C  00B3     MOVWF dest
086D  1FB3     BTFSS dest, 0x7
086E  2870     GOTO 0x70
086F  2871     GOTO 0x71
0870  2890     GOTO 0x90
20:            		divisor = -divisor;
0871  0020     MOVLB 0x0
0872  09A3     COMF data, F
0873  09A4     COMF Data, F
0874  09A5     COMF txData, F
0875  09A6     COMF Nibble, F
0876  09A7     COMF reception, F
0877  09A8     COMF Data, F
0878  09A9     COMF Str, F
0879  09AA     COMF repOperateur, F
087A  0AA3     INCF data, F
087B  1D03     BTFSS STATUS, 0x2
087C  2890     GOTO 0x90
087D  0AA4     INCF Data, F
087E  1D03     BTFSS STATUS, 0x2
087F  2890     GOTO 0x90
0880  0AA5     INCF txData, F
0881  1D03     BTFSS STATUS, 0x2
0882  2890     GOTO 0x90
0883  0AA6     INCF Nibble, F
0884  1D03     BTFSS STATUS, 0x2
0885  2890     GOTO 0x90
0886  0AA7     INCF reception, F
0887  1D03     BTFSS STATUS, 0x2
0888  2890     GOTO 0x90
0889  0AA8     INCF Data, F
088A  1D03     BTFSS STATUS, 0x2
088B  2890     GOTO 0x90
088C  0AA9     INCF Str, F
088D  1D03     BTFSS STATUS, 0x2
088E  2890     GOTO 0x90
088F  0AAA     INCF repOperateur, F
21:            	if(divisor != 0) {
0890  0020     MOVLB 0x0
0891  0823     MOVF data, W
0892  0424     IORWF Data, W
0893  0425     IORWF txData, W
0894  0426     IORWF Nibble, W
0895  0427     IORWF reception, W
0896  0428     IORWF Data, W
0897  0429     IORWF Str, W
0898  042A     IORWF repOperateur, W
0899  1903     BTFSC STATUS, 0x2
089A  289C     GOTO 0x9C
089B  289D     GOTO 0x9D
089C  28F0     GOTO 0xF0
22:            		counter = 1;
089D  01B4     CLRF counter
089E  0AB4     INCF counter, F
23:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
089F  28AC     GOTO 0xAC
08AC  1FAA     BTFSS repOperateur, 0x7
08AD  28AF     GOTO 0xAF
08AE  28B0     GOTO 0xB0
08AF  28A0     GOTO 0xA0
24:            			divisor <<= 1;
08A0  35A3     LSLF data, F
08A1  0DA4     RLF Data, F
08A2  0DA5     RLF txData, F
08A3  0DA6     RLF Nibble, F
08A4  0DA7     RLF reception, F
08A5  0DA8     RLF Data, F
08A6  0DA9     RLF Str, F
08A7  0DAA     RLF repOperateur, F
25:            			counter++;
08A8  3001     MOVLW 0x1
08A9  00B3     MOVWF dest
08AA  0833     MOVF dest, W
08AB  07B4     ADDWF counter, F
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
08B0  082A     MOVF repOperateur, W
08B1  0232     SUBWF c, W
08B2  1D03     BTFSS STATUS, 0x2
08B3  28CE     GOTO 0xCE
08B4  0829     MOVF Str, W
08B5  0231     SUBWF d, W
08B6  1D03     BTFSS STATUS, 0x2
08B7  28CE     GOTO 0xCE
08B8  0828     MOVF Data, W
08B9  0230     SUBWF s2, W
08BA  1D03     BTFSS STATUS, 0x2
08BB  28CE     GOTO 0xCE
08BC  0827     MOVF reception, W
08BD  022F     SUBWF s, W
08BE  1D03     BTFSS STATUS, 0x2
08BF  28CE     GOTO 0xCE
08C0  0826     MOVF Nibble, W
08C1  022E     SUBWF fp, W
08C2  1D03     BTFSS STATUS, 0x2
08C3  28CE     GOTO 0xCE
08C4  0825     MOVF txData, W
08C5  022D     SUBWF 0x2D, W
08C6  1D03     BTFSS STATUS, 0x2
08C7  28CE     GOTO 0xCE
08C8  0824     MOVF Data, W
08C9  022C     SUBWF i, W
08CA  1D03     BTFSS STATUS, 0x2
08CB  28CE     GOTO 0xCE
08CC  0823     MOVF data, W
08CD  022B     SUBWF I2C_Add, W
08CE  1C03     BTFSS STATUS, 0x0
08CF  28D1     GOTO 0xD1
08D0  28D2     GOTO 0xD2
08D1  28E2     GOTO 0xE2
29:            				dividend -= divisor;
08D2  0823     MOVF data, W
08D3  02AB     SUBWF I2C_Add, F
08D4  0824     MOVF Data, W
08D5  3BAC     SUBWFB i, F
08D6  0825     MOVF txData, W
08D7  3BAD     SUBWFB 0x2D, F
08D8  0826     MOVF Nibble, W
08D9  3BAE     SUBWFB fp, F
08DA  0827     MOVF reception, W
08DB  3BAF     SUBWFB s, F
08DC  0828     MOVF Data, W
08DD  3BB0     SUBWFB s2, F
08DE  0829     MOVF Str, W
08DF  3BB1     SUBWFB d, F
08E0  082A     MOVF repOperateur, W
08E1  3BB2     SUBWFB c, F
30:            			*(unsigned long long int *)&divisor >>= 1;
08E2  36AA     LSRF repOperateur, F
08E3  0CA9     RRF Str, F
08E4  0CA8     RRF Data, F
08E5  0CA7     RRF reception, F
08E6  0CA6     RRF Nibble, F
08E7  0CA5     RRF txData, F
08E8  0CA4     RRF Data, F
08E9  0CA3     RRF data, F
31:            		} while(--counter != 0);
08EA  3001     MOVLW 0x1
08EB  02B4     SUBWF counter, F
08EC  1D03     BTFSS STATUS, 0x2
08ED  28EF     GOTO 0xEF
08EE  28F0     GOTO 0xF0
08EF  28B0     GOTO 0xB0
32:            	}
33:            	if(sign)
08F0  0835     MOVF src, W
08F1  1903     BTFSC STATUS, 0x2
08F2  28F4     GOTO 0xF4
08F3  28F5     GOTO 0xF5
08F4  2913     GOTO 0x113
34:            		dividend = -dividend;
08F5  09AB     COMF I2C_Add, F
08F6  09AC     COMF i, F
08F7  09AD     COMF 0x2D, F
08F8  09AE     COMF fp, F
08F9  09AF     COMF s, F
08FA  09B0     COMF s2, F
08FB  09B1     COMF d, F
08FC  09B2     COMF c, F
08FD  0AAB     INCF I2C_Add, F
08FE  1D03     BTFSS STATUS, 0x2
08FF  2913     GOTO 0x113
0900  0AAC     INCF i, F
0901  1D03     BTFSS STATUS, 0x2
0902  2913     GOTO 0x113
0903  0AAD     INCF 0x2D, F
0904  1D03     BTFSS STATUS, 0x2
0905  2913     GOTO 0x113
0906  0AAE     INCF fp, F
0907  1D03     BTFSS STATUS, 0x2
0908  2913     GOTO 0x113
0909  0AAF     INCF s, F
090A  1D03     BTFSS STATUS, 0x2
090B  2913     GOTO 0x113
090C  0AB0     INCF s2, F
090D  1D03     BTFSS STATUS, 0x2
090E  2913     GOTO 0x113
090F  0AB1     INCF d, F
0910  1D03     BTFSS STATUS, 0x2
0911  2913     GOTO 0x113
0912  0AB2     INCF c, F
35:            	return dividend;
0913  0020     MOVLB 0x0
0914  082B     MOVF I2C_Add, W
0915  00A3     MOVWF data
0916  082C     MOVF i, W
0917  00A4     MOVWF Data
0918  082D     MOVF 0x2D, W
0919  00A5     MOVWF txData
091A  082E     MOVF fp, W
091B  00A6     MOVWF Nibble
091C  082F     MOVF s, W
091D  00A7     MOVWF reception
091E  0830     MOVF s2, W
091F  00A8     MOVWF Data
0920  0831     MOVF d, W
0921  00A9     MOVWF Str
0922  0832     MOVF c, W
0923  00AA     MOVWF repOperateur
36:            }
0924  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/aodiv.c  -------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
0925  0020     MOVLB 0x0
0926  01B5     CLRF src
16:            	if(divisor < 0) {
0927  3023     MOVLW 0x23
0928  0086     MOVWF FSR1
0929  3000     MOVLW 0x0
092A  0087     MOVWF FSR1H
092B  3F47     MOVIW 7[FSR1]
092C  00B3     MOVWF dest
092D  1FB3     BTFSS dest, 0x7
092E  2930     GOTO 0x130
092F  2931     GOTO 0x131
0930  2953     GOTO 0x153
17:            		divisor = -divisor;
0931  0020     MOVLB 0x0
0932  09A3     COMF data, F
0933  09A4     COMF Data, F
0934  09A5     COMF txData, F
0935  09A6     COMF Nibble, F
0936  09A7     COMF reception, F
0937  09A8     COMF Data, F
0938  09A9     COMF Str, F
0939  09AA     COMF repOperateur, F
093A  0AA3     INCF data, F
093B  1D03     BTFSS STATUS, 0x2
093C  2950     GOTO 0x150
093D  0AA4     INCF Data, F
093E  1D03     BTFSS STATUS, 0x2
093F  2950     GOTO 0x150
0940  0AA5     INCF txData, F
0941  1D03     BTFSS STATUS, 0x2
0942  2950     GOTO 0x150
0943  0AA6     INCF Nibble, F
0944  1D03     BTFSS STATUS, 0x2
0945  2950     GOTO 0x150
0946  0AA7     INCF reception, F
0947  1D03     BTFSS STATUS, 0x2
0948  2950     GOTO 0x150
0949  0AA8     INCF Data, F
094A  1D03     BTFSS STATUS, 0x2
094B  2950     GOTO 0x150
094C  0AA9     INCF Str, F
094D  1D03     BTFSS STATUS, 0x2
094E  2950     GOTO 0x150
094F  0AAA     INCF repOperateur, F
18:            		sign = 1;
0950  0020     MOVLB 0x0
0951  01B5     CLRF src
0952  0AB5     INCF src, F
19:            	}
20:            	if(dividend < 0) {
0953  302B     MOVLW 0x2B
0954  0086     MOVWF FSR1
0955  3000     MOVLW 0x0
0956  0087     MOVWF FSR1H
0957  3F47     MOVIW 7[FSR1]
0958  0020     MOVLB 0x0
0959  00B3     MOVWF dest
095A  1FB3     BTFSS dest, 0x7
095B  295D     GOTO 0x15D
095C  295E     GOTO 0x15E
095D  2982     GOTO 0x182
21:            		dividend = -dividend;
095E  0020     MOVLB 0x0
095F  09AB     COMF I2C_Add, F
0960  09AC     COMF i, F
0961  09AD     COMF 0x2D, F
0962  09AE     COMF fp, F
0963  09AF     COMF s, F
0964  09B0     COMF s2, F
0965  09B1     COMF d, F
0966  09B2     COMF c, F
0967  0AAB     INCF I2C_Add, F
0968  1D03     BTFSS STATUS, 0x2
0969  297D     GOTO 0x17D
096A  0AAC     INCF i, F
096B  1D03     BTFSS STATUS, 0x2
096C  297D     GOTO 0x17D
096D  0AAD     INCF 0x2D, F
096E  1D03     BTFSS STATUS, 0x2
096F  297D     GOTO 0x17D
0970  0AAE     INCF fp, F
0971  1D03     BTFSS STATUS, 0x2
0972  297D     GOTO 0x17D
0973  0AAF     INCF s, F
0974  1D03     BTFSS STATUS, 0x2
0975  297D     GOTO 0x17D
0976  0AB0     INCF s2, F
0977  1D03     BTFSS STATUS, 0x2
0978  297D     GOTO 0x17D
0979  0AB1     INCF d, F
097A  1D03     BTFSS STATUS, 0x2
097B  297D     GOTO 0x17D
097C  0AB2     INCF c, F
22:            		sign ^= 1;
097D  3001     MOVLW 0x1
097E  0020     MOVLB 0x0
097F  00B3     MOVWF dest
0980  0833     MOVF dest, W
0981  06B5     XORWF src, F
23:            	}
24:            	quotient = 0;
0982  3036     MOVLW 0x36
0983  0086     MOVWF FSR1
0984  3000     MOVLW 0x0
0985  0087     MOVWF FSR1H
0986  3008     MOVLW 0x8
0987  0020     MOVLB 0x0
0988  00B3     MOVWF dest
0989  3000     MOVLW 0x0
098A  001E     MOVWI FSR1++
098B  0BB3     DECFSZ dest, F
098C  298A     GOTO 0x18A
25:            	if(divisor != 0) {
098D  0823     MOVF data, W
098E  0424     IORWF Data, W
098F  0425     IORWF txData, W
0990  0426     IORWF Nibble, W
0991  0427     IORWF reception, W
0992  0428     IORWF Data, W
0993  0429     IORWF Str, W
0994  042A     IORWF repOperateur, W
0995  1903     BTFSC STATUS, 0x2
0996  2998     GOTO 0x198
0997  2999     GOTO 0x199
0998  29F5     GOTO 0x1F5
26:            		counter = 1;
0999  01B4     CLRF counter
099A  0AB4     INCF counter, F
27:            		while(((unsigned long long)divisor & 0x8000000000000000ULL) == 0) {
099B  29A8     GOTO 0x1A8
09A8  1FAA     BTFSS repOperateur, 0x7
09A9  29AB     GOTO 0x1AB
09AA  29AC     GOTO 0x1AC
09AB  299C     GOTO 0x19C
28:            			divisor <<= 1;
099C  35A3     LSLF data, F
099D  0DA4     RLF Data, F
099E  0DA5     RLF txData, F
099F  0DA6     RLF Nibble, F
09A0  0DA7     RLF reception, F
09A1  0DA8     RLF Data, F
09A2  0DA9     RLF Str, F
09A3  0DAA     RLF repOperateur, F
29:            			counter++;
09A4  3001     MOVLW 0x1
09A5  00B3     MOVWF dest
09A6  0833     MOVF dest, W
09A7  07B4     ADDWF counter, F
30:            		}
31:            		do {
32:            			quotient <<= 1;
09AC  35B6     LSLF buf, F
09AD  0DB7     RLF p, F
09AE  0DB8     RLF 0x38, F
09AF  0DB9     RLF 0x39, F
09B0  0DBA     RLF i, F
09B1  0DBB     RLF 0x3B, F
09B2  0DBC     RLF w, F
09B3  0DBD     RLF 0x3D, F
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
09B4  082A     MOVF repOperateur, W
09B5  0232     SUBWF c, W
09B6  1D03     BTFSS STATUS, 0x2
09B7  29D2     GOTO 0x1D2
09B8  0829     MOVF Str, W
09B9  0231     SUBWF d, W
09BA  1D03     BTFSS STATUS, 0x2
09BB  29D2     GOTO 0x1D2
09BC  0828     MOVF Data, W
09BD  0230     SUBWF s2, W
09BE  1D03     BTFSS STATUS, 0x2
09BF  29D2     GOTO 0x1D2
09C0  0827     MOVF reception, W
09C1  022F     SUBWF s, W
09C2  1D03     BTFSS STATUS, 0x2
09C3  29D2     GOTO 0x1D2
09C4  0826     MOVF Nibble, W
09C5  022E     SUBWF fp, W
09C6  1D03     BTFSS STATUS, 0x2
09C7  29D2     GOTO 0x1D2
09C8  0825     MOVF txData, W
09C9  022D     SUBWF 0x2D, W
09CA  1D03     BTFSS STATUS, 0x2
09CB  29D2     GOTO 0x1D2
09CC  0824     MOVF Data, W
09CD  022C     SUBWF i, W
09CE  1D03     BTFSS STATUS, 0x2
09CF  29D2     GOTO 0x1D2
09D0  0823     MOVF data, W
09D1  022B     SUBWF I2C_Add, W
09D2  1C03     BTFSS STATUS, 0x0
09D3  29D5     GOTO 0x1D5
09D4  29D6     GOTO 0x1D6
09D5  29E7     GOTO 0x1E7
34:            				dividend -= divisor;
09D6  0823     MOVF data, W
09D7  02AB     SUBWF I2C_Add, F
09D8  0824     MOVF Data, W
09D9  3BAC     SUBWFB i, F
09DA  0825     MOVF txData, W
09DB  3BAD     SUBWFB 0x2D, F
09DC  0826     MOVF Nibble, W
09DD  3BAE     SUBWFB fp, F
09DE  0827     MOVF reception, W
09DF  3BAF     SUBWFB s, F
09E0  0828     MOVF Data, W
09E1  3BB0     SUBWFB s2, F
09E2  0829     MOVF Str, W
09E3  3BB1     SUBWFB d, F
09E4  082A     MOVF repOperateur, W
09E5  3BB2     SUBWFB c, F
35:            				quotient |= 1;
09E6  1436     BSF buf, 0x0
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
09E7  36AA     LSRF repOperateur, F
09E8  0CA9     RRF Str, F
09E9  0CA8     RRF Data, F
09EA  0CA7     RRF reception, F
09EB  0CA6     RRF Nibble, F
09EC  0CA5     RRF txData, F
09ED  0CA4     RRF Data, F
09EE  0CA3     RRF data, F
38:            		} while(--counter != 0);
09EF  3001     MOVLW 0x1
09F0  02B4     SUBWF counter, F
09F1  1D03     BTFSS STATUS, 0x2
09F2  29F4     GOTO 0x1F4
09F3  29F5     GOTO 0x1F5
09F4  29AC     GOTO 0x1AC
39:            	}
40:            	if(sign)
09F5  0835     MOVF src, W
09F6  1903     BTFSC STATUS, 0x2
09F7  29F9     GOTO 0x1F9
09F8  29FA     GOTO 0x1FA
09F9  2A18     GOTO 0x218
41:            		quotient = -quotient;
09FA  09B6     COMF buf, F
09FB  09B7     COMF p, F
09FC  09B8     COMF 0x38, F
09FD  09B9     COMF 0x39, F
09FE  09BA     COMF i, F
09FF  09BB     COMF 0x3B, F
0A00  09BC     COMF w, F
0A01  09BD     COMF 0x3D, F
0A02  0AB6     INCF buf, F
0A03  1D03     BTFSS STATUS, 0x2
0A04  2A18     GOTO 0x218
0A05  0AB7     INCF p, F
0A06  1D03     BTFSS STATUS, 0x2
0A07  2A18     GOTO 0x218
0A08  0AB8     INCF 0x38, F
0A09  1D03     BTFSS STATUS, 0x2
0A0A  2A18     GOTO 0x218
0A0B  0AB9     INCF 0x39, F
0A0C  1D03     BTFSS STATUS, 0x2
0A0D  2A18     GOTO 0x218
0A0E  0ABA     INCF i, F
0A0F  1D03     BTFSS STATUS, 0x2
0A10  2A18     GOTO 0x218
0A11  0ABB     INCF 0x3B, F
0A12  1D03     BTFSS STATUS, 0x2
0A13  2A18     GOTO 0x218
0A14  0ABC     INCF w, F
0A15  1D03     BTFSS STATUS, 0x2
0A16  2A18     GOTO 0x218
0A17  0ABD     INCF 0x3D, F
42:            	return quotient;
0A18  0020     MOVLB 0x0
0A19  0836     MOVF buf, W
0A1A  00A3     MOVWF data
0A1B  0837     MOVF p, W
0A1C  00A4     MOVWF Data
0A1D  0838     MOVF 0x38, W
0A1E  00A5     MOVWF txData
0A1F  0839     MOVF 0x39, W
0A20  00A6     MOVWF Nibble
0A21  083A     MOVF i, W
0A22  00A7     MOVWF reception
0A23  083B     MOVF 0x3B, W
0A24  00A8     MOVWF Data
0A25  083C     MOVF w, W
0A26  00A9     MOVWF Str
0A27  083D     MOVF 0x3D, W
0A28  00AA     MOVWF repOperateur
43:            }
0A29  0008     RETURN
---  C:/Program Files/Microchip/xc8/v2.32/pic/sources/c99/common/abs.c  ---------------------------------
1:             int abs(int a)
1F87  0020     MOVLB 0x0
1F88  0837     MOVF p, W
1F89  3A80     XORLW 0x80
1F8A  00B8     MOVWF 0x38
1F8B  3080     MOVLW 0x80
1F8C  0238     SUBWF 0x38, W
2:             {
3:             	return a>0 ? a : -a;
1F8D  1D03     BTFSS STATUS, 0x2
1F8E  2F91     GOTO 0x791
1F8F  3001     MOVLW 0x1
1F90  0236     SUBWF buf, W
1F91  1803     BTFSC STATUS, 0x0
1F92  2F94     GOTO 0x794
1F93  2F95     GOTO 0x795
1F94  2FA2     GOTO 0x7A2
1F95  0020     MOVLB 0x0
1F96  0936     COMF buf, W
1F97  00B8     MOVWF 0x38
1F98  0937     COMF p, W
1F99  00B9     MOVWF 0x39
1F9A  0AB8     INCF 0x38, F
1F9B  1903     BTFSC STATUS, 0x2
1F9C  0AB9     INCF 0x39, F
1F9D  0838     MOVF 0x38, W
1F9E  00B6     MOVWF buf
1F9F  0839     MOVF 0x39, W
1FA0  00B7     MOVWF p
1FA1  2FA2     GOTO 0x7A2
4:             }
1FA2  0008     RETURN
